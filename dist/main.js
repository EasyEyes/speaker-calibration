/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["speakerCalibrator"] = factory();
	else
		root["speakerCalibrator"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/mlsGen.js":
/*!************************!*\
  !*** ./dist/mlsGen.js ***!
  \************************/
/***/ (function(module) {

eval("\r\nvar createMLSGenModule = (() => {\r\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\r\n  \r\n  return (\r\nfunction(createMLSGenModule) {\r\n  createMLSGenModule = createMLSGenModule || {};\r\n\r\nvar Module = typeof createMLSGenModule !== \"undefined\" ? createMLSGenModule : {};\r\n\r\nvar readyPromiseResolve, readyPromiseReject;\r\n\r\nModule[\"ready\"] = new Promise(function(resolve, reject) {\r\n readyPromiseResolve = resolve;\r\n readyPromiseReject = reject;\r\n});\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_main\")) {\r\n Object.defineProperty(Module[\"ready\"], \"_main\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"You are getting _main on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n Object.defineProperty(Module[\"ready\"], \"_main\", {\r\n  configurable: true,\r\n  set: function() {\r\n   abort(\"You are setting _main on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n}\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"___getTypeName\")) {\r\n Object.defineProperty(Module[\"ready\"], \"___getTypeName\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"You are getting ___getTypeName on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n Object.defineProperty(Module[\"ready\"], \"___getTypeName\", {\r\n  configurable: true,\r\n  set: function() {\r\n   abort(\"You are setting ___getTypeName on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n}\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"___embind_register_native_and_builtin_types\")) {\r\n Object.defineProperty(Module[\"ready\"], \"___embind_register_native_and_builtin_types\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"You are getting ___embind_register_native_and_builtin_types on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n Object.defineProperty(Module[\"ready\"], \"___embind_register_native_and_builtin_types\", {\r\n  configurable: true,\r\n  set: function() {\r\n   abort(\"You are setting ___embind_register_native_and_builtin_types on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n}\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"___stdio_exit\")) {\r\n Object.defineProperty(Module[\"ready\"], \"___stdio_exit\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"You are getting ___stdio_exit on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n Object.defineProperty(Module[\"ready\"], \"___stdio_exit\", {\r\n  configurable: true,\r\n  set: function() {\r\n   abort(\"You are setting ___stdio_exit on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n}\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"__ZN6__asan9FakeStack17AddrIsInFakeStackEm\")) {\r\n Object.defineProperty(Module[\"ready\"], \"__ZN6__asan9FakeStack17AddrIsInFakeStackEm\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"You are getting __ZN6__asan9FakeStack17AddrIsInFakeStackEm on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n Object.defineProperty(Module[\"ready\"], \"__ZN6__asan9FakeStack17AddrIsInFakeStackEm\", {\r\n  configurable: true,\r\n  set: function() {\r\n   abort(\"You are setting __ZN6__asan9FakeStack17AddrIsInFakeStackEm on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n}\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"__ZN6__asan9FakeStack8AllocateEmmm\")) {\r\n Object.defineProperty(Module[\"ready\"], \"__ZN6__asan9FakeStack8AllocateEmmm\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"You are getting __ZN6__asan9FakeStack8AllocateEmmm on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n Object.defineProperty(Module[\"ready\"], \"__ZN6__asan9FakeStack8AllocateEmmm\", {\r\n  configurable: true,\r\n  set: function() {\r\n   abort(\"You are setting __ZN6__asan9FakeStack8AllocateEmmm on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n}\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"onRuntimeInitialized\")) {\r\n Object.defineProperty(Module[\"ready\"], \"onRuntimeInitialized\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"You are getting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n Object.defineProperty(Module[\"ready\"], \"onRuntimeInitialized\", {\r\n  configurable: true,\r\n  set: function() {\r\n   abort(\"You are setting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\r\n  }\r\n });\r\n}\r\n\r\nvar moduleOverrides = Object.assign({}, Module);\r\n\r\nvar arguments_ = [];\r\n\r\nvar thisProgram = \"./this.program\";\r\n\r\nvar quit_ = (status, toThrow) => {\r\n throw toThrow;\r\n};\r\n\r\nvar ENVIRONMENT_IS_WEB = true;\r\n\r\nvar ENVIRONMENT_IS_WORKER = false;\r\n\r\nvar ENVIRONMENT_IS_NODE = false;\r\n\r\nvar ENVIRONMENT_IS_SHELL = false;\r\n\r\nif (Module[\"ENVIRONMENT\"]) {\r\n throw new Error(\"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)\");\r\n}\r\n\r\nvar scriptDirectory = \"\";\r\n\r\nfunction locateFile(path) {\r\n if (Module[\"locateFile\"]) {\r\n  return Module[\"locateFile\"](path, scriptDirectory);\r\n }\r\n return scriptDirectory + path;\r\n}\r\n\r\nvar read_, readAsync, readBinary, setWindowTitle;\r\n\r\nfunction logExceptionOnExit(e) {\r\n if (e instanceof ExitStatus) return;\r\n let toLog = e;\r\n if (e && typeof e === \"object\" && e.stack) {\r\n  toLog = [ e, e.stack ];\r\n }\r\n err(\"exiting due to exception: \" + toLog);\r\n}\r\n\r\nif (ENVIRONMENT_IS_SHELL) {\r\n if (typeof process === \"object\" && \"function\" === \"function\" || typeof window === \"object\" || typeof importScripts === \"function\") throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\r\n if (typeof read != \"undefined\") {\r\n  read_ = function shell_read(f) {\r\n   return read(f);\r\n  };\r\n }\r\n readBinary = function readBinary(f) {\r\n  let data;\r\n  if (typeof readbuffer === \"function\") {\r\n   return new Uint8Array(readbuffer(f));\r\n  }\r\n  data = read(f, \"binary\");\r\n  assert(typeof data === \"object\");\r\n  return data;\r\n };\r\n readAsync = function readAsync(f, onload, onerror) {\r\n  setTimeout(() => onload(readBinary(f)), 0);\r\n };\r\n if (typeof scriptArgs != \"undefined\") {\r\n  arguments_ = scriptArgs;\r\n } else if (typeof arguments != \"undefined\") {\r\n  arguments_ = arguments;\r\n }\r\n if (typeof quit === \"function\") {\r\n  quit_ = ((status, toThrow) => {\r\n   logExceptionOnExit(toThrow);\r\n   quit(status);\r\n  });\r\n }\r\n if (typeof print !== \"undefined\") {\r\n  if (typeof console === \"undefined\") console = {};\r\n  console.log = print;\r\n  console.warn = console.error = typeof printErr !== \"undefined\" ? printErr : print;\r\n }\r\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n if (ENVIRONMENT_IS_WORKER) {\r\n  scriptDirectory = self.location.href;\r\n } else if (typeof document !== \"undefined\" && document.currentScript) {\r\n  scriptDirectory = document.currentScript.src;\r\n }\r\n if (_scriptDir) {\r\n  scriptDirectory = _scriptDir;\r\n }\r\n if (scriptDirectory.indexOf(\"blob:\") !== 0) {\r\n  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\r\n } else {\r\n  scriptDirectory = \"\";\r\n }\r\n if (!(typeof window === \"object\" || typeof importScripts === \"function\")) throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\r\n {\r\n  read_ = (url => {\r\n   var xhr = new XMLHttpRequest();\r\n   xhr.open(\"GET\", url, false);\r\n   xhr.send(null);\r\n   return xhr.responseText;\r\n  });\r\n  if (ENVIRONMENT_IS_WORKER) {\r\n   readBinary = (url => {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(\"GET\", url, false);\r\n    xhr.responseType = \"arraybuffer\";\r\n    xhr.send(null);\r\n    return new Uint8Array(xhr.response);\r\n   });\r\n  }\r\n  readAsync = ((url, onload, onerror) => {\r\n   var xhr = new XMLHttpRequest();\r\n   xhr.open(\"GET\", url, true);\r\n   xhr.responseType = \"arraybuffer\";\r\n   xhr.onload = (() => {\r\n    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\r\n     onload(xhr.response);\r\n     return;\r\n    }\r\n    onerror();\r\n   });\r\n   xhr.onerror = onerror;\r\n   xhr.send(null);\r\n  });\r\n }\r\n setWindowTitle = (title => document.title = title);\r\n} else {\r\n throw new Error(\"environment detection error\");\r\n}\r\n\r\nvar out = Module[\"print\"] || console.log.bind(console);\r\n\r\nvar err = Module[\"printErr\"] || console.warn.bind(console);\r\n\r\nObject.assign(Module, moduleOverrides);\r\n\r\nmoduleOverrides = null;\r\n\r\nif (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"arguments\")) {\r\n Object.defineProperty(Module, \"arguments\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"Module.arguments has been replaced with plain arguments_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\r\n  }\r\n });\r\n}\r\n\r\nif (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"thisProgram\")) {\r\n Object.defineProperty(Module, \"thisProgram\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"Module.thisProgram has been replaced with plain thisProgram (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\r\n  }\r\n });\r\n}\r\n\r\nif (Module[\"quit\"]) quit_ = Module[\"quit\"];\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"quit\")) {\r\n Object.defineProperty(Module, \"quit\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"Module.quit has been replaced with plain quit_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\r\n  }\r\n });\r\n}\r\n\r\nassert(typeof Module[\"memoryInitializerPrefixURL\"] === \"undefined\", \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\");\r\n\r\nassert(typeof Module[\"pthreadMainPrefixURL\"] === \"undefined\", \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\");\r\n\r\nassert(typeof Module[\"cdInitializerPrefixURL\"] === \"undefined\", \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\");\r\n\r\nassert(typeof Module[\"filePackagePrefixURL\"] === \"undefined\", \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\");\r\n\r\nassert(typeof Module[\"read\"] === \"undefined\", \"Module.read option was removed (modify read_ in JS)\");\r\n\r\nassert(typeof Module[\"readAsync\"] === \"undefined\", \"Module.readAsync option was removed (modify readAsync in JS)\");\r\n\r\nassert(typeof Module[\"readBinary\"] === \"undefined\", \"Module.readBinary option was removed (modify readBinary in JS)\");\r\n\r\nassert(typeof Module[\"setWindowTitle\"] === \"undefined\", \"Module.setWindowTitle option was removed (modify setWindowTitle in JS)\");\r\n\r\nassert(typeof Module[\"TOTAL_MEMORY\"] === \"undefined\", \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\");\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"read\")) {\r\n Object.defineProperty(Module, \"read\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"Module.read has been replaced with plain read_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\r\n  }\r\n });\r\n}\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"readAsync\")) {\r\n Object.defineProperty(Module, \"readAsync\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"Module.readAsync has been replaced with plain readAsync (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\r\n  }\r\n });\r\n}\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"readBinary\")) {\r\n Object.defineProperty(Module, \"readBinary\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"Module.readBinary has been replaced with plain readBinary (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\r\n  }\r\n });\r\n}\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"setWindowTitle\")) {\r\n Object.defineProperty(Module, \"setWindowTitle\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"Module.setWindowTitle has been replaced with plain setWindowTitle (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\r\n  }\r\n });\r\n}\r\n\r\nassert(!ENVIRONMENT_IS_WORKER, \"worker environment detected but not enabled at build time.  Add 'worker' to `-s ENVIRONMENT` to enable.\");\r\n\r\nassert(!ENVIRONMENT_IS_NODE, \"node environment detected but not enabled at build time.  Add 'node' to `-s ENVIRONMENT` to enable.\");\r\n\r\nassert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-s ENVIRONMENT` to enable.\");\r\n\r\nvar POINTER_SIZE = 4;\r\n\r\nfunction warnOnce(text) {\r\n if (!warnOnce.shown) warnOnce.shown = {};\r\n if (!warnOnce.shown[text]) {\r\n  warnOnce.shown[text] = 1;\r\n  err(text);\r\n }\r\n}\r\n\r\nfunction convertJsFunctionToWasm(func, sig) {\r\n if (typeof WebAssembly.Function === \"function\") {\r\n  var typeNames = {\r\n   \"i\": \"i32\",\r\n   \"j\": \"i64\",\r\n   \"f\": \"f32\",\r\n   \"d\": \"f64\"\r\n  };\r\n  var type = {\r\n   parameters: [],\r\n   results: sig[0] == \"v\" ? [] : [ typeNames[sig[0]] ]\r\n  };\r\n  for (var i = 1; i < sig.length; ++i) {\r\n   type.parameters.push(typeNames[sig[i]]);\r\n  }\r\n  return new WebAssembly.Function(type, func);\r\n }\r\n var typeSection = [ 1, 0, 1, 96 ];\r\n var sigRet = sig.slice(0, 1);\r\n var sigParam = sig.slice(1);\r\n var typeCodes = {\r\n  \"i\": 127,\r\n  \"j\": 126,\r\n  \"f\": 125,\r\n  \"d\": 124\r\n };\r\n typeSection.push(sigParam.length);\r\n for (var i = 0; i < sigParam.length; ++i) {\r\n  typeSection.push(typeCodes[sigParam[i]]);\r\n }\r\n if (sigRet == \"v\") {\r\n  typeSection.push(0);\r\n } else {\r\n  typeSection = typeSection.concat([ 1, typeCodes[sigRet] ]);\r\n }\r\n typeSection[1] = typeSection.length - 2;\r\n var bytes = new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0 ].concat(typeSection, [ 2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0 ]));\r\n var module = new WebAssembly.Module(bytes);\r\n var instance = new WebAssembly.Instance(module, {\r\n  \"e\": {\r\n   \"f\": func\r\n  }\r\n });\r\n var wrappedFunc = instance.exports[\"f\"];\r\n return wrappedFunc;\r\n}\r\n\r\nvar freeTableIndexes = [];\r\n\r\nvar functionsInTableMap;\r\n\r\nfunction getEmptyTableSlot() {\r\n if (freeTableIndexes.length) {\r\n  return freeTableIndexes.pop();\r\n }\r\n try {\r\n  wasmTable.grow(1);\r\n } catch (err) {\r\n  if (!(err instanceof RangeError)) {\r\n   throw err;\r\n  }\r\n  throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\r\n }\r\n return wasmTable.length - 1;\r\n}\r\n\r\nfunction updateTableMap(offset, count) {\r\n for (var i = offset; i < offset + count; i++) {\r\n  var item = getWasmTableEntry(i);\r\n  if (item) {\r\n   functionsInTableMap.set(item, i);\r\n  }\r\n }\r\n}\r\n\r\nvar tempRet0 = 0;\r\n\r\nvar setTempRet0 = value => {\r\n tempRet0 = value;\r\n};\r\n\r\nvar wasmBinary;\r\n\r\nif (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"wasmBinary\")) {\r\n Object.defineProperty(Module, \"wasmBinary\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"Module.wasmBinary has been replaced with plain wasmBinary (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\r\n  }\r\n });\r\n}\r\n\r\nvar noExitRuntime = Module[\"noExitRuntime\"] || false;\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"noExitRuntime\")) {\r\n Object.defineProperty(Module, \"noExitRuntime\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"Module.noExitRuntime has been replaced with plain noExitRuntime (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\r\n  }\r\n });\r\n}\r\n\r\nif (typeof WebAssembly !== \"object\") {\r\n abort(\"no native wasm support detected\");\r\n}\r\n\r\nfunction _asan_js_load_1(ptr) {\r\n if (runtimeInitialized) return _asan_c_load_1(ptr);\r\n return HEAP8[ptr];\r\n}\r\n\r\nfunction _asan_js_load_1u(ptr) {\r\n if (runtimeInitialized) return _asan_c_load_1u(ptr);\r\n return HEAPU8[ptr];\r\n}\r\n\r\nfunction _asan_js_load_2(ptr) {\r\n if (runtimeInitialized) return _asan_c_load_2(ptr);\r\n return HEAP16[ptr];\r\n}\r\n\r\nfunction _asan_js_load_2u(ptr) {\r\n if (runtimeInitialized) return _asan_c_load_2u(ptr);\r\n return HEAPU16[ptr];\r\n}\r\n\r\nfunction _asan_js_load_4(ptr) {\r\n if (runtimeInitialized) return _asan_c_load_4(ptr);\r\n return HEAP32[ptr];\r\n}\r\n\r\nfunction _asan_js_load_4u(ptr) {\r\n if (runtimeInitialized) return _asan_c_load_4u(ptr) >>> 0;\r\n return HEAPU32[ptr];\r\n}\r\n\r\nfunction _asan_js_load_f(ptr) {\r\n if (runtimeInitialized) return _asan_c_load_f(ptr);\r\n return HEAPF32[ptr];\r\n}\r\n\r\nfunction _asan_js_load_d(ptr) {\r\n if (runtimeInitialized) return _asan_c_load_d(ptr);\r\n return HEAPF64[ptr];\r\n}\r\n\r\nfunction _asan_js_store_1(ptr, val) {\r\n if (runtimeInitialized) return _asan_c_store_1(ptr, val);\r\n return HEAP8[ptr] = val;\r\n}\r\n\r\nfunction _asan_js_store_1u(ptr, val) {\r\n if (runtimeInitialized) return _asan_c_store_1u(ptr, val);\r\n return HEAPU8[ptr] = val;\r\n}\r\n\r\nfunction _asan_js_store_2(ptr, val) {\r\n if (runtimeInitialized) return _asan_c_store_2(ptr, val);\r\n return HEAP16[ptr] = val;\r\n}\r\n\r\nfunction _asan_js_store_4(ptr, val) {\r\n if (runtimeInitialized) return _asan_c_store_4(ptr, val);\r\n return HEAP32[ptr] = val;\r\n}\r\n\r\nfunction _asan_js_store_4u(ptr, val) {\r\n if (runtimeInitialized) return _asan_c_store_4u(ptr, val) >>> 0;\r\n return HEAPU32[ptr] = val;\r\n}\r\n\r\nfunction _asan_js_store_f(ptr, val) {\r\n if (runtimeInitialized) return _asan_c_store_f(ptr, val);\r\n return HEAPF32[ptr] = val;\r\n}\r\n\r\nfunction _asan_js_store_d(ptr, val) {\r\n if (runtimeInitialized) return _asan_c_store_d(ptr, val);\r\n return HEAPF64[ptr] = val;\r\n}\r\n\r\nvar wasmMemory;\r\n\r\nvar ABORT = false;\r\n\r\nvar EXITSTATUS;\r\n\r\nfunction assert(condition, text) {\r\n if (!condition) {\r\n  abort(\"Assertion failed\" + (text ? \": \" + text : \"\"));\r\n }\r\n}\r\n\r\nfunction getCFunc(ident) {\r\n var func = Module[\"_\" + ident];\r\n assert(func, \"Cannot call unknown function \" + ident + \", make sure it is exported\");\r\n return func;\r\n}\r\n\r\nfunction ccall(ident, returnType, argTypes, args, opts) {\r\n var toC = {\r\n  \"string\": function(str) {\r\n   var ret = 0;\r\n   if (str !== null && str !== undefined && str !== 0) {\r\n    var len = (str.length << 2) + 1;\r\n    ret = stackAlloc(len);\r\n    stringToUTF8(str, ret, len);\r\n   }\r\n   return ret;\r\n  },\r\n  \"array\": function(arr) {\r\n   var ret = stackAlloc(arr.length);\r\n   writeArrayToMemory(arr, ret);\r\n   return ret;\r\n  }\r\n };\r\n function convertReturnValue(ret) {\r\n  if (returnType === \"string\") return UTF8ToString(ret);\r\n  if (returnType === \"boolean\") return Boolean(ret);\r\n  return ret;\r\n }\r\n var func = getCFunc(ident);\r\n var cArgs = [];\r\n var stack = 0;\r\n assert(returnType !== \"array\", 'Return type should not be \"array\".');\r\n if (args) {\r\n  for (var i = 0; i < args.length; i++) {\r\n   var converter = toC[argTypes[i]];\r\n   if (converter) {\r\n    if (stack === 0) stack = stackSave();\r\n    cArgs[i] = converter(args[i]);\r\n   } else {\r\n    cArgs[i] = args[i];\r\n   }\r\n  }\r\n }\r\n var ret = func.apply(null, cArgs);\r\n function onDone(ret) {\r\n  if (stack !== 0) stackRestore(stack);\r\n  return convertReturnValue(ret);\r\n }\r\n ret = onDone(ret);\r\n return ret;\r\n}\r\n\r\nvar ALLOC_STACK = 1;\r\n\r\nvar UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\r\n\r\nfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\r\n var endIdx = idx + maxBytesToRead;\r\n var endPtr = idx;\r\n while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\r\n if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\r\n  return UTF8Decoder.decode(heap.subarray(idx, endPtr));\r\n } else {\r\n  var str = \"\";\r\n  while (idx < endPtr) {\r\n   var u0 = heap[idx++];\r\n   if (!(u0 & 128)) {\r\n    str += String.fromCharCode(u0);\r\n    continue;\r\n   }\r\n   var u1 = heap[idx++] & 63;\r\n   if ((u0 & 224) == 192) {\r\n    str += String.fromCharCode((u0 & 31) << 6 | u1);\r\n    continue;\r\n   }\r\n   var u2 = heap[idx++] & 63;\r\n   if ((u0 & 240) == 224) {\r\n    u0 = (u0 & 15) << 12 | u1 << 6 | u2;\r\n   } else {\r\n    if ((u0 & 248) != 240) warnOnce(\"Invalid UTF-8 leading byte 0x\" + u0.toString(16) + \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\");\r\n    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\r\n   }\r\n   if (u0 < 65536) {\r\n    str += String.fromCharCode(u0);\r\n   } else {\r\n    var ch = u0 - 65536;\r\n    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\r\n   }\r\n  }\r\n }\r\n return str;\r\n}\r\n\r\nfunction UTF8ToString(ptr, maxBytesToRead) {\r\n return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\r\n}\r\n\r\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\r\n if (!(maxBytesToWrite > 0)) return 0;\r\n var startIdx = outIdx;\r\n var endIdx = outIdx + maxBytesToWrite - 1;\r\n for (var i = 0; i < str.length; ++i) {\r\n  var u = str.charCodeAt(i);\r\n  if (u >= 55296 && u <= 57343) {\r\n   var u1 = str.charCodeAt(++i);\r\n   u = 65536 + ((u & 1023) << 10) | u1 & 1023;\r\n  }\r\n  if (u <= 127) {\r\n   if (outIdx >= endIdx) break;\r\n   heap[outIdx++] = u;\r\n  } else if (u <= 2047) {\r\n   if (outIdx + 1 >= endIdx) break;\r\n   heap[outIdx++] = 192 | u >> 6;\r\n   heap[outIdx++] = 128 | u & 63;\r\n  } else if (u <= 65535) {\r\n   if (outIdx + 2 >= endIdx) break;\r\n   heap[outIdx++] = 224 | u >> 12;\r\n   heap[outIdx++] = 128 | u >> 6 & 63;\r\n   heap[outIdx++] = 128 | u & 63;\r\n  } else {\r\n   if (outIdx + 3 >= endIdx) break;\r\n   if (u > 1114111) warnOnce(\"Invalid Unicode code point 0x\" + u.toString(16) + \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\");\r\n   heap[outIdx++] = 240 | u >> 18;\r\n   heap[outIdx++] = 128 | u >> 12 & 63;\r\n   heap[outIdx++] = 128 | u >> 6 & 63;\r\n   heap[outIdx++] = 128 | u & 63;\r\n  }\r\n }\r\n heap[outIdx] = 0;\r\n return outIdx - startIdx;\r\n}\r\n\r\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\r\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\r\n return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\r\n}\r\n\r\nfunction lengthBytesUTF8(str) {\r\n var len = 0;\r\n for (var i = 0; i < str.length; ++i) {\r\n  var u = str.charCodeAt(i);\r\n  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\r\n  if (u <= 127) ++len; else if (u <= 2047) len += 2; else if (u <= 65535) len += 3; else len += 4;\r\n }\r\n return len;\r\n}\r\n\r\nvar UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\r\n\r\nfunction UTF16ToString(ptr, maxBytesToRead) {\r\n assert(ptr % 2 == 0, \"Pointer passed to UTF16ToString must be aligned to two bytes!\");\r\n var endPtr = ptr;\r\n var idx = endPtr >> 1;\r\n var maxIdx = idx + maxBytesToRead / 2;\r\n while (!(idx >= maxIdx) && _asan_js_load_2u(idx)) ++idx;\r\n endPtr = idx << 1;\r\n if (endPtr - ptr > 32 && UTF16Decoder) {\r\n  return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\r\n } else {\r\n  var str = \"\";\r\n  for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\r\n   var codeUnit = _asan_js_load_2(ptr + i * 2 >> 1);\r\n   if (codeUnit == 0) break;\r\n   str += String.fromCharCode(codeUnit);\r\n  }\r\n  return str;\r\n }\r\n}\r\n\r\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\r\n assert(outPtr % 2 == 0, \"Pointer passed to stringToUTF16 must be aligned to two bytes!\");\r\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\r\n if (maxBytesToWrite === undefined) {\r\n  maxBytesToWrite = 2147483647;\r\n }\r\n if (maxBytesToWrite < 2) return 0;\r\n maxBytesToWrite -= 2;\r\n var startPtr = outPtr;\r\n var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\r\n for (var i = 0; i < numCharsToWrite; ++i) {\r\n  var codeUnit = str.charCodeAt(i);\r\n  _asan_js_store_2(outPtr >> 1, codeUnit);\r\n  outPtr += 2;\r\n }\r\n _asan_js_store_2(outPtr >> 1, 0);\r\n return outPtr - startPtr;\r\n}\r\n\r\nfunction lengthBytesUTF16(str) {\r\n return str.length * 2;\r\n}\r\n\r\nfunction UTF32ToString(ptr, maxBytesToRead) {\r\n assert(ptr % 4 == 0, \"Pointer passed to UTF32ToString must be aligned to four bytes!\");\r\n var i = 0;\r\n var str = \"\";\r\n while (!(i >= maxBytesToRead / 4)) {\r\n  var utf32 = _asan_js_load_4(ptr + i * 4 >> 2);\r\n  if (utf32 == 0) break;\r\n  ++i;\r\n  if (utf32 >= 65536) {\r\n   var ch = utf32 - 65536;\r\n   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\r\n  } else {\r\n   str += String.fromCharCode(utf32);\r\n  }\r\n }\r\n return str;\r\n}\r\n\r\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\r\n assert(outPtr % 4 == 0, \"Pointer passed to stringToUTF32 must be aligned to four bytes!\");\r\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\r\n if (maxBytesToWrite === undefined) {\r\n  maxBytesToWrite = 2147483647;\r\n }\r\n if (maxBytesToWrite < 4) return 0;\r\n var startPtr = outPtr;\r\n var endPtr = startPtr + maxBytesToWrite - 4;\r\n for (var i = 0; i < str.length; ++i) {\r\n  var codeUnit = str.charCodeAt(i);\r\n  if (codeUnit >= 55296 && codeUnit <= 57343) {\r\n   var trailSurrogate = str.charCodeAt(++i);\r\n   codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\r\n  }\r\n  _asan_js_store_4(outPtr >> 2, codeUnit);\r\n  outPtr += 4;\r\n  if (outPtr + 4 > endPtr) break;\r\n }\r\n _asan_js_store_4(outPtr >> 2, 0);\r\n return outPtr - startPtr;\r\n}\r\n\r\nfunction lengthBytesUTF32(str) {\r\n var len = 0;\r\n for (var i = 0; i < str.length; ++i) {\r\n  var codeUnit = str.charCodeAt(i);\r\n  if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\r\n  len += 4;\r\n }\r\n return len;\r\n}\r\n\r\nfunction allocateUTF8(str) {\r\n var size = lengthBytesUTF8(str) + 1;\r\n var ret = _malloc(size);\r\n if (ret) stringToUTF8Array(str, HEAP8, ret, size);\r\n return ret;\r\n}\r\n\r\nfunction writeArrayToMemory(array, buffer) {\r\n assert(array.length >= 0, \"writeArrayToMemory array must have a length (should be an array or typed array)\");\r\n HEAP8.set(array, buffer);\r\n}\r\n\r\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\r\n for (var i = 0; i < str.length; ++i) {\r\n  assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));\r\n  _asan_js_store_1(buffer++ >> 0, str.charCodeAt(i));\r\n }\r\n if (!dontAddNull) _asan_js_store_1(buffer >> 0, 0);\r\n}\r\n\r\nvar buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\r\n\r\nfunction updateGlobalBufferAndViews(buf) {\r\n buffer = buf;\r\n Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\r\n Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\r\n Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\r\n Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\r\n Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\r\n Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\r\n Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\r\n Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\r\n}\r\n\r\nvar TOTAL_STACK = 5242880;\r\n\r\nif (Module[\"TOTAL_STACK\"]) assert(TOTAL_STACK === Module[\"TOTAL_STACK\"], \"the stack size can no longer be determined at runtime\");\r\n\r\nvar INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 79101952;\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"INITIAL_MEMORY\")) {\r\n Object.defineProperty(Module, \"INITIAL_MEMORY\", {\r\n  configurable: true,\r\n  get: function() {\r\n   abort(\"Module.INITIAL_MEMORY has been replaced with plain INITIAL_MEMORY (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\r\n  }\r\n });\r\n}\r\n\r\nassert(INITIAL_MEMORY >= TOTAL_STACK, \"INITIAL_MEMORY should be larger than TOTAL_STACK, was \" + INITIAL_MEMORY + \"! (TOTAL_STACK=\" + TOTAL_STACK + \")\");\r\n\r\nassert(typeof Int32Array !== \"undefined\" && typeof Float64Array !== \"undefined\" && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, \"JS engine does not provide full typed array support\");\r\n\r\nassert(!Module[\"wasmMemory\"], \"Use of `wasmMemory` detected.  Use -s IMPORTED_MEMORY to define wasmMemory externally\");\r\n\r\nassert(INITIAL_MEMORY == 79101952, \"Detected runtime INITIAL_MEMORY setting.  Use -s IMPORTED_MEMORY to define wasmMemory dynamically\");\r\n\r\nvar wasmTable;\r\n\r\nfunction writeStackCookie() {\r\n var max = _emscripten_stack_get_end();\r\n assert((max & 3) == 0);\r\n _asan_js_store_4(max + 4 >> 2, 34821223);\r\n _asan_js_store_4(max + 8 >> 2, 2310721022);\r\n}\r\n\r\nfunction checkStackCookie() {\r\n if (ABORT) return;\r\n var max = _emscripten_stack_get_end();\r\n var cookie1 = _asan_js_load_4u(max + 4 >> 2);\r\n var cookie2 = _asan_js_load_4u(max + 8 >> 2);\r\n if (cookie1 != 34821223 || cookie2 != 2310721022) {\r\n  abort(\"Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x\" + cookie2.toString(16) + \" 0x\" + cookie1.toString(16));\r\n }\r\n}\r\n\r\n(function() {\r\n var h16 = new Int16Array(1);\r\n var h8 = new Int8Array(h16.buffer);\r\n h16[0] = 25459;\r\n if (h8[0] !== 115 || h8[1] !== 99) throw \"Runtime error: expected the system to be little-endian! (Run with -s SUPPORT_BIG_ENDIAN=1 to bypass)\";\r\n})();\r\n\r\nvar __ATPRERUN__ = [];\r\n\r\nvar __ATINIT__ = [];\r\n\r\nvar __ATEXIT__ = [];\r\n\r\nvar __ATPOSTRUN__ = [];\r\n\r\nvar runtimeInitialized = false;\r\n\r\nvar runtimeExited = false;\r\n\r\nvar runtimeKeepaliveCounter = 0;\r\n\r\nfunction keepRuntimeAlive() {\r\n return noExitRuntime || runtimeKeepaliveCounter > 0;\r\n}\r\n\r\nfunction preRun() {\r\n if (Module[\"preRun\"]) {\r\n  if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [ Module[\"preRun\"] ];\r\n  while (Module[\"preRun\"].length) {\r\n   addOnPreRun(Module[\"preRun\"].shift());\r\n  }\r\n }\r\n callRuntimeCallbacks(__ATPRERUN__);\r\n}\r\n\r\nfunction initRuntime() {\r\n checkStackCookie();\r\n assert(!runtimeInitialized);\r\n runtimeInitialized = true;\r\n if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\r\n FS.ignorePermissions = false;\r\n TTY.init();\r\n callRuntimeCallbacks(__ATINIT__);\r\n}\r\n\r\nfunction exitRuntime() {\r\n checkStackCookie();\r\n ___funcs_on_exit();\r\n callRuntimeCallbacks(__ATEXIT__);\r\n FS.quit();\r\n TTY.shutdown();\r\n runtimeExited = true;\r\n}\r\n\r\nfunction postRun() {\r\n checkStackCookie();\r\n if (Module[\"postRun\"]) {\r\n  if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [ Module[\"postRun\"] ];\r\n  while (Module[\"postRun\"].length) {\r\n   addOnPostRun(Module[\"postRun\"].shift());\r\n  }\r\n }\r\n callRuntimeCallbacks(__ATPOSTRUN__);\r\n}\r\n\r\nfunction addOnPreRun(cb) {\r\n __ATPRERUN__.unshift(cb);\r\n}\r\n\r\nfunction addOnInit(cb) {\r\n __ATINIT__.unshift(cb);\r\n}\r\n\r\nfunction addOnPostRun(cb) {\r\n __ATPOSTRUN__.unshift(cb);\r\n}\r\n\r\nassert(Math.imul, \"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\r\n\r\nassert(Math.fround, \"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\r\n\r\nassert(Math.clz32, \"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\r\n\r\nassert(Math.trunc, \"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\r\n\r\nvar runDependencies = 0;\r\n\r\nvar runDependencyWatcher = null;\r\n\r\nvar dependenciesFulfilled = null;\r\n\r\nvar runDependencyTracking = {};\r\n\r\nfunction getUniqueRunDependency(id) {\r\n var orig = id;\r\n while (1) {\r\n  if (!runDependencyTracking[id]) return id;\r\n  id = orig + Math.random();\r\n }\r\n}\r\n\r\nfunction addRunDependency(id) {\r\n runDependencies++;\r\n if (Module[\"monitorRunDependencies\"]) {\r\n  Module[\"monitorRunDependencies\"](runDependencies);\r\n }\r\n if (id) {\r\n  assert(!runDependencyTracking[id]);\r\n  runDependencyTracking[id] = 1;\r\n  if (runDependencyWatcher === null && typeof setInterval !== \"undefined\") {\r\n   runDependencyWatcher = setInterval(function() {\r\n    if (ABORT) {\r\n     clearInterval(runDependencyWatcher);\r\n     runDependencyWatcher = null;\r\n     return;\r\n    }\r\n    var shown = false;\r\n    for (var dep in runDependencyTracking) {\r\n     if (!shown) {\r\n      shown = true;\r\n      err(\"still waiting on run dependencies:\");\r\n     }\r\n     err(\"dependency: \" + dep);\r\n    }\r\n    if (shown) {\r\n     err(\"(end of list)\");\r\n    }\r\n   }, 1e4);\r\n  }\r\n } else {\r\n  err(\"warning: run dependency added without ID\");\r\n }\r\n}\r\n\r\nfunction removeRunDependency(id) {\r\n runDependencies--;\r\n if (Module[\"monitorRunDependencies\"]) {\r\n  Module[\"monitorRunDependencies\"](runDependencies);\r\n }\r\n if (id) {\r\n  assert(runDependencyTracking[id]);\r\n  delete runDependencyTracking[id];\r\n } else {\r\n  err(\"warning: run dependency removed without ID\");\r\n }\r\n if (runDependencies == 0) {\r\n  if (runDependencyWatcher !== null) {\r\n   clearInterval(runDependencyWatcher);\r\n   runDependencyWatcher = null;\r\n  }\r\n  if (dependenciesFulfilled) {\r\n   var callback = dependenciesFulfilled;\r\n   dependenciesFulfilled = null;\r\n   callback();\r\n  }\r\n }\r\n}\r\n\r\nModule[\"preloadedImages\"] = {};\r\n\r\nModule[\"preloadedAudios\"] = {};\r\n\r\nfunction abort(what) {\r\n {\r\n  if (Module[\"onAbort\"]) {\r\n   Module[\"onAbort\"](what);\r\n  }\r\n }\r\n what = \"Aborted(\" + what + \")\";\r\n err(what);\r\n ABORT = true;\r\n EXITSTATUS = 1;\r\n var e = new WebAssembly.RuntimeError(what);\r\n readyPromiseReject(e);\r\n throw e;\r\n}\r\n\r\nvar dataURIPrefix = \"data:application/octet-stream;base64,\";\r\n\r\nfunction isDataURI(filename) {\r\n return filename.startsWith(dataURIPrefix);\r\n}\r\n\r\nfunction isFileURI(filename) {\r\n return filename.startsWith(\"file://\");\r\n}\r\n\r\nfunction createExportWrapper(name, fixedasm) {\r\n return function() {\r\n  var displayName = name;\r\n  var asm = fixedasm;\r\n  if (!fixedasm) {\r\n   asm = Module[\"asm\"];\r\n  }\r\n  assert(runtimeInitialized, \"native function `\" + displayName + \"` called before runtime initialization\");\r\n  assert(!runtimeExited, \"native function `\" + displayName + \"` called after runtime exit (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\r\n  if (!asm[name]) {\r\n   assert(asm[name], \"exported native function `\" + displayName + \"` not found\");\r\n  }\r\n  return asm[name].apply(null, arguments);\r\n };\r\n}\r\n\r\nvar wasmBinaryFile;\r\n\r\nwasmBinaryFile = \"mlsGen.wasm\";\r\n\r\nif (!isDataURI(wasmBinaryFile)) {\r\n wasmBinaryFile = locateFile(wasmBinaryFile);\r\n}\r\n\r\nfunction getBinary(file) {\r\n try {\r\n  if (file == wasmBinaryFile && wasmBinary) {\r\n   return new Uint8Array(wasmBinary);\r\n  }\r\n  if (readBinary) {\r\n   return readBinary(file);\r\n  } else {\r\n   throw \"both async and sync fetching of the wasm failed\";\r\n  }\r\n } catch (err) {\r\n  abort(err);\r\n }\r\n}\r\n\r\nfunction getBinaryPromise() {\r\n if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\r\n  if (typeof fetch === \"function\") {\r\n   return fetch(wasmBinaryFile, {\r\n    credentials: \"same-origin\"\r\n   }).then(function(response) {\r\n    if (!response[\"ok\"]) {\r\n     throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\r\n    }\r\n    return response[\"arrayBuffer\"]();\r\n   }).catch(function() {\r\n    return getBinary(wasmBinaryFile);\r\n   });\r\n  }\r\n }\r\n return Promise.resolve().then(function() {\r\n  return getBinary(wasmBinaryFile);\r\n });\r\n}\r\n\r\nvar wasmOffsetConverter;\r\n\r\nfunction WasmOffsetConverter(wasmBytes, wasmModule) {\r\n var offset = 8;\r\n var funcidx = 0;\r\n this.offset_map = {};\r\n this.func_starts = [];\r\n this.name_map = {};\r\n this.import_functions = 0;\r\n var buffer = wasmBytes;\r\n function unsignedLEB128() {\r\n  var result = 0;\r\n  var shift = 0;\r\n  do {\r\n   var byte = buffer[offset++];\r\n   result += (byte & 127) << shift;\r\n   shift += 7;\r\n  } while (byte & 128);\r\n  return result;\r\n }\r\n function skipLimits() {\r\n  var flags = unsignedLEB128();\r\n  unsignedLEB128();\r\n  var hasMax = (flags & 1) != 0;\r\n  if (hasMax) {\r\n   unsignedLEB128();\r\n  }\r\n }\r\n binary_parse: while (offset < buffer.length) {\r\n  var type = buffer[offset++];\r\n  var end = unsignedLEB128() + offset;\r\n  switch (type) {\r\n  case 2:\r\n   var count = unsignedLEB128();\r\n   while (count-- > 0) {\r\n    offset = unsignedLEB128() + offset;\r\n    offset = unsignedLEB128() + offset;\r\n    switch (buffer[offset++]) {\r\n    case 0:\r\n     ++funcidx;\r\n     unsignedLEB128();\r\n     break;\r\n\r\n    case 1:\r\n     ++offset;\r\n     skipLimits();\r\n     break;\r\n\r\n    case 2:\r\n     skipLimits();\r\n     break;\r\n\r\n    case 3:\r\n     offset += 2;\r\n     break;\r\n\r\n    default:\r\n     throw \"bad import kind\";\r\n    }\r\n   }\r\n   this.import_functions = funcidx;\r\n   break;\r\n\r\n  case 10:\r\n   var count = unsignedLEB128();\r\n   while (count-- > 0) {\r\n    var size = unsignedLEB128();\r\n    this.offset_map[funcidx++] = offset;\r\n    this.func_starts.push(offset);\r\n    offset += size;\r\n   }\r\n   break binary_parse;\r\n  }\r\n  offset = end;\r\n }\r\n var sections = WebAssembly.Module.customSections(wasmModule, \"name\");\r\n for (var i = 0; i < sections.length; ++i) {\r\n  buffer = new Uint8Array(sections[i]);\r\n  if (buffer[0] != 1) continue;\r\n  offset = 1;\r\n  unsignedLEB128();\r\n  var count = unsignedLEB128();\r\n  while (count-- > 0) {\r\n   var index = unsignedLEB128();\r\n   var length = unsignedLEB128();\r\n   this.name_map[index] = UTF8ArrayToString(buffer, offset, length);\r\n   offset += length;\r\n  }\r\n }\r\n}\r\n\r\nWasmOffsetConverter.prototype.convert = function(funcidx, offset) {\r\n return this.offset_map[funcidx] + offset;\r\n};\r\n\r\nWasmOffsetConverter.prototype.getIndex = function(offset) {\r\n var lo = 0;\r\n var hi = this.func_starts.length;\r\n var mid;\r\n while (lo < hi) {\r\n  mid = Math.floor((lo + hi) / 2);\r\n  if (this.func_starts[mid] > offset) {\r\n   hi = mid;\r\n  } else {\r\n   lo = mid + 1;\r\n  }\r\n }\r\n return lo + this.import_functions - 1;\r\n};\r\n\r\nWasmOffsetConverter.prototype.isSameFunc = function(offset1, offset2) {\r\n return this.getIndex(offset1) == this.getIndex(offset2);\r\n};\r\n\r\nWasmOffsetConverter.prototype.getName = function(offset) {\r\n var index = this.getIndex(offset);\r\n return this.name_map[index] || \"wasm-function[\" + index + \"]\";\r\n};\r\n\r\nfunction resetPrototype(constructor, attrs) {\r\n var object = Object.create(constructor.prototype);\r\n return Object.assign(object, attrs);\r\n}\r\n\r\nfunction createWasm() {\r\n var info = {\r\n  \"env\": asmLibraryArg,\r\n  \"wasi_snapshot_preview1\": asmLibraryArg\r\n };\r\n function receiveInstance(instance, module) {\r\n  var exports = instance.exports;\r\n  Module[\"asm\"] = exports;\r\n  wasmMemory = Module[\"asm\"][\"memory\"];\r\n  assert(wasmMemory, \"memory not found in wasm exports\");\r\n  updateGlobalBufferAndViews(wasmMemory.buffer);\r\n  wasmTable = Module[\"asm\"][\"__indirect_function_table\"];\r\n  assert(wasmTable, \"table not found in wasm exports\");\r\n  addOnInit(Module[\"asm\"][\"__wasm_call_ctors\"]);\r\n  removeRunDependency(\"wasm-instantiate\");\r\n }\r\n addRunDependency(\"wasm-instantiate\");\r\n var trueModule = Module;\r\n function receiveInstantiationResult(result) {\r\n  assert(Module === trueModule, \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\");\r\n  trueModule = null;\r\n  receiveInstance(result[\"instance\"]);\r\n }\r\n function instantiateArrayBuffer(receiver) {\r\n  var savedBinary;\r\n  return getBinaryPromise().then(function(binary) {\r\n   savedBinary = binary;\r\n   return WebAssembly.instantiate(binary, info);\r\n  }).then(function(instance) {\r\n   wasmOffsetConverter = new WasmOffsetConverter(savedBinary, instance.module);\r\n   return instance;\r\n  }).then(receiver, function(reason) {\r\n   err(\"failed to asynchronously prepare wasm: \" + reason);\r\n   if (isFileURI(wasmBinaryFile)) {\r\n    err(\"warning: Loading from a file URI (\" + wasmBinaryFile + \") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing\");\r\n   }\r\n   abort(reason);\r\n  });\r\n }\r\n function instantiateAsync() {\r\n  if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && typeof fetch === \"function\") {\r\n   return fetch(wasmBinaryFile, {\r\n    credentials: \"same-origin\"\r\n   }).then(function(response) {\r\n    var result = WebAssembly.instantiateStreaming(response, info);\r\n    var clonedResponsePromise = response.clone().arrayBuffer();\r\n    return result.then(function(instantiationResult) {\r\n     clonedResponsePromise.then(function(arrayBufferResult) {\r\n      wasmOffsetConverter = new WasmOffsetConverter(new Uint8Array(arrayBufferResult), instantiationResult.module);\r\n      receiveInstantiationResult(instantiationResult);\r\n     }, function(reason) {\r\n      err(\"failed to initialize offset-converter: \" + reason);\r\n     });\r\n    }, function(reason) {\r\n     err(\"wasm streaming compile failed: \" + reason);\r\n     err(\"falling back to ArrayBuffer instantiation\");\r\n     return instantiateArrayBuffer(receiveInstantiationResult);\r\n    });\r\n   });\r\n  } else {\r\n   return instantiateArrayBuffer(receiveInstantiationResult);\r\n  }\r\n }\r\n if (Module[\"instantiateWasm\"]) {\r\n  wasmOffsetConverter = resetPrototype(WasmOffsetConverter, Module[\"wasmOffsetData\"]);\r\n  try {\r\n   var exports = Module[\"instantiateWasm\"](info, receiveInstance);\r\n   return exports;\r\n  } catch (e) {\r\n   err(\"Module.instantiateWasm callback failed with error: \" + e);\r\n   return false;\r\n  }\r\n }\r\n instantiateAsync().catch(readyPromiseReject);\r\n return {};\r\n}\r\n\r\nvar tempDouble;\r\n\r\nvar tempI64;\r\n\r\nvar ASM_CONSTS = {\r\n 9944289: function() {\r\n  return withBuiltinMalloc(function() {\r\n   return allocateUTF8(Module[\"ASAN_OPTIONS\"] || 0);\r\n  });\r\n },\r\n 9944386: function() {\r\n  return withBuiltinMalloc(function() {\r\n   return allocateUTF8(Module[\"LSAN_OPTIONS\"] || 0);\r\n  });\r\n },\r\n 9944483: function() {\r\n  return withBuiltinMalloc(function() {\r\n   return allocateUTF8(Module[\"UBSAN_OPTIONS\"] || 0);\r\n  });\r\n },\r\n 9944581: function() {\r\n  var setting = Module[\"printWithColors\"];\r\n  if (setting != null) {\r\n   return setting;\r\n  } else {\r\n   return ENVIRONMENT_IS_NODE && process.stderr.isTTY;\r\n  }\r\n }\r\n};\r\n\r\nfunction callRuntimeCallbacks(callbacks) {\r\n while (callbacks.length > 0) {\r\n  var callback = callbacks.shift();\r\n  if (typeof callback == \"function\") {\r\n   callback(Module);\r\n   continue;\r\n  }\r\n  var func = callback.func;\r\n  if (typeof func === \"number\") {\r\n   if (callback.arg === undefined) {\r\n    getWasmTableEntry(func)();\r\n   } else {\r\n    getWasmTableEntry(func)(callback.arg);\r\n   }\r\n  } else {\r\n   func(callback.arg === undefined ? null : callback.arg);\r\n  }\r\n }\r\n}\r\n\r\nfunction demangle(func) {\r\n warnOnce(\"warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\");\r\n return func;\r\n}\r\n\r\nfunction demangleAll(text) {\r\n var regex = /\\b_Z[\\w\\d_]+/g;\r\n return text.replace(regex, function(x) {\r\n  var y = demangle(x);\r\n  return x === y ? x : y + \" [\" + x + \"]\";\r\n });\r\n}\r\n\r\nvar wasmTableMirror = [];\r\n\r\nfunction getWasmTableEntry(funcPtr) {\r\n var func = wasmTableMirror[funcPtr];\r\n if (!func) {\r\n  if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\r\n  wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\r\n }\r\n assert(wasmTable.get(funcPtr) == func, \"JavaScript-side Wasm function table mirror is out of date!\");\r\n return func;\r\n}\r\n\r\nfunction jsStackTrace() {\r\n var error = new Error();\r\n if (!error.stack) {\r\n  try {\r\n   throw new Error();\r\n  } catch (e) {\r\n   error = e;\r\n  }\r\n  if (!error.stack) {\r\n   return \"(no stack trace available)\";\r\n  }\r\n }\r\n return error.stack.toString();\r\n}\r\n\r\nfunction setWasmTableEntry(idx, func) {\r\n wasmTable.set(idx, func);\r\n wasmTableMirror[idx] = func;\r\n}\r\n\r\nfunction ___assert_fail(condition, filename, line, func) {\r\n abort(\"Assertion failed: \" + UTF8ToString(condition) + \", at: \" + [ filename ? UTF8ToString(filename) : \"unknown filename\", line, func ? UTF8ToString(func) : \"unknown function\" ]);\r\n}\r\n\r\nvar PATH = {\r\n splitPath: function(filename) {\r\n  var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n  return splitPathRe.exec(filename).slice(1);\r\n },\r\n normalizeArray: function(parts, allowAboveRoot) {\r\n  var up = 0;\r\n  for (var i = parts.length - 1; i >= 0; i--) {\r\n   var last = parts[i];\r\n   if (last === \".\") {\r\n    parts.splice(i, 1);\r\n   } else if (last === \"..\") {\r\n    parts.splice(i, 1);\r\n    up++;\r\n   } else if (up) {\r\n    parts.splice(i, 1);\r\n    up--;\r\n   }\r\n  }\r\n  if (allowAboveRoot) {\r\n   for (;up; up--) {\r\n    parts.unshift(\"..\");\r\n   }\r\n  }\r\n  return parts;\r\n },\r\n normalize: function(path) {\r\n  var isAbsolute = path.charAt(0) === \"/\", trailingSlash = path.substr(-1) === \"/\";\r\n  path = PATH.normalizeArray(path.split(\"/\").filter(function(p) {\r\n   return !!p;\r\n  }), !isAbsolute).join(\"/\");\r\n  if (!path && !isAbsolute) {\r\n   path = \".\";\r\n  }\r\n  if (path && trailingSlash) {\r\n   path += \"/\";\r\n  }\r\n  return (isAbsolute ? \"/\" : \"\") + path;\r\n },\r\n dirname: function(path) {\r\n  var result = PATH.splitPath(path), root = result[0], dir = result[1];\r\n  if (!root && !dir) {\r\n   return \".\";\r\n  }\r\n  if (dir) {\r\n   dir = dir.substr(0, dir.length - 1);\r\n  }\r\n  return root + dir;\r\n },\r\n basename: function(path) {\r\n  if (path === \"/\") return \"/\";\r\n  path = PATH.normalize(path);\r\n  path = path.replace(/\\/$/, \"\");\r\n  var lastSlash = path.lastIndexOf(\"/\");\r\n  if (lastSlash === -1) return path;\r\n  return path.substr(lastSlash + 1);\r\n },\r\n extname: function(path) {\r\n  return PATH.splitPath(path)[3];\r\n },\r\n join: function() {\r\n  var paths = Array.prototype.slice.call(arguments, 0);\r\n  return PATH.normalize(paths.join(\"/\"));\r\n },\r\n join2: function(l, r) {\r\n  return PATH.normalize(l + \"/\" + r);\r\n }\r\n};\r\n\r\nfunction getRandomDevice() {\r\n if (typeof crypto === \"object\" && typeof crypto[\"getRandomValues\"] === \"function\") {\r\n  var randomBuffer = new Uint8Array(1);\r\n  return function() {\r\n   crypto.getRandomValues(randomBuffer);\r\n   return randomBuffer[0];\r\n  };\r\n } else return function() {\r\n  abort(\"no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };\");\r\n };\r\n}\r\n\r\nvar PATH_FS = {\r\n resolve: function() {\r\n  var resolvedPath = \"\", resolvedAbsolute = false;\r\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n   var path = i >= 0 ? arguments[i] : FS.cwd();\r\n   if (typeof path !== \"string\") {\r\n    throw new TypeError(\"Arguments to path.resolve must be strings\");\r\n   } else if (!path) {\r\n    return \"\";\r\n   }\r\n   resolvedPath = path + \"/\" + resolvedPath;\r\n   resolvedAbsolute = path.charAt(0) === \"/\";\r\n  }\r\n  resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(function(p) {\r\n   return !!p;\r\n  }), !resolvedAbsolute).join(\"/\");\r\n  return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\r\n },\r\n relative: function(from, to) {\r\n  from = PATH_FS.resolve(from).substr(1);\r\n  to = PATH_FS.resolve(to).substr(1);\r\n  function trim(arr) {\r\n   var start = 0;\r\n   for (;start < arr.length; start++) {\r\n    if (arr[start] !== \"\") break;\r\n   }\r\n   var end = arr.length - 1;\r\n   for (;end >= 0; end--) {\r\n    if (arr[end] !== \"\") break;\r\n   }\r\n   if (start > end) return [];\r\n   return arr.slice(start, end - start + 1);\r\n  }\r\n  var fromParts = trim(from.split(\"/\"));\r\n  var toParts = trim(to.split(\"/\"));\r\n  var length = Math.min(fromParts.length, toParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n   if (fromParts[i] !== toParts[i]) {\r\n    samePartsLength = i;\r\n    break;\r\n   }\r\n  }\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n   outputParts.push(\"..\");\r\n  }\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n  return outputParts.join(\"/\");\r\n }\r\n};\r\n\r\nvar TTY = {\r\n ttys: [],\r\n init: function() {},\r\n shutdown: function() {},\r\n register: function(dev, ops) {\r\n  TTY.ttys[dev] = {\r\n   input: [],\r\n   output: [],\r\n   ops: ops\r\n  };\r\n  FS.registerDevice(dev, TTY.stream_ops);\r\n },\r\n stream_ops: {\r\n  open: function(stream) {\r\n   var tty = TTY.ttys[stream.node.rdev];\r\n   if (!tty) {\r\n    throw new FS.ErrnoError(43);\r\n   }\r\n   stream.tty = tty;\r\n   stream.seekable = false;\r\n  },\r\n  close: function(stream) {\r\n   stream.tty.ops.flush(stream.tty);\r\n  },\r\n  flush: function(stream) {\r\n   stream.tty.ops.flush(stream.tty);\r\n  },\r\n  read: function(stream, buffer, offset, length, pos) {\r\n   if (!stream.tty || !stream.tty.ops.get_char) {\r\n    throw new FS.ErrnoError(60);\r\n   }\r\n   var bytesRead = 0;\r\n   for (var i = 0; i < length; i++) {\r\n    var result;\r\n    try {\r\n     result = stream.tty.ops.get_char(stream.tty);\r\n    } catch (e) {\r\n     throw new FS.ErrnoError(29);\r\n    }\r\n    if (result === undefined && bytesRead === 0) {\r\n     throw new FS.ErrnoError(6);\r\n    }\r\n    if (result === null || result === undefined) break;\r\n    bytesRead++;\r\n    buffer[offset + i] = result;\r\n   }\r\n   if (bytesRead) {\r\n    stream.node.timestamp = Date.now();\r\n   }\r\n   return bytesRead;\r\n  },\r\n  write: function(stream, buffer, offset, length, pos) {\r\n   if (!stream.tty || !stream.tty.ops.put_char) {\r\n    throw new FS.ErrnoError(60);\r\n   }\r\n   try {\r\n    for (var i = 0; i < length; i++) {\r\n     stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\r\n    }\r\n   } catch (e) {\r\n    throw new FS.ErrnoError(29);\r\n   }\r\n   if (length) {\r\n    stream.node.timestamp = Date.now();\r\n   }\r\n   return i;\r\n  }\r\n },\r\n default_tty_ops: {\r\n  get_char: function(tty) {\r\n   if (!tty.input.length) {\r\n    var result = null;\r\n    if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\r\n     result = window.prompt(\"Input: \");\r\n     if (result !== null) {\r\n      result += \"\\n\";\r\n     }\r\n    } else if (typeof readline == \"function\") {\r\n     result = readline();\r\n     if (result !== null) {\r\n      result += \"\\n\";\r\n     }\r\n    }\r\n    if (!result) {\r\n     return null;\r\n    }\r\n    tty.input = intArrayFromString(result, true);\r\n   }\r\n   return tty.input.shift();\r\n  },\r\n  put_char: function(tty, val) {\r\n   if (val === null || val === 10) {\r\n    out(UTF8ArrayToString(tty.output, 0));\r\n    tty.output = [];\r\n   } else {\r\n    if (val != 0) tty.output.push(val);\r\n   }\r\n  },\r\n  flush: function(tty) {\r\n   if (tty.output && tty.output.length > 0) {\r\n    out(UTF8ArrayToString(tty.output, 0));\r\n    tty.output = [];\r\n   }\r\n  }\r\n },\r\n default_tty1_ops: {\r\n  put_char: function(tty, val) {\r\n   if (val === null || val === 10) {\r\n    err(UTF8ArrayToString(tty.output, 0));\r\n    tty.output = [];\r\n   } else {\r\n    if (val != 0) tty.output.push(val);\r\n   }\r\n  },\r\n  flush: function(tty) {\r\n   if (tty.output && tty.output.length > 0) {\r\n    err(UTF8ArrayToString(tty.output, 0));\r\n    tty.output = [];\r\n   }\r\n  }\r\n }\r\n};\r\n\r\nfunction zeroMemory(address, size) {\r\n HEAPU8.fill(0, address, address + size);\r\n}\r\n\r\nfunction alignMemory(size, alignment) {\r\n assert(alignment, \"alignment argument is required\");\r\n return Math.ceil(size / alignment) * alignment;\r\n}\r\n\r\nfunction mmapAlloc(size) {\r\n size = alignMemory(size, 65536);\r\n var ptr = _memalign(65536, size);\r\n if (!ptr) return 0;\r\n zeroMemory(ptr, size);\r\n return ptr;\r\n}\r\n\r\nvar MEMFS = {\r\n ops_table: null,\r\n mount: function(mount) {\r\n  return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\r\n },\r\n createNode: function(parent, name, mode, dev) {\r\n  if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\r\n   throw new FS.ErrnoError(63);\r\n  }\r\n  if (!MEMFS.ops_table) {\r\n   MEMFS.ops_table = {\r\n    dir: {\r\n     node: {\r\n      getattr: MEMFS.node_ops.getattr,\r\n      setattr: MEMFS.node_ops.setattr,\r\n      lookup: MEMFS.node_ops.lookup,\r\n      mknod: MEMFS.node_ops.mknod,\r\n      rename: MEMFS.node_ops.rename,\r\n      unlink: MEMFS.node_ops.unlink,\r\n      rmdir: MEMFS.node_ops.rmdir,\r\n      readdir: MEMFS.node_ops.readdir,\r\n      symlink: MEMFS.node_ops.symlink\r\n     },\r\n     stream: {\r\n      llseek: MEMFS.stream_ops.llseek\r\n     }\r\n    },\r\n    file: {\r\n     node: {\r\n      getattr: MEMFS.node_ops.getattr,\r\n      setattr: MEMFS.node_ops.setattr\r\n     },\r\n     stream: {\r\n      llseek: MEMFS.stream_ops.llseek,\r\n      read: MEMFS.stream_ops.read,\r\n      write: MEMFS.stream_ops.write,\r\n      allocate: MEMFS.stream_ops.allocate,\r\n      mmap: MEMFS.stream_ops.mmap,\r\n      msync: MEMFS.stream_ops.msync\r\n     }\r\n    },\r\n    link: {\r\n     node: {\r\n      getattr: MEMFS.node_ops.getattr,\r\n      setattr: MEMFS.node_ops.setattr,\r\n      readlink: MEMFS.node_ops.readlink\r\n     },\r\n     stream: {}\r\n    },\r\n    chrdev: {\r\n     node: {\r\n      getattr: MEMFS.node_ops.getattr,\r\n      setattr: MEMFS.node_ops.setattr\r\n     },\r\n     stream: FS.chrdev_stream_ops\r\n    }\r\n   };\r\n  }\r\n  var node = FS.createNode(parent, name, mode, dev);\r\n  if (FS.isDir(node.mode)) {\r\n   node.node_ops = MEMFS.ops_table.dir.node;\r\n   node.stream_ops = MEMFS.ops_table.dir.stream;\r\n   node.contents = {};\r\n  } else if (FS.isFile(node.mode)) {\r\n   node.node_ops = MEMFS.ops_table.file.node;\r\n   node.stream_ops = MEMFS.ops_table.file.stream;\r\n   node.usedBytes = 0;\r\n   node.contents = null;\r\n  } else if (FS.isLink(node.mode)) {\r\n   node.node_ops = MEMFS.ops_table.link.node;\r\n   node.stream_ops = MEMFS.ops_table.link.stream;\r\n  } else if (FS.isChrdev(node.mode)) {\r\n   node.node_ops = MEMFS.ops_table.chrdev.node;\r\n   node.stream_ops = MEMFS.ops_table.chrdev.stream;\r\n  }\r\n  node.timestamp = Date.now();\r\n  if (parent) {\r\n   parent.contents[name] = node;\r\n   parent.timestamp = node.timestamp;\r\n  }\r\n  return node;\r\n },\r\n getFileDataAsTypedArray: function(node) {\r\n  if (!node.contents) return new Uint8Array(0);\r\n  if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\r\n  return new Uint8Array(node.contents);\r\n },\r\n expandFileStorage: function(node, newCapacity) {\r\n  var prevCapacity = node.contents ? node.contents.length : 0;\r\n  if (prevCapacity >= newCapacity) return;\r\n  var CAPACITY_DOUBLING_MAX = 1024 * 1024;\r\n  newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\r\n  if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\r\n  var oldContents = node.contents;\r\n  node.contents = new Uint8Array(newCapacity);\r\n  if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\r\n },\r\n resizeFileStorage: function(node, newSize) {\r\n  if (node.usedBytes == newSize) return;\r\n  if (newSize == 0) {\r\n   node.contents = null;\r\n   node.usedBytes = 0;\r\n  } else {\r\n   var oldContents = node.contents;\r\n   node.contents = new Uint8Array(newSize);\r\n   if (oldContents) {\r\n    node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\r\n   }\r\n   node.usedBytes = newSize;\r\n  }\r\n },\r\n node_ops: {\r\n  getattr: function(node) {\r\n   var attr = {};\r\n   attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\r\n   attr.ino = node.id;\r\n   attr.mode = node.mode;\r\n   attr.nlink = 1;\r\n   attr.uid = 0;\r\n   attr.gid = 0;\r\n   attr.rdev = node.rdev;\r\n   if (FS.isDir(node.mode)) {\r\n    attr.size = 4096;\r\n   } else if (FS.isFile(node.mode)) {\r\n    attr.size = node.usedBytes;\r\n   } else if (FS.isLink(node.mode)) {\r\n    attr.size = node.link.length;\r\n   } else {\r\n    attr.size = 0;\r\n   }\r\n   attr.atime = new Date(node.timestamp);\r\n   attr.mtime = new Date(node.timestamp);\r\n   attr.ctime = new Date(node.timestamp);\r\n   attr.blksize = 4096;\r\n   attr.blocks = Math.ceil(attr.size / attr.blksize);\r\n   return attr;\r\n  },\r\n  setattr: function(node, attr) {\r\n   if (attr.mode !== undefined) {\r\n    node.mode = attr.mode;\r\n   }\r\n   if (attr.timestamp !== undefined) {\r\n    node.timestamp = attr.timestamp;\r\n   }\r\n   if (attr.size !== undefined) {\r\n    MEMFS.resizeFileStorage(node, attr.size);\r\n   }\r\n  },\r\n  lookup: function(parent, name) {\r\n   throw FS.genericErrors[44];\r\n  },\r\n  mknod: function(parent, name, mode, dev) {\r\n   return MEMFS.createNode(parent, name, mode, dev);\r\n  },\r\n  rename: function(old_node, new_dir, new_name) {\r\n   if (FS.isDir(old_node.mode)) {\r\n    var new_node;\r\n    try {\r\n     new_node = FS.lookupNode(new_dir, new_name);\r\n    } catch (e) {}\r\n    if (new_node) {\r\n     for (var i in new_node.contents) {\r\n      throw new FS.ErrnoError(55);\r\n     }\r\n    }\r\n   }\r\n   delete old_node.parent.contents[old_node.name];\r\n   old_node.parent.timestamp = Date.now();\r\n   old_node.name = new_name;\r\n   new_dir.contents[new_name] = old_node;\r\n   new_dir.timestamp = old_node.parent.timestamp;\r\n   old_node.parent = new_dir;\r\n  },\r\n  unlink: function(parent, name) {\r\n   delete parent.contents[name];\r\n   parent.timestamp = Date.now();\r\n  },\r\n  rmdir: function(parent, name) {\r\n   var node = FS.lookupNode(parent, name);\r\n   for (var i in node.contents) {\r\n    throw new FS.ErrnoError(55);\r\n   }\r\n   delete parent.contents[name];\r\n   parent.timestamp = Date.now();\r\n  },\r\n  readdir: function(node) {\r\n   var entries = [ \".\", \"..\" ];\r\n   for (var key in node.contents) {\r\n    if (!node.contents.hasOwnProperty(key)) {\r\n     continue;\r\n    }\r\n    entries.push(key);\r\n   }\r\n   return entries;\r\n  },\r\n  symlink: function(parent, newname, oldpath) {\r\n   var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\r\n   node.link = oldpath;\r\n   return node;\r\n  },\r\n  readlink: function(node) {\r\n   if (!FS.isLink(node.mode)) {\r\n    throw new FS.ErrnoError(28);\r\n   }\r\n   return node.link;\r\n  }\r\n },\r\n stream_ops: {\r\n  read: function(stream, buffer, offset, length, position) {\r\n   var contents = stream.node.contents;\r\n   if (position >= stream.node.usedBytes) return 0;\r\n   var size = Math.min(stream.node.usedBytes - position, length);\r\n   assert(size >= 0);\r\n   if (size > 8 && contents.subarray) {\r\n    buffer.set(contents.subarray(position, position + size), offset);\r\n   } else {\r\n    for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\r\n   }\r\n   return size;\r\n  },\r\n  write: function(stream, buffer, offset, length, position, canOwn) {\r\n   assert(!(buffer instanceof ArrayBuffer));\r\n   if (!length) return 0;\r\n   var node = stream.node;\r\n   node.timestamp = Date.now();\r\n   if (buffer.subarray && (!node.contents || node.contents.subarray)) {\r\n    if (canOwn) {\r\n     assert(position === 0, \"canOwn must imply no weird position inside the file\");\r\n     node.contents = buffer.subarray(offset, offset + length);\r\n     node.usedBytes = length;\r\n     return length;\r\n    } else if (node.usedBytes === 0 && position === 0) {\r\n     node.contents = buffer.slice(offset, offset + length);\r\n     node.usedBytes = length;\r\n     return length;\r\n    } else if (position + length <= node.usedBytes) {\r\n     node.contents.set(buffer.subarray(offset, offset + length), position);\r\n     return length;\r\n    }\r\n   }\r\n   MEMFS.expandFileStorage(node, position + length);\r\n   if (node.contents.subarray && buffer.subarray) {\r\n    node.contents.set(buffer.subarray(offset, offset + length), position);\r\n   } else {\r\n    for (var i = 0; i < length; i++) {\r\n     node.contents[position + i] = buffer[offset + i];\r\n    }\r\n   }\r\n   node.usedBytes = Math.max(node.usedBytes, position + length);\r\n   return length;\r\n  },\r\n  llseek: function(stream, offset, whence) {\r\n   var position = offset;\r\n   if (whence === 1) {\r\n    position += stream.position;\r\n   } else if (whence === 2) {\r\n    if (FS.isFile(stream.node.mode)) {\r\n     position += stream.node.usedBytes;\r\n    }\r\n   }\r\n   if (position < 0) {\r\n    throw new FS.ErrnoError(28);\r\n   }\r\n   return position;\r\n  },\r\n  allocate: function(stream, offset, length) {\r\n   MEMFS.expandFileStorage(stream.node, offset + length);\r\n   stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\r\n  },\r\n  mmap: function(stream, address, length, position, prot, flags) {\r\n   if (address !== 0) {\r\n    throw new FS.ErrnoError(28);\r\n   }\r\n   if (!FS.isFile(stream.node.mode)) {\r\n    throw new FS.ErrnoError(43);\r\n   }\r\n   var ptr;\r\n   var allocated;\r\n   var contents = stream.node.contents;\r\n   if (!(flags & 2) && contents.buffer === buffer) {\r\n    allocated = false;\r\n    ptr = contents.byteOffset;\r\n   } else {\r\n    if (position > 0 || position + length < contents.length) {\r\n     if (contents.subarray) {\r\n      contents = contents.subarray(position, position + length);\r\n     } else {\r\n      contents = Array.prototype.slice.call(contents, position, position + length);\r\n     }\r\n    }\r\n    allocated = true;\r\n    ptr = mmapAlloc(length);\r\n    if (!ptr) {\r\n     throw new FS.ErrnoError(48);\r\n    }\r\n    HEAP8.set(contents, ptr);\r\n   }\r\n   return {\r\n    ptr: ptr,\r\n    allocated: allocated\r\n   };\r\n  },\r\n  msync: function(stream, buffer, offset, length, mmapFlags) {\r\n   if (!FS.isFile(stream.node.mode)) {\r\n    throw new FS.ErrnoError(43);\r\n   }\r\n   if (mmapFlags & 2) {\r\n    return 0;\r\n   }\r\n   var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\r\n   return 0;\r\n  }\r\n }\r\n};\r\n\r\nfunction asyncLoad(url, onload, onerror, noRunDep) {\r\n var dep = !noRunDep ? getUniqueRunDependency(\"al \" + url) : \"\";\r\n readAsync(url, function(arrayBuffer) {\r\n  assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).');\r\n  onload(new Uint8Array(arrayBuffer));\r\n  if (dep) removeRunDependency(dep);\r\n }, function(event) {\r\n  if (onerror) {\r\n   onerror();\r\n  } else {\r\n   throw 'Loading data file \"' + url + '\" failed.';\r\n  }\r\n });\r\n if (dep) addRunDependency(dep);\r\n}\r\n\r\nvar ERRNO_MESSAGES = {\r\n 0: \"Success\",\r\n 1: \"Arg list too long\",\r\n 2: \"Permission denied\",\r\n 3: \"Address already in use\",\r\n 4: \"Address not available\",\r\n 5: \"Address family not supported by protocol family\",\r\n 6: \"No more processes\",\r\n 7: \"Socket already connected\",\r\n 8: \"Bad file number\",\r\n 9: \"Trying to read unreadable message\",\r\n 10: \"Mount device busy\",\r\n 11: \"Operation canceled\",\r\n 12: \"No children\",\r\n 13: \"Connection aborted\",\r\n 14: \"Connection refused\",\r\n 15: \"Connection reset by peer\",\r\n 16: \"File locking deadlock error\",\r\n 17: \"Destination address required\",\r\n 18: \"Math arg out of domain of func\",\r\n 19: \"Quota exceeded\",\r\n 20: \"File exists\",\r\n 21: \"Bad address\",\r\n 22: \"File too large\",\r\n 23: \"Host is unreachable\",\r\n 24: \"Identifier removed\",\r\n 25: \"Illegal byte sequence\",\r\n 26: \"Connection already in progress\",\r\n 27: \"Interrupted system call\",\r\n 28: \"Invalid argument\",\r\n 29: \"I/O error\",\r\n 30: \"Socket is already connected\",\r\n 31: \"Is a directory\",\r\n 32: \"Too many symbolic links\",\r\n 33: \"Too many open files\",\r\n 34: \"Too many links\",\r\n 35: \"Message too long\",\r\n 36: \"Multihop attempted\",\r\n 37: \"File or path name too long\",\r\n 38: \"Network interface is not configured\",\r\n 39: \"Connection reset by network\",\r\n 40: \"Network is unreachable\",\r\n 41: \"Too many open files in system\",\r\n 42: \"No buffer space available\",\r\n 43: \"No such device\",\r\n 44: \"No such file or directory\",\r\n 45: \"Exec format error\",\r\n 46: \"No record locks available\",\r\n 47: \"The link has been severed\",\r\n 48: \"Not enough core\",\r\n 49: \"No message of desired type\",\r\n 50: \"Protocol not available\",\r\n 51: \"No space left on device\",\r\n 52: \"Function not implemented\",\r\n 53: \"Socket is not connected\",\r\n 54: \"Not a directory\",\r\n 55: \"Directory not empty\",\r\n 56: \"State not recoverable\",\r\n 57: \"Socket operation on non-socket\",\r\n 59: \"Not a typewriter\",\r\n 60: \"No such device or address\",\r\n 61: \"Value too large for defined data type\",\r\n 62: \"Previous owner died\",\r\n 63: \"Not super-user\",\r\n 64: \"Broken pipe\",\r\n 65: \"Protocol error\",\r\n 66: \"Unknown protocol\",\r\n 67: \"Protocol wrong type for socket\",\r\n 68: \"Math result not representable\",\r\n 69: \"Read only file system\",\r\n 70: \"Illegal seek\",\r\n 71: \"No such process\",\r\n 72: \"Stale file handle\",\r\n 73: \"Connection timed out\",\r\n 74: \"Text file busy\",\r\n 75: \"Cross-device link\",\r\n 100: \"Device not a stream\",\r\n 101: \"Bad font file fmt\",\r\n 102: \"Invalid slot\",\r\n 103: \"Invalid request code\",\r\n 104: \"No anode\",\r\n 105: \"Block device required\",\r\n 106: \"Channel number out of range\",\r\n 107: \"Level 3 halted\",\r\n 108: \"Level 3 reset\",\r\n 109: \"Link number out of range\",\r\n 110: \"Protocol driver not attached\",\r\n 111: \"No CSI structure available\",\r\n 112: \"Level 2 halted\",\r\n 113: \"Invalid exchange\",\r\n 114: \"Invalid request descriptor\",\r\n 115: \"Exchange full\",\r\n 116: \"No data (for no delay io)\",\r\n 117: \"Timer expired\",\r\n 118: \"Out of streams resources\",\r\n 119: \"Machine is not on the network\",\r\n 120: \"Package not installed\",\r\n 121: \"The object is remote\",\r\n 122: \"Advertise error\",\r\n 123: \"Srmount error\",\r\n 124: \"Communication error on send\",\r\n 125: \"Cross mount point (not really error)\",\r\n 126: \"Given log. name not unique\",\r\n 127: \"f.d. invalid for this operation\",\r\n 128: \"Remote address changed\",\r\n 129: \"Can   access a needed shared lib\",\r\n 130: \"Accessing a corrupted shared lib\",\r\n 131: \".lib section in a.out corrupted\",\r\n 132: \"Attempting to link in too many libs\",\r\n 133: \"Attempting to exec a shared library\",\r\n 135: \"Streams pipe error\",\r\n 136: \"Too many users\",\r\n 137: \"Socket type not supported\",\r\n 138: \"Not supported\",\r\n 139: \"Protocol family not supported\",\r\n 140: \"Can't send after socket shutdown\",\r\n 141: \"Too many references\",\r\n 142: \"Host is down\",\r\n 148: \"No medium (in tape drive)\",\r\n 156: \"Level 2 not synchronized\"\r\n};\r\n\r\nvar ERRNO_CODES = {};\r\n\r\nvar FS = {\r\n root: null,\r\n mounts: [],\r\n devices: {},\r\n streams: [],\r\n nextInode: 1,\r\n nameTable: null,\r\n currentPath: \"/\",\r\n initialized: false,\r\n ignorePermissions: true,\r\n ErrnoError: null,\r\n genericErrors: {},\r\n filesystems: null,\r\n syncFSRequests: 0,\r\n lookupPath: (path, opts = {}) => {\r\n  path = PATH_FS.resolve(FS.cwd(), path);\r\n  if (!path) return {\r\n   path: \"\",\r\n   node: null\r\n  };\r\n  var defaults = {\r\n   follow_mount: true,\r\n   recurse_count: 0\r\n  };\r\n  for (var key in defaults) {\r\n   if (opts[key] === undefined) {\r\n    opts[key] = defaults[key];\r\n   }\r\n  }\r\n  if (opts.recurse_count > 8) {\r\n   throw new FS.ErrnoError(32);\r\n  }\r\n  var parts = PATH.normalizeArray(path.split(\"/\").filter(p => !!p), false);\r\n  var current = FS.root;\r\n  var current_path = \"/\";\r\n  for (var i = 0; i < parts.length; i++) {\r\n   var islast = i === parts.length - 1;\r\n   if (islast && opts.parent) {\r\n    break;\r\n   }\r\n   current = FS.lookupNode(current, parts[i]);\r\n   current_path = PATH.join2(current_path, parts[i]);\r\n   if (FS.isMountpoint(current)) {\r\n    if (!islast || islast && opts.follow_mount) {\r\n     current = current.mounted.root;\r\n    }\r\n   }\r\n   if (!islast || opts.follow) {\r\n    var count = 0;\r\n    while (FS.isLink(current.mode)) {\r\n     var link = FS.readlink(current_path);\r\n     current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\r\n     var lookup = FS.lookupPath(current_path, {\r\n      recurse_count: opts.recurse_count\r\n     });\r\n     current = lookup.node;\r\n     if (count++ > 40) {\r\n      throw new FS.ErrnoError(32);\r\n     }\r\n    }\r\n   }\r\n  }\r\n  return {\r\n   path: current_path,\r\n   node: current\r\n  };\r\n },\r\n getPath: node => {\r\n  var path;\r\n  while (true) {\r\n   if (FS.isRoot(node)) {\r\n    var mount = node.mount.mountpoint;\r\n    if (!path) return mount;\r\n    return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path;\r\n   }\r\n   path = path ? node.name + \"/\" + path : node.name;\r\n   node = node.parent;\r\n  }\r\n },\r\n hashName: (parentid, name) => {\r\n  var hash = 0;\r\n  for (var i = 0; i < name.length; i++) {\r\n   hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\r\n  }\r\n  return (parentid + hash >>> 0) % FS.nameTable.length;\r\n },\r\n hashAddNode: node => {\r\n  var hash = FS.hashName(node.parent.id, node.name);\r\n  node.name_next = FS.nameTable[hash];\r\n  FS.nameTable[hash] = node;\r\n },\r\n hashRemoveNode: node => {\r\n  var hash = FS.hashName(node.parent.id, node.name);\r\n  if (FS.nameTable[hash] === node) {\r\n   FS.nameTable[hash] = node.name_next;\r\n  } else {\r\n   var current = FS.nameTable[hash];\r\n   while (current) {\r\n    if (current.name_next === node) {\r\n     current.name_next = node.name_next;\r\n     break;\r\n    }\r\n    current = current.name_next;\r\n   }\r\n  }\r\n },\r\n lookupNode: (parent, name) => {\r\n  var errCode = FS.mayLookup(parent);\r\n  if (errCode) {\r\n   throw new FS.ErrnoError(errCode, parent);\r\n  }\r\n  var hash = FS.hashName(parent.id, name);\r\n  for (var node = FS.nameTable[hash]; node; node = node.name_next) {\r\n   var nodeName = node.name;\r\n   if (node.parent.id === parent.id && nodeName === name) {\r\n    return node;\r\n   }\r\n  }\r\n  return FS.lookup(parent, name);\r\n },\r\n createNode: (parent, name, mode, rdev) => {\r\n  assert(typeof parent === \"object\");\r\n  var node = new FS.FSNode(parent, name, mode, rdev);\r\n  FS.hashAddNode(node);\r\n  return node;\r\n },\r\n destroyNode: node => {\r\n  FS.hashRemoveNode(node);\r\n },\r\n isRoot: node => {\r\n  return node === node.parent;\r\n },\r\n isMountpoint: node => {\r\n  return !!node.mounted;\r\n },\r\n isFile: mode => {\r\n  return (mode & 61440) === 32768;\r\n },\r\n isDir: mode => {\r\n  return (mode & 61440) === 16384;\r\n },\r\n isLink: mode => {\r\n  return (mode & 61440) === 40960;\r\n },\r\n isChrdev: mode => {\r\n  return (mode & 61440) === 8192;\r\n },\r\n isBlkdev: mode => {\r\n  return (mode & 61440) === 24576;\r\n },\r\n isFIFO: mode => {\r\n  return (mode & 61440) === 4096;\r\n },\r\n isSocket: mode => {\r\n  return (mode & 49152) === 49152;\r\n },\r\n flagModes: {\r\n  \"r\": 0,\r\n  \"r+\": 2,\r\n  \"w\": 577,\r\n  \"w+\": 578,\r\n  \"a\": 1089,\r\n  \"a+\": 1090\r\n },\r\n modeStringToFlags: str => {\r\n  var flags = FS.flagModes[str];\r\n  if (typeof flags === \"undefined\") {\r\n   throw new Error(\"Unknown file open mode: \" + str);\r\n  }\r\n  return flags;\r\n },\r\n flagsToPermissionString: flag => {\r\n  var perms = [ \"r\", \"w\", \"rw\" ][flag & 3];\r\n  if (flag & 512) {\r\n   perms += \"w\";\r\n  }\r\n  return perms;\r\n },\r\n nodePermissions: (node, perms) => {\r\n  if (FS.ignorePermissions) {\r\n   return 0;\r\n  }\r\n  if (perms.includes(\"r\") && !(node.mode & 292)) {\r\n   return 2;\r\n  } else if (perms.includes(\"w\") && !(node.mode & 146)) {\r\n   return 2;\r\n  } else if (perms.includes(\"x\") && !(node.mode & 73)) {\r\n   return 2;\r\n  }\r\n  return 0;\r\n },\r\n mayLookup: dir => {\r\n  var errCode = FS.nodePermissions(dir, \"x\");\r\n  if (errCode) return errCode;\r\n  if (!dir.node_ops.lookup) return 2;\r\n  return 0;\r\n },\r\n mayCreate: (dir, name) => {\r\n  try {\r\n   var node = FS.lookupNode(dir, name);\r\n   return 20;\r\n  } catch (e) {}\r\n  return FS.nodePermissions(dir, \"wx\");\r\n },\r\n mayDelete: (dir, name, isdir) => {\r\n  var node;\r\n  try {\r\n   node = FS.lookupNode(dir, name);\r\n  } catch (e) {\r\n   return e.errno;\r\n  }\r\n  var errCode = FS.nodePermissions(dir, \"wx\");\r\n  if (errCode) {\r\n   return errCode;\r\n  }\r\n  if (isdir) {\r\n   if (!FS.isDir(node.mode)) {\r\n    return 54;\r\n   }\r\n   if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\r\n    return 10;\r\n   }\r\n  } else {\r\n   if (FS.isDir(node.mode)) {\r\n    return 31;\r\n   }\r\n  }\r\n  return 0;\r\n },\r\n mayOpen: (node, flags) => {\r\n  if (!node) {\r\n   return 44;\r\n  }\r\n  if (FS.isLink(node.mode)) {\r\n   return 32;\r\n  } else if (FS.isDir(node.mode)) {\r\n   if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\r\n    return 31;\r\n   }\r\n  }\r\n  return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\r\n },\r\n MAX_OPEN_FDS: 4096,\r\n nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {\r\n  for (var fd = fd_start; fd <= fd_end; fd++) {\r\n   if (!FS.streams[fd]) {\r\n    return fd;\r\n   }\r\n  }\r\n  throw new FS.ErrnoError(33);\r\n },\r\n getStream: fd => FS.streams[fd],\r\n createStream: (stream, fd_start, fd_end) => {\r\n  if (!FS.FSStream) {\r\n   FS.FSStream = function() {};\r\n   FS.FSStream.prototype = {\r\n    object: {\r\n     get: function() {\r\n      return this.node;\r\n     },\r\n     set: function(val) {\r\n      this.node = val;\r\n     }\r\n    },\r\n    isRead: {\r\n     get: function() {\r\n      return (this.flags & 2097155) !== 1;\r\n     }\r\n    },\r\n    isWrite: {\r\n     get: function() {\r\n      return (this.flags & 2097155) !== 0;\r\n     }\r\n    },\r\n    isAppend: {\r\n     get: function() {\r\n      return this.flags & 1024;\r\n     }\r\n    }\r\n   };\r\n  }\r\n  stream = Object.assign(new FS.FSStream(), stream);\r\n  var fd = FS.nextfd(fd_start, fd_end);\r\n  stream.fd = fd;\r\n  FS.streams[fd] = stream;\r\n  return stream;\r\n },\r\n closeStream: fd => {\r\n  FS.streams[fd] = null;\r\n },\r\n chrdev_stream_ops: {\r\n  open: stream => {\r\n   var device = FS.getDevice(stream.node.rdev);\r\n   stream.stream_ops = device.stream_ops;\r\n   if (stream.stream_ops.open) {\r\n    stream.stream_ops.open(stream);\r\n   }\r\n  },\r\n  llseek: () => {\r\n   throw new FS.ErrnoError(70);\r\n  }\r\n },\r\n major: dev => dev >> 8,\r\n minor: dev => dev & 255,\r\n makedev: (ma, mi) => ma << 8 | mi,\r\n registerDevice: (dev, ops) => {\r\n  FS.devices[dev] = {\r\n   stream_ops: ops\r\n  };\r\n },\r\n getDevice: dev => FS.devices[dev],\r\n getMounts: mount => {\r\n  var mounts = [];\r\n  var check = [ mount ];\r\n  while (check.length) {\r\n   var m = check.pop();\r\n   mounts.push(m);\r\n   check.push.apply(check, m.mounts);\r\n  }\r\n  return mounts;\r\n },\r\n syncfs: (populate, callback) => {\r\n  if (typeof populate === \"function\") {\r\n   callback = populate;\r\n   populate = false;\r\n  }\r\n  FS.syncFSRequests++;\r\n  if (FS.syncFSRequests > 1) {\r\n   err(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\");\r\n  }\r\n  var mounts = FS.getMounts(FS.root.mount);\r\n  var completed = 0;\r\n  function doCallback(errCode) {\r\n   assert(FS.syncFSRequests > 0);\r\n   FS.syncFSRequests--;\r\n   return callback(errCode);\r\n  }\r\n  function done(errCode) {\r\n   if (errCode) {\r\n    if (!done.errored) {\r\n     done.errored = true;\r\n     return doCallback(errCode);\r\n    }\r\n    return;\r\n   }\r\n   if (++completed >= mounts.length) {\r\n    doCallback(null);\r\n   }\r\n  }\r\n  mounts.forEach(mount => {\r\n   if (!mount.type.syncfs) {\r\n    return done(null);\r\n   }\r\n   mount.type.syncfs(mount, populate, done);\r\n  });\r\n },\r\n mount: (type, opts, mountpoint) => {\r\n  if (typeof type === \"string\") {\r\n   throw type;\r\n  }\r\n  var root = mountpoint === \"/\";\r\n  var pseudo = !mountpoint;\r\n  var node;\r\n  if (root && FS.root) {\r\n   throw new FS.ErrnoError(10);\r\n  } else if (!root && !pseudo) {\r\n   var lookup = FS.lookupPath(mountpoint, {\r\n    follow_mount: false\r\n   });\r\n   mountpoint = lookup.path;\r\n   node = lookup.node;\r\n   if (FS.isMountpoint(node)) {\r\n    throw new FS.ErrnoError(10);\r\n   }\r\n   if (!FS.isDir(node.mode)) {\r\n    throw new FS.ErrnoError(54);\r\n   }\r\n  }\r\n  var mount = {\r\n   type: type,\r\n   opts: opts,\r\n   mountpoint: mountpoint,\r\n   mounts: []\r\n  };\r\n  var mountRoot = type.mount(mount);\r\n  mountRoot.mount = mount;\r\n  mount.root = mountRoot;\r\n  if (root) {\r\n   FS.root = mountRoot;\r\n  } else if (node) {\r\n   node.mounted = mount;\r\n   if (node.mount) {\r\n    node.mount.mounts.push(mount);\r\n   }\r\n  }\r\n  return mountRoot;\r\n },\r\n unmount: mountpoint => {\r\n  var lookup = FS.lookupPath(mountpoint, {\r\n   follow_mount: false\r\n  });\r\n  if (!FS.isMountpoint(lookup.node)) {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  var node = lookup.node;\r\n  var mount = node.mounted;\r\n  var mounts = FS.getMounts(mount);\r\n  Object.keys(FS.nameTable).forEach(hash => {\r\n   var current = FS.nameTable[hash];\r\n   while (current) {\r\n    var next = current.name_next;\r\n    if (mounts.includes(current.mount)) {\r\n     FS.destroyNode(current);\r\n    }\r\n    current = next;\r\n   }\r\n  });\r\n  node.mounted = null;\r\n  var idx = node.mount.mounts.indexOf(mount);\r\n  assert(idx !== -1);\r\n  node.mount.mounts.splice(idx, 1);\r\n },\r\n lookup: (parent, name) => {\r\n  return parent.node_ops.lookup(parent, name);\r\n },\r\n mknod: (path, mode, dev) => {\r\n  var lookup = FS.lookupPath(path, {\r\n   parent: true\r\n  });\r\n  var parent = lookup.node;\r\n  var name = PATH.basename(path);\r\n  if (!name || name === \".\" || name === \"..\") {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  var errCode = FS.mayCreate(parent, name);\r\n  if (errCode) {\r\n   throw new FS.ErrnoError(errCode);\r\n  }\r\n  if (!parent.node_ops.mknod) {\r\n   throw new FS.ErrnoError(63);\r\n  }\r\n  return parent.node_ops.mknod(parent, name, mode, dev);\r\n },\r\n create: (path, mode) => {\r\n  mode = mode !== undefined ? mode : 438;\r\n  mode &= 4095;\r\n  mode |= 32768;\r\n  return FS.mknod(path, mode, 0);\r\n },\r\n mkdir: (path, mode) => {\r\n  mode = mode !== undefined ? mode : 511;\r\n  mode &= 511 | 512;\r\n  mode |= 16384;\r\n  return FS.mknod(path, mode, 0);\r\n },\r\n mkdirTree: (path, mode) => {\r\n  var dirs = path.split(\"/\");\r\n  var d = \"\";\r\n  for (var i = 0; i < dirs.length; ++i) {\r\n   if (!dirs[i]) continue;\r\n   d += \"/\" + dirs[i];\r\n   try {\r\n    FS.mkdir(d, mode);\r\n   } catch (e) {\r\n    if (e.errno != 20) throw e;\r\n   }\r\n  }\r\n },\r\n mkdev: (path, mode, dev) => {\r\n  if (typeof dev === \"undefined\") {\r\n   dev = mode;\r\n   mode = 438;\r\n  }\r\n  mode |= 8192;\r\n  return FS.mknod(path, mode, dev);\r\n },\r\n symlink: (oldpath, newpath) => {\r\n  if (!PATH_FS.resolve(oldpath)) {\r\n   throw new FS.ErrnoError(44);\r\n  }\r\n  var lookup = FS.lookupPath(newpath, {\r\n   parent: true\r\n  });\r\n  var parent = lookup.node;\r\n  if (!parent) {\r\n   throw new FS.ErrnoError(44);\r\n  }\r\n  var newname = PATH.basename(newpath);\r\n  var errCode = FS.mayCreate(parent, newname);\r\n  if (errCode) {\r\n   throw new FS.ErrnoError(errCode);\r\n  }\r\n  if (!parent.node_ops.symlink) {\r\n   throw new FS.ErrnoError(63);\r\n  }\r\n  return parent.node_ops.symlink(parent, newname, oldpath);\r\n },\r\n rename: (old_path, new_path) => {\r\n  var old_dirname = PATH.dirname(old_path);\r\n  var new_dirname = PATH.dirname(new_path);\r\n  var old_name = PATH.basename(old_path);\r\n  var new_name = PATH.basename(new_path);\r\n  var lookup, old_dir, new_dir;\r\n  lookup = FS.lookupPath(old_path, {\r\n   parent: true\r\n  });\r\n  old_dir = lookup.node;\r\n  lookup = FS.lookupPath(new_path, {\r\n   parent: true\r\n  });\r\n  new_dir = lookup.node;\r\n  if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\r\n  if (old_dir.mount !== new_dir.mount) {\r\n   throw new FS.ErrnoError(75);\r\n  }\r\n  var old_node = FS.lookupNode(old_dir, old_name);\r\n  var relative = PATH_FS.relative(old_path, new_dirname);\r\n  if (relative.charAt(0) !== \".\") {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  relative = PATH_FS.relative(new_path, old_dirname);\r\n  if (relative.charAt(0) !== \".\") {\r\n   throw new FS.ErrnoError(55);\r\n  }\r\n  var new_node;\r\n  try {\r\n   new_node = FS.lookupNode(new_dir, new_name);\r\n  } catch (e) {}\r\n  if (old_node === new_node) {\r\n   return;\r\n  }\r\n  var isdir = FS.isDir(old_node.mode);\r\n  var errCode = FS.mayDelete(old_dir, old_name, isdir);\r\n  if (errCode) {\r\n   throw new FS.ErrnoError(errCode);\r\n  }\r\n  errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\r\n  if (errCode) {\r\n   throw new FS.ErrnoError(errCode);\r\n  }\r\n  if (!old_dir.node_ops.rename) {\r\n   throw new FS.ErrnoError(63);\r\n  }\r\n  if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\r\n   throw new FS.ErrnoError(10);\r\n  }\r\n  if (new_dir !== old_dir) {\r\n   errCode = FS.nodePermissions(old_dir, \"w\");\r\n   if (errCode) {\r\n    throw new FS.ErrnoError(errCode);\r\n   }\r\n  }\r\n  FS.hashRemoveNode(old_node);\r\n  try {\r\n   old_dir.node_ops.rename(old_node, new_dir, new_name);\r\n  } catch (e) {\r\n   throw e;\r\n  } finally {\r\n   FS.hashAddNode(old_node);\r\n  }\r\n },\r\n rmdir: path => {\r\n  var lookup = FS.lookupPath(path, {\r\n   parent: true\r\n  });\r\n  var parent = lookup.node;\r\n  var name = PATH.basename(path);\r\n  var node = FS.lookupNode(parent, name);\r\n  var errCode = FS.mayDelete(parent, name, true);\r\n  if (errCode) {\r\n   throw new FS.ErrnoError(errCode);\r\n  }\r\n  if (!parent.node_ops.rmdir) {\r\n   throw new FS.ErrnoError(63);\r\n  }\r\n  if (FS.isMountpoint(node)) {\r\n   throw new FS.ErrnoError(10);\r\n  }\r\n  parent.node_ops.rmdir(parent, name);\r\n  FS.destroyNode(node);\r\n },\r\n readdir: path => {\r\n  var lookup = FS.lookupPath(path, {\r\n   follow: true\r\n  });\r\n  var node = lookup.node;\r\n  if (!node.node_ops.readdir) {\r\n   throw new FS.ErrnoError(54);\r\n  }\r\n  return node.node_ops.readdir(node);\r\n },\r\n unlink: path => {\r\n  var lookup = FS.lookupPath(path, {\r\n   parent: true\r\n  });\r\n  var parent = lookup.node;\r\n  if (!parent) {\r\n   throw new FS.ErrnoError(44);\r\n  }\r\n  var name = PATH.basename(path);\r\n  var node = FS.lookupNode(parent, name);\r\n  var errCode = FS.mayDelete(parent, name, false);\r\n  if (errCode) {\r\n   throw new FS.ErrnoError(errCode);\r\n  }\r\n  if (!parent.node_ops.unlink) {\r\n   throw new FS.ErrnoError(63);\r\n  }\r\n  if (FS.isMountpoint(node)) {\r\n   throw new FS.ErrnoError(10);\r\n  }\r\n  parent.node_ops.unlink(parent, name);\r\n  FS.destroyNode(node);\r\n },\r\n readlink: path => {\r\n  var lookup = FS.lookupPath(path);\r\n  var link = lookup.node;\r\n  if (!link) {\r\n   throw new FS.ErrnoError(44);\r\n  }\r\n  if (!link.node_ops.readlink) {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\r\n },\r\n stat: (path, dontFollow) => {\r\n  var lookup = FS.lookupPath(path, {\r\n   follow: !dontFollow\r\n  });\r\n  var node = lookup.node;\r\n  if (!node) {\r\n   throw new FS.ErrnoError(44);\r\n  }\r\n  if (!node.node_ops.getattr) {\r\n   throw new FS.ErrnoError(63);\r\n  }\r\n  return node.node_ops.getattr(node);\r\n },\r\n lstat: path => {\r\n  return FS.stat(path, true);\r\n },\r\n chmod: (path, mode, dontFollow) => {\r\n  var node;\r\n  if (typeof path === \"string\") {\r\n   var lookup = FS.lookupPath(path, {\r\n    follow: !dontFollow\r\n   });\r\n   node = lookup.node;\r\n  } else {\r\n   node = path;\r\n  }\r\n  if (!node.node_ops.setattr) {\r\n   throw new FS.ErrnoError(63);\r\n  }\r\n  node.node_ops.setattr(node, {\r\n   mode: mode & 4095 | node.mode & ~4095,\r\n   timestamp: Date.now()\r\n  });\r\n },\r\n lchmod: (path, mode) => {\r\n  FS.chmod(path, mode, true);\r\n },\r\n fchmod: (fd, mode) => {\r\n  var stream = FS.getStream(fd);\r\n  if (!stream) {\r\n   throw new FS.ErrnoError(8);\r\n  }\r\n  FS.chmod(stream.node, mode);\r\n },\r\n chown: (path, uid, gid, dontFollow) => {\r\n  var node;\r\n  if (typeof path === \"string\") {\r\n   var lookup = FS.lookupPath(path, {\r\n    follow: !dontFollow\r\n   });\r\n   node = lookup.node;\r\n  } else {\r\n   node = path;\r\n  }\r\n  if (!node.node_ops.setattr) {\r\n   throw new FS.ErrnoError(63);\r\n  }\r\n  node.node_ops.setattr(node, {\r\n   timestamp: Date.now()\r\n  });\r\n },\r\n lchown: (path, uid, gid) => {\r\n  FS.chown(path, uid, gid, true);\r\n },\r\n fchown: (fd, uid, gid) => {\r\n  var stream = FS.getStream(fd);\r\n  if (!stream) {\r\n   throw new FS.ErrnoError(8);\r\n  }\r\n  FS.chown(stream.node, uid, gid);\r\n },\r\n truncate: (path, len) => {\r\n  if (len < 0) {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  var node;\r\n  if (typeof path === \"string\") {\r\n   var lookup = FS.lookupPath(path, {\r\n    follow: true\r\n   });\r\n   node = lookup.node;\r\n  } else {\r\n   node = path;\r\n  }\r\n  if (!node.node_ops.setattr) {\r\n   throw new FS.ErrnoError(63);\r\n  }\r\n  if (FS.isDir(node.mode)) {\r\n   throw new FS.ErrnoError(31);\r\n  }\r\n  if (!FS.isFile(node.mode)) {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  var errCode = FS.nodePermissions(node, \"w\");\r\n  if (errCode) {\r\n   throw new FS.ErrnoError(errCode);\r\n  }\r\n  node.node_ops.setattr(node, {\r\n   size: len,\r\n   timestamp: Date.now()\r\n  });\r\n },\r\n ftruncate: (fd, len) => {\r\n  var stream = FS.getStream(fd);\r\n  if (!stream) {\r\n   throw new FS.ErrnoError(8);\r\n  }\r\n  if ((stream.flags & 2097155) === 0) {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  FS.truncate(stream.node, len);\r\n },\r\n utime: (path, atime, mtime) => {\r\n  var lookup = FS.lookupPath(path, {\r\n   follow: true\r\n  });\r\n  var node = lookup.node;\r\n  node.node_ops.setattr(node, {\r\n   timestamp: Math.max(atime, mtime)\r\n  });\r\n },\r\n open: (path, flags, mode, fd_start, fd_end) => {\r\n  if (path === \"\") {\r\n   throw new FS.ErrnoError(44);\r\n  }\r\n  flags = typeof flags === \"string\" ? FS.modeStringToFlags(flags) : flags;\r\n  mode = typeof mode === \"undefined\" ? 438 : mode;\r\n  if (flags & 64) {\r\n   mode = mode & 4095 | 32768;\r\n  } else {\r\n   mode = 0;\r\n  }\r\n  var node;\r\n  if (typeof path === \"object\") {\r\n   node = path;\r\n  } else {\r\n   path = PATH.normalize(path);\r\n   try {\r\n    var lookup = FS.lookupPath(path, {\r\n     follow: !(flags & 131072)\r\n    });\r\n    node = lookup.node;\r\n   } catch (e) {}\r\n  }\r\n  var created = false;\r\n  if (flags & 64) {\r\n   if (node) {\r\n    if (flags & 128) {\r\n     throw new FS.ErrnoError(20);\r\n    }\r\n   } else {\r\n    node = FS.mknod(path, mode, 0);\r\n    created = true;\r\n   }\r\n  }\r\n  if (!node) {\r\n   throw new FS.ErrnoError(44);\r\n  }\r\n  if (FS.isChrdev(node.mode)) {\r\n   flags &= ~512;\r\n  }\r\n  if (flags & 65536 && !FS.isDir(node.mode)) {\r\n   throw new FS.ErrnoError(54);\r\n  }\r\n  if (!created) {\r\n   var errCode = FS.mayOpen(node, flags);\r\n   if (errCode) {\r\n    throw new FS.ErrnoError(errCode);\r\n   }\r\n  }\r\n  if (flags & 512) {\r\n   FS.truncate(node, 0);\r\n  }\r\n  flags &= ~(128 | 512 | 131072);\r\n  var stream = FS.createStream({\r\n   node: node,\r\n   path: FS.getPath(node),\r\n   flags: flags,\r\n   seekable: true,\r\n   position: 0,\r\n   stream_ops: node.stream_ops,\r\n   ungotten: [],\r\n   error: false\r\n  }, fd_start, fd_end);\r\n  if (stream.stream_ops.open) {\r\n   stream.stream_ops.open(stream);\r\n  }\r\n  if (Module[\"logReadFiles\"] && !(flags & 1)) {\r\n   if (!FS.readFiles) FS.readFiles = {};\r\n   if (!(path in FS.readFiles)) {\r\n    FS.readFiles[path] = 1;\r\n   }\r\n  }\r\n  return stream;\r\n },\r\n close: stream => {\r\n  if (FS.isClosed(stream)) {\r\n   throw new FS.ErrnoError(8);\r\n  }\r\n  if (stream.getdents) stream.getdents = null;\r\n  try {\r\n   if (stream.stream_ops.close) {\r\n    stream.stream_ops.close(stream);\r\n   }\r\n  } catch (e) {\r\n   throw e;\r\n  } finally {\r\n   FS.closeStream(stream.fd);\r\n  }\r\n  stream.fd = null;\r\n },\r\n isClosed: stream => {\r\n  return stream.fd === null;\r\n },\r\n llseek: (stream, offset, whence) => {\r\n  if (FS.isClosed(stream)) {\r\n   throw new FS.ErrnoError(8);\r\n  }\r\n  if (!stream.seekable || !stream.stream_ops.llseek) {\r\n   throw new FS.ErrnoError(70);\r\n  }\r\n  if (whence != 0 && whence != 1 && whence != 2) {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  stream.position = stream.stream_ops.llseek(stream, offset, whence);\r\n  stream.ungotten = [];\r\n  return stream.position;\r\n },\r\n read: (stream, buffer, offset, length, position) => {\r\n  if (length < 0 || position < 0) {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  if (FS.isClosed(stream)) {\r\n   throw new FS.ErrnoError(8);\r\n  }\r\n  if ((stream.flags & 2097155) === 1) {\r\n   throw new FS.ErrnoError(8);\r\n  }\r\n  if (FS.isDir(stream.node.mode)) {\r\n   throw new FS.ErrnoError(31);\r\n  }\r\n  if (!stream.stream_ops.read) {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  var seeking = typeof position !== \"undefined\";\r\n  if (!seeking) {\r\n   position = stream.position;\r\n  } else if (!stream.seekable) {\r\n   throw new FS.ErrnoError(70);\r\n  }\r\n  var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\r\n  if (!seeking) stream.position += bytesRead;\r\n  return bytesRead;\r\n },\r\n write: (stream, buffer, offset, length, position, canOwn) => {\r\n  if (length < 0 || position < 0) {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  if (FS.isClosed(stream)) {\r\n   throw new FS.ErrnoError(8);\r\n  }\r\n  if ((stream.flags & 2097155) === 0) {\r\n   throw new FS.ErrnoError(8);\r\n  }\r\n  if (FS.isDir(stream.node.mode)) {\r\n   throw new FS.ErrnoError(31);\r\n  }\r\n  if (!stream.stream_ops.write) {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  if (stream.seekable && stream.flags & 1024) {\r\n   FS.llseek(stream, 0, 2);\r\n  }\r\n  var seeking = typeof position !== \"undefined\";\r\n  if (!seeking) {\r\n   position = stream.position;\r\n  } else if (!stream.seekable) {\r\n   throw new FS.ErrnoError(70);\r\n  }\r\n  var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\r\n  if (!seeking) stream.position += bytesWritten;\r\n  return bytesWritten;\r\n },\r\n allocate: (stream, offset, length) => {\r\n  if (FS.isClosed(stream)) {\r\n   throw new FS.ErrnoError(8);\r\n  }\r\n  if (offset < 0 || length <= 0) {\r\n   throw new FS.ErrnoError(28);\r\n  }\r\n  if ((stream.flags & 2097155) === 0) {\r\n   throw new FS.ErrnoError(8);\r\n  }\r\n  if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\r\n   throw new FS.ErrnoError(43);\r\n  }\r\n  if (!stream.stream_ops.allocate) {\r\n   throw new FS.ErrnoError(138);\r\n  }\r\n  stream.stream_ops.allocate(stream, offset, length);\r\n },\r\n mmap: (stream, address, length, position, prot, flags) => {\r\n  if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\r\n   throw new FS.ErrnoError(2);\r\n  }\r\n  if ((stream.flags & 2097155) === 1) {\r\n   throw new FS.ErrnoError(2);\r\n  }\r\n  if (!stream.stream_ops.mmap) {\r\n   throw new FS.ErrnoError(43);\r\n  }\r\n  return stream.stream_ops.mmap(stream, address, length, position, prot, flags);\r\n },\r\n msync: (stream, buffer, offset, length, mmapFlags) => {\r\n  if (!stream || !stream.stream_ops.msync) {\r\n   return 0;\r\n  }\r\n  return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\r\n },\r\n munmap: stream => 0,\r\n ioctl: (stream, cmd, arg) => {\r\n  if (!stream.stream_ops.ioctl) {\r\n   throw new FS.ErrnoError(59);\r\n  }\r\n  return stream.stream_ops.ioctl(stream, cmd, arg);\r\n },\r\n readFile: (path, opts = {}) => {\r\n  opts.flags = opts.flags || 0;\r\n  opts.encoding = opts.encoding || \"binary\";\r\n  if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\r\n   throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\r\n  }\r\n  var ret;\r\n  var stream = FS.open(path, opts.flags);\r\n  var stat = FS.stat(path);\r\n  var length = stat.size;\r\n  var buf = new Uint8Array(length);\r\n  FS.read(stream, buf, 0, length, 0);\r\n  if (opts.encoding === \"utf8\") {\r\n   ret = UTF8ArrayToString(buf, 0);\r\n  } else if (opts.encoding === \"binary\") {\r\n   ret = buf;\r\n  }\r\n  FS.close(stream);\r\n  return ret;\r\n },\r\n writeFile: (path, data, opts = {}) => {\r\n  opts.flags = opts.flags || 577;\r\n  var stream = FS.open(path, opts.flags, opts.mode);\r\n  if (typeof data === \"string\") {\r\n   var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\r\n   var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\r\n   FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\r\n  } else if (ArrayBuffer.isView(data)) {\r\n   FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\r\n  } else {\r\n   throw new Error(\"Unsupported data type\");\r\n  }\r\n  FS.close(stream);\r\n },\r\n cwd: () => FS.currentPath,\r\n chdir: path => {\r\n  var lookup = FS.lookupPath(path, {\r\n   follow: true\r\n  });\r\n  if (lookup.node === null) {\r\n   throw new FS.ErrnoError(44);\r\n  }\r\n  if (!FS.isDir(lookup.node.mode)) {\r\n   throw new FS.ErrnoError(54);\r\n  }\r\n  var errCode = FS.nodePermissions(lookup.node, \"x\");\r\n  if (errCode) {\r\n   throw new FS.ErrnoError(errCode);\r\n  }\r\n  FS.currentPath = lookup.path;\r\n },\r\n createDefaultDirectories: () => {\r\n  FS.mkdir(\"/tmp\");\r\n  FS.mkdir(\"/home\");\r\n  FS.mkdir(\"/home/web_user\");\r\n },\r\n createDefaultDevices: () => {\r\n  FS.mkdir(\"/dev\");\r\n  FS.registerDevice(FS.makedev(1, 3), {\r\n   read: () => 0,\r\n   write: (stream, buffer, offset, length, pos) => length\r\n  });\r\n  FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\r\n  TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\r\n  TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\r\n  FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\r\n  FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\r\n  var random_device = getRandomDevice();\r\n  FS.createDevice(\"/dev\", \"random\", random_device);\r\n  FS.createDevice(\"/dev\", \"urandom\", random_device);\r\n  FS.mkdir(\"/dev/shm\");\r\n  FS.mkdir(\"/dev/shm/tmp\");\r\n },\r\n createSpecialDirectories: () => {\r\n  FS.mkdir(\"/proc\");\r\n  var proc_self = FS.mkdir(\"/proc/self\");\r\n  FS.mkdir(\"/proc/self/fd\");\r\n  FS.mount({\r\n   mount: () => {\r\n    var node = FS.createNode(proc_self, \"fd\", 16384 | 511, 73);\r\n    node.node_ops = {\r\n     lookup: (parent, name) => {\r\n      var fd = +name;\r\n      var stream = FS.getStream(fd);\r\n      if (!stream) throw new FS.ErrnoError(8);\r\n      var ret = {\r\n       parent: null,\r\n       mount: {\r\n        mountpoint: \"fake\"\r\n       },\r\n       node_ops: {\r\n        readlink: () => stream.path\r\n       }\r\n      };\r\n      ret.parent = ret;\r\n      return ret;\r\n     }\r\n    };\r\n    return node;\r\n   }\r\n  }, {}, \"/proc/self/fd\");\r\n },\r\n createStandardStreams: () => {\r\n  if (Module[\"stdin\"]) {\r\n   FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\r\n  } else {\r\n   FS.symlink(\"/dev/tty\", \"/dev/stdin\");\r\n  }\r\n  if (Module[\"stdout\"]) {\r\n   FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\r\n  } else {\r\n   FS.symlink(\"/dev/tty\", \"/dev/stdout\");\r\n  }\r\n  if (Module[\"stderr\"]) {\r\n   FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\r\n  } else {\r\n   FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\r\n  }\r\n  var stdin = FS.open(\"/dev/stdin\", 0);\r\n  var stdout = FS.open(\"/dev/stdout\", 1);\r\n  var stderr = FS.open(\"/dev/stderr\", 1);\r\n  assert(stdin.fd === 0, \"invalid handle for stdin (\" + stdin.fd + \")\");\r\n  assert(stdout.fd === 1, \"invalid handle for stdout (\" + stdout.fd + \")\");\r\n  assert(stderr.fd === 2, \"invalid handle for stderr (\" + stderr.fd + \")\");\r\n },\r\n ensureErrnoError: () => {\r\n  if (FS.ErrnoError) return;\r\n  FS.ErrnoError = function ErrnoError(errno, node) {\r\n   this.node = node;\r\n   this.setErrno = function(errno) {\r\n    this.errno = errno;\r\n    for (var key in ERRNO_CODES) {\r\n     if (ERRNO_CODES[key] === errno) {\r\n      this.code = key;\r\n      break;\r\n     }\r\n    }\r\n   };\r\n   this.setErrno(errno);\r\n   this.message = ERRNO_MESSAGES[errno];\r\n   if (this.stack) {\r\n    Object.defineProperty(this, \"stack\", {\r\n     value: new Error().stack,\r\n     writable: true\r\n    });\r\n    this.stack = demangleAll(this.stack);\r\n   }\r\n  };\r\n  FS.ErrnoError.prototype = new Error();\r\n  FS.ErrnoError.prototype.constructor = FS.ErrnoError;\r\n  [ 44 ].forEach(code => {\r\n   FS.genericErrors[code] = new FS.ErrnoError(code);\r\n   FS.genericErrors[code].stack = \"<generic error, no stack>\";\r\n  });\r\n },\r\n staticInit: () => {\r\n  FS.ensureErrnoError();\r\n  FS.nameTable = new Array(4096);\r\n  FS.mount(MEMFS, {}, \"/\");\r\n  FS.createDefaultDirectories();\r\n  FS.createDefaultDevices();\r\n  FS.createSpecialDirectories();\r\n  FS.filesystems = {\r\n   \"MEMFS\": MEMFS\r\n  };\r\n },\r\n init: (input, output, error) => {\r\n  assert(!FS.init.initialized, \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\");\r\n  FS.init.initialized = true;\r\n  FS.ensureErrnoError();\r\n  Module[\"stdin\"] = input || Module[\"stdin\"];\r\n  Module[\"stdout\"] = output || Module[\"stdout\"];\r\n  Module[\"stderr\"] = error || Module[\"stderr\"];\r\n  FS.createStandardStreams();\r\n },\r\n quit: () => {\r\n  FS.init.initialized = false;\r\n  ___stdio_exit();\r\n  for (var i = 0; i < FS.streams.length; i++) {\r\n   var stream = FS.streams[i];\r\n   if (!stream) {\r\n    continue;\r\n   }\r\n   FS.close(stream);\r\n  }\r\n },\r\n getMode: (canRead, canWrite) => {\r\n  var mode = 0;\r\n  if (canRead) mode |= 292 | 73;\r\n  if (canWrite) mode |= 146;\r\n  return mode;\r\n },\r\n findObject: (path, dontResolveLastLink) => {\r\n  var ret = FS.analyzePath(path, dontResolveLastLink);\r\n  if (ret.exists) {\r\n   return ret.object;\r\n  } else {\r\n   return null;\r\n  }\r\n },\r\n analyzePath: (path, dontResolveLastLink) => {\r\n  try {\r\n   var lookup = FS.lookupPath(path, {\r\n    follow: !dontResolveLastLink\r\n   });\r\n   path = lookup.path;\r\n  } catch (e) {}\r\n  var ret = {\r\n   isRoot: false,\r\n   exists: false,\r\n   error: 0,\r\n   name: null,\r\n   path: null,\r\n   object: null,\r\n   parentExists: false,\r\n   parentPath: null,\r\n   parentObject: null\r\n  };\r\n  try {\r\n   var lookup = FS.lookupPath(path, {\r\n    parent: true\r\n   });\r\n   ret.parentExists = true;\r\n   ret.parentPath = lookup.path;\r\n   ret.parentObject = lookup.node;\r\n   ret.name = PATH.basename(path);\r\n   lookup = FS.lookupPath(path, {\r\n    follow: !dontResolveLastLink\r\n   });\r\n   ret.exists = true;\r\n   ret.path = lookup.path;\r\n   ret.object = lookup.node;\r\n   ret.name = lookup.node.name;\r\n   ret.isRoot = lookup.path === \"/\";\r\n  } catch (e) {\r\n   ret.error = e.errno;\r\n  }\r\n  return ret;\r\n },\r\n createPath: (parent, path, canRead, canWrite) => {\r\n  parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\r\n  var parts = path.split(\"/\").reverse();\r\n  while (parts.length) {\r\n   var part = parts.pop();\r\n   if (!part) continue;\r\n   var current = PATH.join2(parent, part);\r\n   try {\r\n    FS.mkdir(current);\r\n   } catch (e) {}\r\n   parent = current;\r\n  }\r\n  return current;\r\n },\r\n createFile: (parent, name, properties, canRead, canWrite) => {\r\n  var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\r\n  var mode = FS.getMode(canRead, canWrite);\r\n  return FS.create(path, mode);\r\n },\r\n createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {\r\n  var path = name;\r\n  if (parent) {\r\n   parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\r\n   path = name ? PATH.join2(parent, name) : parent;\r\n  }\r\n  var mode = FS.getMode(canRead, canWrite);\r\n  var node = FS.create(path, mode);\r\n  if (data) {\r\n   if (typeof data === \"string\") {\r\n    var arr = new Array(data.length);\r\n    for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\r\n    data = arr;\r\n   }\r\n   FS.chmod(node, mode | 146);\r\n   var stream = FS.open(node, 577);\r\n   FS.write(stream, data, 0, data.length, 0, canOwn);\r\n   FS.close(stream);\r\n   FS.chmod(node, mode);\r\n  }\r\n  return node;\r\n },\r\n createDevice: (parent, name, input, output) => {\r\n  var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\r\n  var mode = FS.getMode(!!input, !!output);\r\n  if (!FS.createDevice.major) FS.createDevice.major = 64;\r\n  var dev = FS.makedev(FS.createDevice.major++, 0);\r\n  FS.registerDevice(dev, {\r\n   open: stream => {\r\n    stream.seekable = false;\r\n   },\r\n   close: stream => {\r\n    if (output && output.buffer && output.buffer.length) {\r\n     output(10);\r\n    }\r\n   },\r\n   read: (stream, buffer, offset, length, pos) => {\r\n    var bytesRead = 0;\r\n    for (var i = 0; i < length; i++) {\r\n     var result;\r\n     try {\r\n      result = input();\r\n     } catch (e) {\r\n      throw new FS.ErrnoError(29);\r\n     }\r\n     if (result === undefined && bytesRead === 0) {\r\n      throw new FS.ErrnoError(6);\r\n     }\r\n     if (result === null || result === undefined) break;\r\n     bytesRead++;\r\n     buffer[offset + i] = result;\r\n    }\r\n    if (bytesRead) {\r\n     stream.node.timestamp = Date.now();\r\n    }\r\n    return bytesRead;\r\n   },\r\n   write: (stream, buffer, offset, length, pos) => {\r\n    for (var i = 0; i < length; i++) {\r\n     try {\r\n      output(buffer[offset + i]);\r\n     } catch (e) {\r\n      throw new FS.ErrnoError(29);\r\n     }\r\n    }\r\n    if (length) {\r\n     stream.node.timestamp = Date.now();\r\n    }\r\n    return i;\r\n   }\r\n  });\r\n  return FS.mkdev(path, mode, dev);\r\n },\r\n forceLoadFile: obj => {\r\n  if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\r\n  if (typeof XMLHttpRequest !== \"undefined\") {\r\n   throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\r\n  } else if (read_) {\r\n   try {\r\n    obj.contents = intArrayFromString(read_(obj.url), true);\r\n    obj.usedBytes = obj.contents.length;\r\n   } catch (e) {\r\n    throw new FS.ErrnoError(29);\r\n   }\r\n  } else {\r\n   throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\r\n  }\r\n },\r\n createLazyFile: (parent, name, url, canRead, canWrite) => {\r\n  function LazyUint8Array() {\r\n   this.lengthKnown = false;\r\n   this.chunks = [];\r\n  }\r\n  LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\r\n   if (idx > this.length - 1 || idx < 0) {\r\n    return undefined;\r\n   }\r\n   var chunkOffset = idx % this.chunkSize;\r\n   var chunkNum = idx / this.chunkSize | 0;\r\n   return this.getter(chunkNum)[chunkOffset];\r\n  };\r\n  LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\r\n   this.getter = getter;\r\n  };\r\n  LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\r\n   var xhr = new XMLHttpRequest();\r\n   xhr.open(\"HEAD\", url, false);\r\n   xhr.send(null);\r\n   if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n   var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\r\n   var header;\r\n   var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\r\n   var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\r\n   var chunkSize = 1024 * 1024;\r\n   if (!hasByteServing) chunkSize = datalength;\r\n   var doXHR = (from, to) => {\r\n    if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\r\n    if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(\"GET\", url, false);\r\n    if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\r\n    xhr.responseType = \"arraybuffer\";\r\n    if (xhr.overrideMimeType) {\r\n     xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n    }\r\n    xhr.send(null);\r\n    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n    if (xhr.response !== undefined) {\r\n     return new Uint8Array(xhr.response || []);\r\n    } else {\r\n     return intArrayFromString(xhr.responseText || \"\", true);\r\n    }\r\n   };\r\n   var lazyArray = this;\r\n   lazyArray.setDataGetter(chunkNum => {\r\n    var start = chunkNum * chunkSize;\r\n    var end = (chunkNum + 1) * chunkSize - 1;\r\n    end = Math.min(end, datalength - 1);\r\n    if (typeof lazyArray.chunks[chunkNum] === \"undefined\") {\r\n     lazyArray.chunks[chunkNum] = doXHR(start, end);\r\n    }\r\n    if (typeof lazyArray.chunks[chunkNum] === \"undefined\") throw new Error(\"doXHR failed!\");\r\n    return lazyArray.chunks[chunkNum];\r\n   });\r\n   if (usesGzip || !datalength) {\r\n    chunkSize = datalength = 1;\r\n    datalength = this.getter(0).length;\r\n    chunkSize = datalength;\r\n    out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\r\n   }\r\n   this._length = datalength;\r\n   this._chunkSize = chunkSize;\r\n   this.lengthKnown = true;\r\n  };\r\n  if (typeof XMLHttpRequest !== \"undefined\") {\r\n   if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\r\n   var lazyArray = new LazyUint8Array();\r\n   Object.defineProperties(lazyArray, {\r\n    length: {\r\n     get: function() {\r\n      if (!this.lengthKnown) {\r\n       this.cacheLength();\r\n      }\r\n      return this._length;\r\n     }\r\n    },\r\n    chunkSize: {\r\n     get: function() {\r\n      if (!this.lengthKnown) {\r\n       this.cacheLength();\r\n      }\r\n      return this._chunkSize;\r\n     }\r\n    }\r\n   });\r\n   var properties = {\r\n    isDevice: false,\r\n    contents: lazyArray\r\n   };\r\n  } else {\r\n   var properties = {\r\n    isDevice: false,\r\n    url: url\r\n   };\r\n  }\r\n  var node = FS.createFile(parent, name, properties, canRead, canWrite);\r\n  if (properties.contents) {\r\n   node.contents = properties.contents;\r\n  } else if (properties.url) {\r\n   node.contents = null;\r\n   node.url = properties.url;\r\n  }\r\n  Object.defineProperties(node, {\r\n   usedBytes: {\r\n    get: function() {\r\n     return this.contents.length;\r\n    }\r\n   }\r\n  });\r\n  var stream_ops = {};\r\n  var keys = Object.keys(node.stream_ops);\r\n  keys.forEach(key => {\r\n   var fn = node.stream_ops[key];\r\n   stream_ops[key] = function forceLoadLazyFile() {\r\n    FS.forceLoadFile(node);\r\n    return fn.apply(null, arguments);\r\n   };\r\n  });\r\n  stream_ops.read = ((stream, buffer, offset, length, position) => {\r\n   FS.forceLoadFile(node);\r\n   var contents = stream.node.contents;\r\n   if (position >= contents.length) return 0;\r\n   var size = Math.min(contents.length - position, length);\r\n   assert(size >= 0);\r\n   if (contents.slice) {\r\n    for (var i = 0; i < size; i++) {\r\n     buffer[offset + i] = contents[position + i];\r\n    }\r\n   } else {\r\n    for (var i = 0; i < size; i++) {\r\n     buffer[offset + i] = contents.get(position + i);\r\n    }\r\n   }\r\n   return size;\r\n  });\r\n  node.stream_ops = stream_ops;\r\n  return node;\r\n },\r\n createPreloadedFile: (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\r\n  var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\r\n  var dep = getUniqueRunDependency(\"cp \" + fullname);\r\n  function processData(byteArray) {\r\n   function finish(byteArray) {\r\n    if (preFinish) preFinish();\r\n    if (!dontCreateFile) {\r\n     FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\r\n    }\r\n    if (onload) onload();\r\n    removeRunDependency(dep);\r\n   }\r\n   if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {\r\n    if (onerror) onerror();\r\n    removeRunDependency(dep);\r\n   })) {\r\n    return;\r\n   }\r\n   finish(byteArray);\r\n  }\r\n  addRunDependency(dep);\r\n  if (typeof url == \"string\") {\r\n   asyncLoad(url, byteArray => processData(byteArray), onerror);\r\n  } else {\r\n   processData(url);\r\n  }\r\n },\r\n indexedDB: () => {\r\n  return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\r\n },\r\n DB_NAME: () => {\r\n  return \"EM_FS_\" + window.location.pathname;\r\n },\r\n DB_VERSION: 20,\r\n DB_STORE_NAME: \"FILE_DATA\",\r\n saveFilesToDB: (paths, onload, onerror) => {\r\n  onload = onload || (() => {});\r\n  onerror = onerror || (() => {});\r\n  var indexedDB = FS.indexedDB();\r\n  try {\r\n   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\r\n  } catch (e) {\r\n   return onerror(e);\r\n  }\r\n  openRequest.onupgradeneeded = (() => {\r\n   out(\"creating db\");\r\n   var db = openRequest.result;\r\n   db.createObjectStore(FS.DB_STORE_NAME);\r\n  });\r\n  openRequest.onsuccess = (() => {\r\n   var db = openRequest.result;\r\n   var transaction = db.transaction([ FS.DB_STORE_NAME ], \"readwrite\");\r\n   var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n   var ok = 0, fail = 0, total = paths.length;\r\n   function finish() {\r\n    if (fail == 0) onload(); else onerror();\r\n   }\r\n   paths.forEach(path => {\r\n    var putRequest = files.put(FS.analyzePath(path).object.contents, path);\r\n    putRequest.onsuccess = (() => {\r\n     ok++;\r\n     if (ok + fail == total) finish();\r\n    });\r\n    putRequest.onerror = (() => {\r\n     fail++;\r\n     if (ok + fail == total) finish();\r\n    });\r\n   });\r\n   transaction.onerror = onerror;\r\n  });\r\n  openRequest.onerror = onerror;\r\n },\r\n loadFilesFromDB: (paths, onload, onerror) => {\r\n  onload = onload || (() => {});\r\n  onerror = onerror || (() => {});\r\n  var indexedDB = FS.indexedDB();\r\n  try {\r\n   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\r\n  } catch (e) {\r\n   return onerror(e);\r\n  }\r\n  openRequest.onupgradeneeded = onerror;\r\n  openRequest.onsuccess = (() => {\r\n   var db = openRequest.result;\r\n   try {\r\n    var transaction = db.transaction([ FS.DB_STORE_NAME ], \"readonly\");\r\n   } catch (e) {\r\n    onerror(e);\r\n    return;\r\n   }\r\n   var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n   var ok = 0, fail = 0, total = paths.length;\r\n   function finish() {\r\n    if (fail == 0) onload(); else onerror();\r\n   }\r\n   paths.forEach(path => {\r\n    var getRequest = files.get(path);\r\n    getRequest.onsuccess = (() => {\r\n     if (FS.analyzePath(path).exists) {\r\n      FS.unlink(path);\r\n     }\r\n     FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\r\n     ok++;\r\n     if (ok + fail == total) finish();\r\n    });\r\n    getRequest.onerror = (() => {\r\n     fail++;\r\n     if (ok + fail == total) finish();\r\n    });\r\n   });\r\n   transaction.onerror = onerror;\r\n  });\r\n  openRequest.onerror = onerror;\r\n },\r\n absolutePath: () => {\r\n  abort(\"FS.absolutePath has been removed; use PATH_FS.resolve instead\");\r\n },\r\n createFolder: () => {\r\n  abort(\"FS.createFolder has been removed; use FS.mkdir instead\");\r\n },\r\n createLink: () => {\r\n  abort(\"FS.createLink has been removed; use FS.symlink instead\");\r\n },\r\n joinPath: () => {\r\n  abort(\"FS.joinPath has been removed; use PATH.join instead\");\r\n },\r\n mmapAlloc: () => {\r\n  abort(\"FS.mmapAlloc has been replaced by the top level function mmapAlloc\");\r\n },\r\n standardizePath: () => {\r\n  abort(\"FS.standardizePath has been removed; use PATH.normalize instead\");\r\n }\r\n};\r\n\r\nvar SYSCALLS = {\r\n mappings: {},\r\n DEFAULT_POLLMASK: 5,\r\n calculateAt: function(dirfd, path, allowEmpty) {\r\n  if (path[0] === \"/\") {\r\n   return path;\r\n  }\r\n  var dir;\r\n  if (dirfd === -100) {\r\n   dir = FS.cwd();\r\n  } else {\r\n   var dirstream = FS.getStream(dirfd);\r\n   if (!dirstream) throw new FS.ErrnoError(8);\r\n   dir = dirstream.path;\r\n  }\r\n  if (path.length == 0) {\r\n   if (!allowEmpty) {\r\n    throw new FS.ErrnoError(44);\r\n   }\r\n   return dir;\r\n  }\r\n  return PATH.join2(dir, path);\r\n },\r\n doStat: function(func, path, buf) {\r\n  try {\r\n   var stat = func(path);\r\n  } catch (e) {\r\n   if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\r\n    return -54;\r\n   }\r\n   throw e;\r\n  }\r\n  _asan_js_store_4(buf >> 2, stat.dev);\r\n  _asan_js_store_4(buf + 4 >> 2, 0);\r\n  _asan_js_store_4(buf + 8 >> 2, stat.ino);\r\n  _asan_js_store_4(buf + 12 >> 2, stat.mode);\r\n  _asan_js_store_4(buf + 16 >> 2, stat.nlink);\r\n  _asan_js_store_4(buf + 20 >> 2, stat.uid);\r\n  _asan_js_store_4(buf + 24 >> 2, stat.gid);\r\n  _asan_js_store_4(buf + 28 >> 2, stat.rdev);\r\n  _asan_js_store_4(buf + 32 >> 2, 0);\r\n  tempI64 = [ stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \r\n  _asan_js_store_4(buf + 40 >> 2, tempI64[0]), _asan_js_store_4(buf + 44 >> 2, tempI64[1]);\r\n  _asan_js_store_4(buf + 48 >> 2, 4096);\r\n  _asan_js_store_4(buf + 52 >> 2, stat.blocks);\r\n  _asan_js_store_4(buf + 56 >> 2, stat.atime.getTime() / 1e3 | 0);\r\n  _asan_js_store_4(buf + 60 >> 2, 0);\r\n  _asan_js_store_4(buf + 64 >> 2, stat.mtime.getTime() / 1e3 | 0);\r\n  _asan_js_store_4(buf + 68 >> 2, 0);\r\n  _asan_js_store_4(buf + 72 >> 2, stat.ctime.getTime() / 1e3 | 0);\r\n  _asan_js_store_4(buf + 76 >> 2, 0);\r\n  tempI64 = [ stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \r\n  _asan_js_store_4(buf + 80 >> 2, tempI64[0]), _asan_js_store_4(buf + 84 >> 2, tempI64[1]);\r\n  return 0;\r\n },\r\n doMsync: function(addr, stream, len, flags, offset) {\r\n  var buffer = HEAPU8.slice(addr, addr + len);\r\n  FS.msync(stream, buffer, offset, len, flags);\r\n },\r\n doMkdir: function(path, mode) {\r\n  path = PATH.normalize(path);\r\n  if (path[path.length - 1] === \"/\") path = path.substr(0, path.length - 1);\r\n  FS.mkdir(path, mode, 0);\r\n  return 0;\r\n },\r\n doMknod: function(path, mode, dev) {\r\n  switch (mode & 61440) {\r\n  case 32768:\r\n  case 8192:\r\n  case 24576:\r\n  case 4096:\r\n  case 49152:\r\n   break;\r\n\r\n  default:\r\n   return -28;\r\n  }\r\n  FS.mknod(path, mode, dev);\r\n  return 0;\r\n },\r\n doReadlink: function(path, buf, bufsize) {\r\n  if (bufsize <= 0) return -28;\r\n  var ret = FS.readlink(path);\r\n  var len = Math.min(bufsize, lengthBytesUTF8(ret));\r\n  var endChar = _asan_js_load_1(buf + len);\r\n  stringToUTF8(ret, buf, bufsize + 1);\r\n  _asan_js_store_1(buf + len, endChar);\r\n  return len;\r\n },\r\n doAccess: function(path, amode) {\r\n  if (amode & ~7) {\r\n   return -28;\r\n  }\r\n  var lookup = FS.lookupPath(path, {\r\n   follow: true\r\n  });\r\n  var node = lookup.node;\r\n  if (!node) {\r\n   return -44;\r\n  }\r\n  var perms = \"\";\r\n  if (amode & 4) perms += \"r\";\r\n  if (amode & 2) perms += \"w\";\r\n  if (amode & 1) perms += \"x\";\r\n  if (perms && FS.nodePermissions(node, perms)) {\r\n   return -2;\r\n  }\r\n  return 0;\r\n },\r\n doDup: function(path, flags, suggestFD) {\r\n  var suggest = FS.getStream(suggestFD);\r\n  if (suggest) FS.close(suggest);\r\n  return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\r\n },\r\n doReadv: function(stream, iov, iovcnt, offset) {\r\n  var ret = 0;\r\n  for (var i = 0; i < iovcnt; i++) {\r\n   var ptr = _asan_js_load_4(iov + i * 8 >> 2);\r\n   var len = _asan_js_load_4(iov + (i * 8 + 4) >> 2);\r\n   var curr = FS.read(stream, HEAP8, ptr, len, offset);\r\n   if (curr < 0) return -1;\r\n   ret += curr;\r\n   if (curr < len) break;\r\n  }\r\n  return ret;\r\n },\r\n doWritev: function(stream, iov, iovcnt, offset) {\r\n  var ret = 0;\r\n  for (var i = 0; i < iovcnt; i++) {\r\n   var ptr = _asan_js_load_4(iov + i * 8 >> 2);\r\n   var len = _asan_js_load_4(iov + (i * 8 + 4) >> 2);\r\n   var curr = FS.write(stream, HEAP8, ptr, len, offset);\r\n   if (curr < 0) return -1;\r\n   ret += curr;\r\n  }\r\n  return ret;\r\n },\r\n varargs: undefined,\r\n get: function() {\r\n  assert(SYSCALLS.varargs != undefined);\r\n  SYSCALLS.varargs += 4;\r\n  var ret = _asan_js_load_4(SYSCALLS.varargs - 4 >> 2);\r\n  return ret;\r\n },\r\n getStr: function(ptr) {\r\n  var ret = UTF8ToString(ptr);\r\n  return ret;\r\n },\r\n getStreamFromFD: function(fd) {\r\n  var stream = FS.getStream(fd);\r\n  if (!stream) throw new FS.ErrnoError(8);\r\n  return stream;\r\n },\r\n get64: function(low, high) {\r\n  if (low >= 0) assert(high === 0); else assert(high === -1);\r\n  return low;\r\n }\r\n};\r\n\r\nfunction ___syscall_dup(fd) {\r\n try {\r\n  var old = SYSCALLS.getStreamFromFD(fd);\r\n  return FS.open(old.path, old.flags, 0).fd;\r\n } catch (e) {\r\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\r\n  return -e.errno;\r\n }\r\n}\r\n\r\nfunction ___syscall_open(path, flags, varargs) {\r\n SYSCALLS.varargs = varargs;\r\n try {\r\n  var pathname = SYSCALLS.getStr(path);\r\n  var mode = varargs ? SYSCALLS.get() : 0;\r\n  var stream = FS.open(pathname, flags, mode);\r\n  return stream.fd;\r\n } catch (e) {\r\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\r\n  return -e.errno;\r\n }\r\n}\r\n\r\nfunction ___syscall_stat64(path, buf) {\r\n try {\r\n  path = SYSCALLS.getStr(path);\r\n  return SYSCALLS.doStat(FS.stat, path, buf);\r\n } catch (e) {\r\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\r\n  return -e.errno;\r\n }\r\n}\r\n\r\nfunction __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\r\n\r\nfunction getShiftFromSize(size) {\r\n switch (size) {\r\n case 1:\r\n  return 0;\r\n\r\n case 2:\r\n  return 1;\r\n\r\n case 4:\r\n  return 2;\r\n\r\n case 8:\r\n  return 3;\r\n\r\n default:\r\n  throw new TypeError(\"Unknown type size: \" + size);\r\n }\r\n}\r\n\r\nfunction embind_init_charCodes() {\r\n var codes = new Array(256);\r\n for (var i = 0; i < 256; ++i) {\r\n  codes[i] = String.fromCharCode(i);\r\n }\r\n embind_charCodes = codes;\r\n}\r\n\r\nvar embind_charCodes = undefined;\r\n\r\nfunction readLatin1String(ptr) {\r\n var ret = \"\";\r\n var c = ptr;\r\n while (_asan_js_load_1u(c)) {\r\n  ret += embind_charCodes[_asan_js_load_1u(c++)];\r\n }\r\n return ret;\r\n}\r\n\r\nvar awaitingDependencies = {};\r\n\r\nvar registeredTypes = {};\r\n\r\nvar typeDependencies = {};\r\n\r\nvar char_0 = 48;\r\n\r\nvar char_9 = 57;\r\n\r\nfunction makeLegalFunctionName(name) {\r\n if (undefined === name) {\r\n  return \"_unknown\";\r\n }\r\n name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\r\n var f = name.charCodeAt(0);\r\n if (f >= char_0 && f <= char_9) {\r\n  return \"_\" + name;\r\n } else {\r\n  return name;\r\n }\r\n}\r\n\r\nfunction createNamedFunction(name, body) {\r\n name = makeLegalFunctionName(name);\r\n return new Function(\"body\", \"return function \" + name + \"() {\\n\" + '    \"use strict\";' + \"    return body.apply(this, arguments);\\n\" + \"};\\n\")(body);\r\n}\r\n\r\nfunction extendError(baseErrorType, errorName) {\r\n var errorClass = createNamedFunction(errorName, function(message) {\r\n  this.name = errorName;\r\n  this.message = message;\r\n  var stack = new Error(message).stack;\r\n  if (stack !== undefined) {\r\n   this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\r\n  }\r\n });\r\n errorClass.prototype = Object.create(baseErrorType.prototype);\r\n errorClass.prototype.constructor = errorClass;\r\n errorClass.prototype.toString = function() {\r\n  if (this.message === undefined) {\r\n   return this.name;\r\n  } else {\r\n   return this.name + \": \" + this.message;\r\n  }\r\n };\r\n return errorClass;\r\n}\r\n\r\nvar BindingError = undefined;\r\n\r\nfunction throwBindingError(message) {\r\n throw new BindingError(message);\r\n}\r\n\r\nvar InternalError = undefined;\r\n\r\nfunction throwInternalError(message) {\r\n throw new InternalError(message);\r\n}\r\n\r\nfunction whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\r\n myTypes.forEach(function(type) {\r\n  typeDependencies[type] = dependentTypes;\r\n });\r\n function onComplete(typeConverters) {\r\n  var myTypeConverters = getTypeConverters(typeConverters);\r\n  if (myTypeConverters.length !== myTypes.length) {\r\n   throwInternalError(\"Mismatched type converter count\");\r\n  }\r\n  for (var i = 0; i < myTypes.length; ++i) {\r\n   registerType(myTypes[i], myTypeConverters[i]);\r\n  }\r\n }\r\n var typeConverters = new Array(dependentTypes.length);\r\n var unregisteredTypes = [];\r\n var registered = 0;\r\n dependentTypes.forEach(function(dt, i) {\r\n  if (registeredTypes.hasOwnProperty(dt)) {\r\n   typeConverters[i] = registeredTypes[dt];\r\n  } else {\r\n   unregisteredTypes.push(dt);\r\n   if (!awaitingDependencies.hasOwnProperty(dt)) {\r\n    awaitingDependencies[dt] = [];\r\n   }\r\n   awaitingDependencies[dt].push(function() {\r\n    typeConverters[i] = registeredTypes[dt];\r\n    ++registered;\r\n    if (registered === unregisteredTypes.length) {\r\n     onComplete(typeConverters);\r\n    }\r\n   });\r\n  }\r\n });\r\n if (0 === unregisteredTypes.length) {\r\n  onComplete(typeConverters);\r\n }\r\n}\r\n\r\nfunction registerType(rawType, registeredInstance, options = {}) {\r\n if (!(\"argPackAdvance\" in registeredInstance)) {\r\n  throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\r\n }\r\n var name = registeredInstance.name;\r\n if (!rawType) {\r\n  throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\r\n }\r\n if (registeredTypes.hasOwnProperty(rawType)) {\r\n  if (options.ignoreDuplicateRegistrations) {\r\n   return;\r\n  } else {\r\n   throwBindingError(\"Cannot register type '\" + name + \"' twice\");\r\n  }\r\n }\r\n registeredTypes[rawType] = registeredInstance;\r\n delete typeDependencies[rawType];\r\n if (awaitingDependencies.hasOwnProperty(rawType)) {\r\n  var callbacks = awaitingDependencies[rawType];\r\n  delete awaitingDependencies[rawType];\r\n  callbacks.forEach(function(cb) {\r\n   cb();\r\n  });\r\n }\r\n}\r\n\r\nfunction __embind_register_bool(rawType, name, size, trueValue, falseValue) {\r\n var shift = getShiftFromSize(size);\r\n name = readLatin1String(name);\r\n registerType(rawType, {\r\n  name: name,\r\n  \"fromWireType\": function(wt) {\r\n   return !!wt;\r\n  },\r\n  \"toWireType\": function(destructors, o) {\r\n   return o ? trueValue : falseValue;\r\n  },\r\n  \"argPackAdvance\": 8,\r\n  \"readValueFromPointer\": function(pointer) {\r\n   var heap;\r\n   if (size === 1) {\r\n    heap = HEAP8;\r\n   } else if (size === 2) {\r\n    heap = HEAP16;\r\n   } else if (size === 4) {\r\n    heap = HEAP32;\r\n   } else {\r\n    throw new TypeError(\"Unknown boolean type size: \" + name);\r\n   }\r\n   return this[\"fromWireType\"](heap[pointer >> shift]);\r\n  },\r\n  destructorFunction: null\r\n });\r\n}\r\n\r\nfunction ClassHandle_isAliasOf(other) {\r\n if (!(this instanceof ClassHandle)) {\r\n  return false;\r\n }\r\n if (!(other instanceof ClassHandle)) {\r\n  return false;\r\n }\r\n var leftClass = this.$$.ptrType.registeredClass;\r\n var left = this.$$.ptr;\r\n var rightClass = other.$$.ptrType.registeredClass;\r\n var right = other.$$.ptr;\r\n while (leftClass.baseClass) {\r\n  left = leftClass.upcast(left);\r\n  leftClass = leftClass.baseClass;\r\n }\r\n while (rightClass.baseClass) {\r\n  right = rightClass.upcast(right);\r\n  rightClass = rightClass.baseClass;\r\n }\r\n return leftClass === rightClass && left === right;\r\n}\r\n\r\nfunction shallowCopyInternalPointer(o) {\r\n return {\r\n  count: o.count,\r\n  deleteScheduled: o.deleteScheduled,\r\n  preservePointerOnDelete: o.preservePointerOnDelete,\r\n  ptr: o.ptr,\r\n  ptrType: o.ptrType,\r\n  smartPtr: o.smartPtr,\r\n  smartPtrType: o.smartPtrType\r\n };\r\n}\r\n\r\nfunction throwInstanceAlreadyDeleted(obj) {\r\n function getInstanceTypeName(handle) {\r\n  return handle.$$.ptrType.registeredClass.name;\r\n }\r\n throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\r\n}\r\n\r\nvar finalizationRegistry = false;\r\n\r\nfunction detachFinalizer(handle) {}\r\n\r\nfunction runDestructor($$) {\r\n if ($$.smartPtr) {\r\n  $$.smartPtrType.rawDestructor($$.smartPtr);\r\n } else {\r\n  $$.ptrType.registeredClass.rawDestructor($$.ptr);\r\n }\r\n}\r\n\r\nfunction releaseClassHandle($$) {\r\n $$.count.value -= 1;\r\n var toDelete = 0 === $$.count.value;\r\n if (toDelete) {\r\n  runDestructor($$);\r\n }\r\n}\r\n\r\nfunction downcastPointer(ptr, ptrClass, desiredClass) {\r\n if (ptrClass === desiredClass) {\r\n  return ptr;\r\n }\r\n if (undefined === desiredClass.baseClass) {\r\n  return null;\r\n }\r\n var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\r\n if (rv === null) {\r\n  return null;\r\n }\r\n return desiredClass.downcast(rv);\r\n}\r\n\r\nvar registeredPointers = {};\r\n\r\nfunction getInheritedInstanceCount() {\r\n return Object.keys(registeredInstances).length;\r\n}\r\n\r\nfunction getLiveInheritedInstances() {\r\n var rv = [];\r\n for (var k in registeredInstances) {\r\n  if (registeredInstances.hasOwnProperty(k)) {\r\n   rv.push(registeredInstances[k]);\r\n  }\r\n }\r\n return rv;\r\n}\r\n\r\nvar deletionQueue = [];\r\n\r\nfunction flushPendingDeletes() {\r\n while (deletionQueue.length) {\r\n  var obj = deletionQueue.pop();\r\n  obj.$$.deleteScheduled = false;\r\n  obj[\"delete\"]();\r\n }\r\n}\r\n\r\nvar delayFunction = undefined;\r\n\r\nfunction setDelayFunction(fn) {\r\n delayFunction = fn;\r\n if (deletionQueue.length && delayFunction) {\r\n  delayFunction(flushPendingDeletes);\r\n }\r\n}\r\n\r\nfunction init_embind() {\r\n Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\r\n Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\r\n Module[\"flushPendingDeletes\"] = flushPendingDeletes;\r\n Module[\"setDelayFunction\"] = setDelayFunction;\r\n}\r\n\r\nvar registeredInstances = {};\r\n\r\nfunction getBasestPointer(class_, ptr) {\r\n if (ptr === undefined) {\r\n  throwBindingError(\"ptr should not be undefined\");\r\n }\r\n while (class_.baseClass) {\r\n  ptr = class_.upcast(ptr);\r\n  class_ = class_.baseClass;\r\n }\r\n return ptr;\r\n}\r\n\r\nfunction getInheritedInstance(class_, ptr) {\r\n ptr = getBasestPointer(class_, ptr);\r\n return registeredInstances[ptr];\r\n}\r\n\r\nfunction makeClassHandle(prototype, record) {\r\n if (!record.ptrType || !record.ptr) {\r\n  throwInternalError(\"makeClassHandle requires ptr and ptrType\");\r\n }\r\n var hasSmartPtrType = !!record.smartPtrType;\r\n var hasSmartPtr = !!record.smartPtr;\r\n if (hasSmartPtrType !== hasSmartPtr) {\r\n  throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\r\n }\r\n record.count = {\r\n  value: 1\r\n };\r\n return attachFinalizer(Object.create(prototype, {\r\n  $$: {\r\n   value: record\r\n  }\r\n }));\r\n}\r\n\r\nfunction RegisteredPointer_fromWireType(ptr) {\r\n var rawPointer = this.getPointee(ptr);\r\n if (!rawPointer) {\r\n  this.destructor(ptr);\r\n  return null;\r\n }\r\n var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\r\n if (undefined !== registeredInstance) {\r\n  if (0 === registeredInstance.$$.count.value) {\r\n   registeredInstance.$$.ptr = rawPointer;\r\n   registeredInstance.$$.smartPtr = ptr;\r\n   return registeredInstance[\"clone\"]();\r\n  } else {\r\n   var rv = registeredInstance[\"clone\"]();\r\n   this.destructor(ptr);\r\n   return rv;\r\n  }\r\n }\r\n function makeDefaultHandle() {\r\n  if (this.isSmartPointer) {\r\n   return makeClassHandle(this.registeredClass.instancePrototype, {\r\n    ptrType: this.pointeeType,\r\n    ptr: rawPointer,\r\n    smartPtrType: this,\r\n    smartPtr: ptr\r\n   });\r\n  } else {\r\n   return makeClassHandle(this.registeredClass.instancePrototype, {\r\n    ptrType: this,\r\n    ptr: ptr\r\n   });\r\n  }\r\n }\r\n var actualType = this.registeredClass.getActualType(rawPointer);\r\n var registeredPointerRecord = registeredPointers[actualType];\r\n if (!registeredPointerRecord) {\r\n  return makeDefaultHandle.call(this);\r\n }\r\n var toType;\r\n if (this.isConst) {\r\n  toType = registeredPointerRecord.constPointerType;\r\n } else {\r\n  toType = registeredPointerRecord.pointerType;\r\n }\r\n var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\r\n if (dp === null) {\r\n  return makeDefaultHandle.call(this);\r\n }\r\n if (this.isSmartPointer) {\r\n  return makeClassHandle(toType.registeredClass.instancePrototype, {\r\n   ptrType: toType,\r\n   ptr: dp,\r\n   smartPtrType: this,\r\n   smartPtr: ptr\r\n  });\r\n } else {\r\n  return makeClassHandle(toType.registeredClass.instancePrototype, {\r\n   ptrType: toType,\r\n   ptr: dp\r\n  });\r\n }\r\n}\r\n\r\nfunction attachFinalizer(handle) {\r\n if (\"undefined\" === typeof FinalizationRegistry) {\r\n  attachFinalizer = (handle => handle);\r\n  return handle;\r\n }\r\n finalizationRegistry = new FinalizationRegistry(info => {\r\n  console.warn(info.leakWarning.stack.replace(/^Error: /, \"\"));\r\n  releaseClassHandle(info.$$);\r\n });\r\n attachFinalizer = (handle => {\r\n  var $$ = handle.$$;\r\n  var hasSmartPtr = !!$$.smartPtr;\r\n  if (hasSmartPtr) {\r\n   var info = {\r\n    $$: $$\r\n   };\r\n   var cls = $$.ptrType.registeredClass;\r\n   info.leakWarning = new Error(\"Embind found a leaked C++ instance \" + cls.name + \" <0x\" + $$.ptr.toString(16) + \">.\\n\" + \"We'll free it automatically in this case, but this functionality is not reliable across various environments.\\n\" + \"Make sure to invoke .delete() manually once you're done with the instance instead.\\n\" + \"Originally allocated\");\r\n   if (\"captureStackTrace\" in Error) {\r\n    Error.captureStackTrace(info.leakWarning, RegisteredPointer_fromWireType);\r\n   }\r\n   finalizationRegistry.register(handle, info, handle);\r\n  }\r\n  return handle;\r\n });\r\n detachFinalizer = (handle => finalizationRegistry.unregister(handle));\r\n return attachFinalizer(handle);\r\n}\r\n\r\nfunction ClassHandle_clone() {\r\n if (!this.$$.ptr) {\r\n  throwInstanceAlreadyDeleted(this);\r\n }\r\n if (this.$$.preservePointerOnDelete) {\r\n  this.$$.count.value += 1;\r\n  return this;\r\n } else {\r\n  var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\r\n   $$: {\r\n    value: shallowCopyInternalPointer(this.$$)\r\n   }\r\n  }));\r\n  clone.$$.count.value += 1;\r\n  clone.$$.deleteScheduled = false;\r\n  return clone;\r\n }\r\n}\r\n\r\nfunction ClassHandle_delete() {\r\n if (!this.$$.ptr) {\r\n  throwInstanceAlreadyDeleted(this);\r\n }\r\n if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\r\n  throwBindingError(\"Object already scheduled for deletion\");\r\n }\r\n detachFinalizer(this);\r\n releaseClassHandle(this.$$);\r\n if (!this.$$.preservePointerOnDelete) {\r\n  this.$$.smartPtr = undefined;\r\n  this.$$.ptr = undefined;\r\n }\r\n}\r\n\r\nfunction ClassHandle_isDeleted() {\r\n return !this.$$.ptr;\r\n}\r\n\r\nfunction ClassHandle_deleteLater() {\r\n if (!this.$$.ptr) {\r\n  throwInstanceAlreadyDeleted(this);\r\n }\r\n if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\r\n  throwBindingError(\"Object already scheduled for deletion\");\r\n }\r\n deletionQueue.push(this);\r\n if (deletionQueue.length === 1 && delayFunction) {\r\n  delayFunction(flushPendingDeletes);\r\n }\r\n this.$$.deleteScheduled = true;\r\n return this;\r\n}\r\n\r\nfunction init_ClassHandle() {\r\n ClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\r\n ClassHandle.prototype[\"clone\"] = ClassHandle_clone;\r\n ClassHandle.prototype[\"delete\"] = ClassHandle_delete;\r\n ClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\r\n ClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater;\r\n}\r\n\r\nfunction ClassHandle() {}\r\n\r\nfunction ensureOverloadTable(proto, methodName, humanName) {\r\n if (undefined === proto[methodName].overloadTable) {\r\n  var prevFunc = proto[methodName];\r\n  proto[methodName] = function() {\r\n   if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\r\n    throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\r\n   }\r\n   return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\r\n  };\r\n  proto[methodName].overloadTable = [];\r\n  proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\r\n }\r\n}\r\n\r\nfunction exposePublicSymbol(name, value, numArguments) {\r\n if (Module.hasOwnProperty(name)) {\r\n  if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\r\n   throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\r\n  }\r\n  ensureOverloadTable(Module, name, name);\r\n  if (Module.hasOwnProperty(numArguments)) {\r\n   throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\r\n  }\r\n  Module[name].overloadTable[numArguments] = value;\r\n } else {\r\n  Module[name] = value;\r\n  if (undefined !== numArguments) {\r\n   Module[name].numArguments = numArguments;\r\n  }\r\n }\r\n}\r\n\r\nfunction RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\r\n this.name = name;\r\n this.constructor = constructor;\r\n this.instancePrototype = instancePrototype;\r\n this.rawDestructor = rawDestructor;\r\n this.baseClass = baseClass;\r\n this.getActualType = getActualType;\r\n this.upcast = upcast;\r\n this.downcast = downcast;\r\n this.pureVirtualFunctions = [];\r\n}\r\n\r\nfunction upcastPointer(ptr, ptrClass, desiredClass) {\r\n while (ptrClass !== desiredClass) {\r\n  if (!ptrClass.upcast) {\r\n   throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\r\n  }\r\n  ptr = ptrClass.upcast(ptr);\r\n  ptrClass = ptrClass.baseClass;\r\n }\r\n return ptr;\r\n}\r\n\r\nfunction constNoSmartPtrRawPointerToWireType(destructors, handle) {\r\n if (handle === null) {\r\n  if (this.isReference) {\r\n   throwBindingError(\"null is not a valid \" + this.name);\r\n  }\r\n  return 0;\r\n }\r\n if (!handle.$$) {\r\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\r\n }\r\n if (!handle.$$.ptr) {\r\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\r\n }\r\n var handleClass = handle.$$.ptrType.registeredClass;\r\n var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n return ptr;\r\n}\r\n\r\nfunction genericPointerToWireType(destructors, handle) {\r\n var ptr;\r\n if (handle === null) {\r\n  if (this.isReference) {\r\n   throwBindingError(\"null is not a valid \" + this.name);\r\n  }\r\n  if (this.isSmartPointer) {\r\n   ptr = this.rawConstructor();\r\n   if (destructors !== null) {\r\n    destructors.push(this.rawDestructor, ptr);\r\n   }\r\n   return ptr;\r\n  } else {\r\n   return 0;\r\n  }\r\n }\r\n if (!handle.$$) {\r\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\r\n }\r\n if (!handle.$$.ptr) {\r\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\r\n }\r\n if (!this.isConst && handle.$$.ptrType.isConst) {\r\n  throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\r\n }\r\n var handleClass = handle.$$.ptrType.registeredClass;\r\n ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n if (this.isSmartPointer) {\r\n  if (undefined === handle.$$.smartPtr) {\r\n   throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\r\n  }\r\n  switch (this.sharingPolicy) {\r\n  case 0:\r\n   if (handle.$$.smartPtrType === this) {\r\n    ptr = handle.$$.smartPtr;\r\n   } else {\r\n    throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\r\n   }\r\n   break;\r\n\r\n  case 1:\r\n   ptr = handle.$$.smartPtr;\r\n   break;\r\n\r\n  case 2:\r\n   if (handle.$$.smartPtrType === this) {\r\n    ptr = handle.$$.smartPtr;\r\n   } else {\r\n    var clonedHandle = handle[\"clone\"]();\r\n    ptr = this.rawShare(ptr, Emval.toHandle(function() {\r\n     clonedHandle[\"delete\"]();\r\n    }));\r\n    if (destructors !== null) {\r\n     destructors.push(this.rawDestructor, ptr);\r\n    }\r\n   }\r\n   break;\r\n\r\n  default:\r\n   throwBindingError(\"Unsupporting sharing policy\");\r\n  }\r\n }\r\n return ptr;\r\n}\r\n\r\nfunction nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\r\n if (handle === null) {\r\n  if (this.isReference) {\r\n   throwBindingError(\"null is not a valid \" + this.name);\r\n  }\r\n  return 0;\r\n }\r\n if (!handle.$$) {\r\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\r\n }\r\n if (!handle.$$.ptr) {\r\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\r\n }\r\n if (handle.$$.ptrType.isConst) {\r\n  throwBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name);\r\n }\r\n var handleClass = handle.$$.ptrType.registeredClass;\r\n var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n return ptr;\r\n}\r\n\r\nfunction simpleReadValueFromPointer(pointer) {\r\n return this[\"fromWireType\"](_asan_js_load_4u(pointer >> 2));\r\n}\r\n\r\nfunction RegisteredPointer_getPointee(ptr) {\r\n if (this.rawGetPointee) {\r\n  ptr = this.rawGetPointee(ptr);\r\n }\r\n return ptr;\r\n}\r\n\r\nfunction RegisteredPointer_destructor(ptr) {\r\n if (this.rawDestructor) {\r\n  this.rawDestructor(ptr);\r\n }\r\n}\r\n\r\nfunction RegisteredPointer_deleteObject(handle) {\r\n if (handle !== null) {\r\n  handle[\"delete\"]();\r\n }\r\n}\r\n\r\nfunction init_RegisteredPointer() {\r\n RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\r\n RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\r\n RegisteredPointer.prototype[\"argPackAdvance\"] = 8;\r\n RegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\r\n RegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\r\n RegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType;\r\n}\r\n\r\nfunction RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\r\n this.name = name;\r\n this.registeredClass = registeredClass;\r\n this.isReference = isReference;\r\n this.isConst = isConst;\r\n this.isSmartPointer = isSmartPointer;\r\n this.pointeeType = pointeeType;\r\n this.sharingPolicy = sharingPolicy;\r\n this.rawGetPointee = rawGetPointee;\r\n this.rawConstructor = rawConstructor;\r\n this.rawShare = rawShare;\r\n this.rawDestructor = rawDestructor;\r\n if (!isSmartPointer && registeredClass.baseClass === undefined) {\r\n  if (isConst) {\r\n   this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\r\n   this.destructorFunction = null;\r\n  } else {\r\n   this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\r\n   this.destructorFunction = null;\r\n  }\r\n } else {\r\n  this[\"toWireType\"] = genericPointerToWireType;\r\n }\r\n}\r\n\r\nfunction replacePublicSymbol(name, value, numArguments) {\r\n if (!Module.hasOwnProperty(name)) {\r\n  throwInternalError(\"Replacing nonexistant public symbol\");\r\n }\r\n if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\r\n  Module[name].overloadTable[numArguments] = value;\r\n } else {\r\n  Module[name] = value;\r\n  Module[name].argCount = numArguments;\r\n }\r\n}\r\n\r\nfunction dynCallLegacy(sig, ptr, args) {\r\n assert(\"dynCall_\" + sig in Module, \"bad function pointer type - no table for sig '\" + sig + \"'\");\r\n if (args && args.length) {\r\n  assert(args.length === sig.substring(1).replace(/j/g, \"--\").length);\r\n } else {\r\n  assert(sig.length == 1);\r\n }\r\n var f = Module[\"dynCall_\" + sig];\r\n return args && args.length ? f.apply(null, [ ptr ].concat(args)) : f.call(null, ptr);\r\n}\r\n\r\nfunction dynCall(sig, ptr, args) {\r\n if (sig.includes(\"j\")) {\r\n  return dynCallLegacy(sig, ptr, args);\r\n }\r\n assert(getWasmTableEntry(ptr), \"missing table entry in dynCall: \" + ptr);\r\n return getWasmTableEntry(ptr).apply(null, args);\r\n}\r\n\r\nfunction getDynCaller(sig, ptr) {\r\n assert(sig.includes(\"j\"), \"getDynCaller should only be called with i64 sigs\");\r\n var argCache = [];\r\n return function() {\r\n  argCache.length = 0;\r\n  Object.assign(argCache, arguments);\r\n  return dynCall(sig, ptr, argCache);\r\n };\r\n}\r\n\r\nfunction embind__requireFunction(signature, rawFunction) {\r\n signature = readLatin1String(signature);\r\n function makeDynCaller() {\r\n  if (signature.includes(\"j\")) {\r\n   return getDynCaller(signature, rawFunction);\r\n  }\r\n  return getWasmTableEntry(rawFunction);\r\n }\r\n var fp = makeDynCaller();\r\n if (typeof fp !== \"function\") {\r\n  throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\r\n }\r\n return fp;\r\n}\r\n\r\nvar UnboundTypeError = undefined;\r\n\r\nfunction getTypeName(type) {\r\n var ptr = ___getTypeName(type);\r\n var rv = readLatin1String(ptr);\r\n _free(ptr);\r\n return rv;\r\n}\r\n\r\nfunction throwUnboundTypeError(message, types) {\r\n var unboundTypes = [];\r\n var seen = {};\r\n function visit(type) {\r\n  if (seen[type]) {\r\n   return;\r\n  }\r\n  if (registeredTypes[type]) {\r\n   return;\r\n  }\r\n  if (typeDependencies[type]) {\r\n   typeDependencies[type].forEach(visit);\r\n   return;\r\n  }\r\n  unboundTypes.push(type);\r\n  seen[type] = true;\r\n }\r\n types.forEach(visit);\r\n throw new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([ \", \" ]));\r\n}\r\n\r\nfunction __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\r\n name = readLatin1String(name);\r\n getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\r\n if (upcast) {\r\n  upcast = embind__requireFunction(upcastSignature, upcast);\r\n }\r\n if (downcast) {\r\n  downcast = embind__requireFunction(downcastSignature, downcast);\r\n }\r\n rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\r\n var legalFunctionName = makeLegalFunctionName(name);\r\n exposePublicSymbol(legalFunctionName, function() {\r\n  throwUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [ baseClassRawType ]);\r\n });\r\n whenDependentTypesAreResolved([ rawType, rawPointerType, rawConstPointerType ], baseClassRawType ? [ baseClassRawType ] : [], function(base) {\r\n  base = base[0];\r\n  var baseClass;\r\n  var basePrototype;\r\n  if (baseClassRawType) {\r\n   baseClass = base.registeredClass;\r\n   basePrototype = baseClass.instancePrototype;\r\n  } else {\r\n   basePrototype = ClassHandle.prototype;\r\n  }\r\n  var constructor = createNamedFunction(legalFunctionName, function() {\r\n   if (Object.getPrototypeOf(this) !== instancePrototype) {\r\n    throw new BindingError(\"Use 'new' to construct \" + name);\r\n   }\r\n   if (undefined === registeredClass.constructor_body) {\r\n    throw new BindingError(name + \" has no accessible constructor\");\r\n   }\r\n   var body = registeredClass.constructor_body[arguments.length];\r\n   if (undefined === body) {\r\n    throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\r\n   }\r\n   return body.apply(this, arguments);\r\n  });\r\n  var instancePrototype = Object.create(basePrototype, {\r\n   constructor: {\r\n    value: constructor\r\n   }\r\n  });\r\n  constructor.prototype = instancePrototype;\r\n  var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\r\n  var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\r\n  var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\r\n  var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\r\n  registeredPointers[rawType] = {\r\n   pointerType: pointerConverter,\r\n   constPointerType: constPointerConverter\r\n  };\r\n  replacePublicSymbol(legalFunctionName, constructor);\r\n  return [ referenceConverter, pointerConverter, constPointerConverter ];\r\n });\r\n}\r\n\r\nfunction heap32VectorToArray(count, firstElement) {\r\n var array = [];\r\n for (var i = 0; i < count; i++) {\r\n  array.push(_asan_js_load_4((firstElement >> 2) + i));\r\n }\r\n return array;\r\n}\r\n\r\nfunction runDestructors(destructors) {\r\n while (destructors.length) {\r\n  var ptr = destructors.pop();\r\n  var del = destructors.pop();\r\n  del(ptr);\r\n }\r\n}\r\n\r\nfunction __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\r\n assert(argCount > 0);\r\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n invoker = embind__requireFunction(invokerSignature, invoker);\r\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\r\n  classType = classType[0];\r\n  var humanName = \"constructor \" + classType.name;\r\n  if (undefined === classType.registeredClass.constructor_body) {\r\n   classType.registeredClass.constructor_body = [];\r\n  }\r\n  if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\r\n   throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\r\n  }\r\n  classType.registeredClass.constructor_body[argCount - 1] = (() => {\r\n   throwUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes);\r\n  });\r\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\r\n   argTypes.splice(1, 0, null);\r\n   classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\r\n   return [];\r\n  });\r\n  return [];\r\n });\r\n}\r\n\r\nfunction new_(constructor, argumentList) {\r\n if (!(constructor instanceof Function)) {\r\n  throw new TypeError(\"new_ called with constructor type \" + typeof constructor + \" which is not a function\");\r\n }\r\n var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {});\r\n dummy.prototype = constructor.prototype;\r\n var obj = new dummy();\r\n var r = constructor.apply(obj, argumentList);\r\n return r instanceof Object ? r : obj;\r\n}\r\n\r\nfunction craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\r\n var argCount = argTypes.length;\r\n if (argCount < 2) {\r\n  throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\r\n }\r\n var isClassMethodFunc = argTypes[1] !== null && classType !== null;\r\n var needsDestructorStack = false;\r\n for (var i = 1; i < argTypes.length; ++i) {\r\n  if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\r\n   needsDestructorStack = true;\r\n   break;\r\n  }\r\n }\r\n var returns = argTypes[0].name !== \"void\";\r\n var argsList = \"\";\r\n var argsListWired = \"\";\r\n for (var i = 0; i < argCount - 2; ++i) {\r\n  argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\r\n  argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\r\n }\r\n var invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\n\" + \"if (arguments.length !== \" + (argCount - 2) + \") {\\n\" + \"throwBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n\" + \"}\\n\";\r\n if (needsDestructorStack) {\r\n  invokerFnBody += \"var destructors = [];\\n\";\r\n }\r\n var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\r\n var args1 = [ \"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\" ];\r\n var args2 = [ throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1] ];\r\n if (isClassMethodFunc) {\r\n  invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\r\n }\r\n for (var i = 0; i < argCount - 2; ++i) {\r\n  invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\r\n  args1.push(\"argType\" + i);\r\n  args2.push(argTypes[i + 2]);\r\n }\r\n if (isClassMethodFunc) {\r\n  argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\r\n }\r\n invokerFnBody += (returns ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\r\n if (needsDestructorStack) {\r\n  invokerFnBody += \"runDestructors(destructors);\\n\";\r\n } else {\r\n  for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\r\n   var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\r\n   if (argTypes[i].destructorFunction !== null) {\r\n    invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\r\n    args1.push(paramName + \"_dtor\");\r\n    args2.push(argTypes[i].destructorFunction);\r\n   }\r\n  }\r\n }\r\n if (returns) {\r\n  invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\r\n } else {}\r\n invokerFnBody += \"}\\n\";\r\n args1.push(invokerFnBody);\r\n var invokerFunction = new_(Function, args1).apply(null, args2);\r\n return invokerFunction;\r\n}\r\n\r\nfunction __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {\r\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n methodName = readLatin1String(methodName);\r\n rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\r\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\r\n  classType = classType[0];\r\n  var humanName = classType.name + \".\" + methodName;\r\n  if (methodName.startsWith(\"@@\")) {\r\n   methodName = Symbol[methodName.substring(2)];\r\n  }\r\n  if (isPureVirtual) {\r\n   classType.registeredClass.pureVirtualFunctions.push(methodName);\r\n  }\r\n  function unboundTypesHandler() {\r\n   throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\r\n  }\r\n  var proto = classType.registeredClass.instancePrototype;\r\n  var method = proto[methodName];\r\n  if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\r\n   unboundTypesHandler.argCount = argCount - 2;\r\n   unboundTypesHandler.className = classType.name;\r\n   proto[methodName] = unboundTypesHandler;\r\n  } else {\r\n   ensureOverloadTable(proto, methodName, humanName);\r\n   proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\r\n  }\r\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\r\n   var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\r\n   if (undefined === proto[methodName].overloadTable) {\r\n    memberFunction.argCount = argCount - 2;\r\n    proto[methodName] = memberFunction;\r\n   } else {\r\n    proto[methodName].overloadTable[argCount - 2] = memberFunction;\r\n   }\r\n   return [];\r\n  });\r\n  return [];\r\n });\r\n}\r\n\r\nvar emval_free_list = [];\r\n\r\nvar emval_handle_array = [ {}, {\r\n value: undefined\r\n}, {\r\n value: null\r\n}, {\r\n value: true\r\n}, {\r\n value: false\r\n} ];\r\n\r\nfunction __emval_decref(handle) {\r\n if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\r\n  emval_handle_array[handle] = undefined;\r\n  emval_free_list.push(handle);\r\n }\r\n}\r\n\r\nfunction count_emval_handles() {\r\n var count = 0;\r\n for (var i = 5; i < emval_handle_array.length; ++i) {\r\n  if (emval_handle_array[i] !== undefined) {\r\n   ++count;\r\n  }\r\n }\r\n return count;\r\n}\r\n\r\nfunction get_first_emval() {\r\n for (var i = 5; i < emval_handle_array.length; ++i) {\r\n  if (emval_handle_array[i] !== undefined) {\r\n   return emval_handle_array[i];\r\n  }\r\n }\r\n return null;\r\n}\r\n\r\nfunction init_emval() {\r\n Module[\"count_emval_handles\"] = count_emval_handles;\r\n Module[\"get_first_emval\"] = get_first_emval;\r\n}\r\n\r\nvar Emval = {\r\n toValue: function(handle) {\r\n  if (!handle) {\r\n   throwBindingError(\"Cannot use deleted val. handle = \" + handle);\r\n  }\r\n  return emval_handle_array[handle].value;\r\n },\r\n toHandle: function(value) {\r\n  switch (value) {\r\n  case undefined:\r\n   {\r\n    return 1;\r\n   }\r\n\r\n  case null:\r\n   {\r\n    return 2;\r\n   }\r\n\r\n  case true:\r\n   {\r\n    return 3;\r\n   }\r\n\r\n  case false:\r\n   {\r\n    return 4;\r\n   }\r\n\r\n  default:\r\n   {\r\n    var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\r\n    emval_handle_array[handle] = {\r\n     refcount: 1,\r\n     value: value\r\n    };\r\n    return handle;\r\n   }\r\n  }\r\n }\r\n};\r\n\r\nfunction __embind_register_emval(rawType, name) {\r\n name = readLatin1String(name);\r\n registerType(rawType, {\r\n  name: name,\r\n  \"fromWireType\": function(handle) {\r\n   var rv = Emval.toValue(handle);\r\n   __emval_decref(handle);\r\n   return rv;\r\n  },\r\n  \"toWireType\": function(destructors, value) {\r\n   return Emval.toHandle(value);\r\n  },\r\n  \"argPackAdvance\": 8,\r\n  \"readValueFromPointer\": simpleReadValueFromPointer,\r\n  destructorFunction: null\r\n });\r\n}\r\n\r\nfunction _embind_repr(v) {\r\n if (v === null) {\r\n  return \"null\";\r\n }\r\n var t = typeof v;\r\n if (t === \"object\" || t === \"array\" || t === \"function\") {\r\n  return v.toString();\r\n } else {\r\n  return \"\" + v;\r\n }\r\n}\r\n\r\nfunction floatReadValueFromPointer(name, shift) {\r\n switch (shift) {\r\n case 2:\r\n  return function(pointer) {\r\n   return this[\"fromWireType\"](_asan_js_load_f(pointer >> 2));\r\n  };\r\n\r\n case 3:\r\n  return function(pointer) {\r\n   return this[\"fromWireType\"](_asan_js_load_d(pointer >> 3));\r\n  };\r\n\r\n default:\r\n  throw new TypeError(\"Unknown float type: \" + name);\r\n }\r\n}\r\n\r\nfunction __embind_register_float(rawType, name, size) {\r\n var shift = getShiftFromSize(size);\r\n name = readLatin1String(name);\r\n registerType(rawType, {\r\n  name: name,\r\n  \"fromWireType\": function(value) {\r\n   return value;\r\n  },\r\n  \"toWireType\": function(destructors, value) {\r\n   if (typeof value !== \"number\" && typeof value !== \"boolean\") {\r\n    throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\r\n   }\r\n   return value;\r\n  },\r\n  \"argPackAdvance\": 8,\r\n  \"readValueFromPointer\": floatReadValueFromPointer(name, shift),\r\n  destructorFunction: null\r\n });\r\n}\r\n\r\nfunction __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\r\n var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n name = readLatin1String(name);\r\n rawInvoker = embind__requireFunction(signature, rawInvoker);\r\n exposePublicSymbol(name, function() {\r\n  throwUnboundTypeError(\"Cannot call \" + name + \" due to unbound types\", argTypes);\r\n }, argCount - 1);\r\n whenDependentTypesAreResolved([], argTypes, function(argTypes) {\r\n  var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));\r\n  replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);\r\n  return [];\r\n });\r\n}\r\n\r\nfunction integerReadValueFromPointer(name, shift, signed) {\r\n switch (shift) {\r\n case 0:\r\n  return signed ? function readS8FromPointer(pointer) {\r\n   return _asan_js_load_1(pointer);\r\n  } : function readU8FromPointer(pointer) {\r\n   return _asan_js_load_1u(pointer);\r\n  };\r\n\r\n case 1:\r\n  return signed ? function readS16FromPointer(pointer) {\r\n   return _asan_js_load_2(pointer >> 1);\r\n  } : function readU16FromPointer(pointer) {\r\n   return _asan_js_load_2u(pointer >> 1);\r\n  };\r\n\r\n case 2:\r\n  return signed ? function readS32FromPointer(pointer) {\r\n   return _asan_js_load_4(pointer >> 2);\r\n  } : function readU32FromPointer(pointer) {\r\n   return _asan_js_load_4u(pointer >> 2);\r\n  };\r\n\r\n default:\r\n  throw new TypeError(\"Unknown integer type: \" + name);\r\n }\r\n}\r\n\r\nfunction __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\r\n name = readLatin1String(name);\r\n if (maxRange === -1) {\r\n  maxRange = 4294967295;\r\n }\r\n var shift = getShiftFromSize(size);\r\n var fromWireType = value => value;\r\n if (minRange === 0) {\r\n  var bitshift = 32 - 8 * size;\r\n  fromWireType = (value => value << bitshift >>> bitshift);\r\n }\r\n var isUnsignedType = name.includes(\"unsigned\");\r\n var checkAssertions = (value, toTypeName) => {\r\n  if (typeof value !== \"number\" && typeof value !== \"boolean\") {\r\n   throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + toTypeName);\r\n  }\r\n  if (value < minRange || value > maxRange) {\r\n   throw new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + \", \" + maxRange + \"]!\");\r\n  }\r\n };\r\n var toWireType;\r\n if (isUnsignedType) {\r\n  toWireType = function(destructors, value) {\r\n   checkAssertions(value, this.name);\r\n   return value >>> 0;\r\n  };\r\n } else {\r\n  toWireType = function(destructors, value) {\r\n   checkAssertions(value, this.name);\r\n   return value;\r\n  };\r\n }\r\n registerType(primitiveType, {\r\n  name: name,\r\n  \"fromWireType\": fromWireType,\r\n  \"toWireType\": toWireType,\r\n  \"argPackAdvance\": 8,\r\n  \"readValueFromPointer\": integerReadValueFromPointer(name, shift, minRange !== 0),\r\n  destructorFunction: null\r\n });\r\n}\r\n\r\nfunction __embind_register_memory_view(rawType, dataTypeIndex, name) {\r\n var typeMapping = [ Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];\r\n var TA = typeMapping[dataTypeIndex];\r\n function decodeMemoryView(handle) {\r\n  handle = handle >> 2;\r\n  var heap = HEAPU32;\r\n  var size = heap[handle];\r\n  var data = heap[handle + 1];\r\n  return new TA(buffer, data, size);\r\n }\r\n name = readLatin1String(name);\r\n registerType(rawType, {\r\n  name: name,\r\n  \"fromWireType\": decodeMemoryView,\r\n  \"argPackAdvance\": 8,\r\n  \"readValueFromPointer\": decodeMemoryView\r\n }, {\r\n  ignoreDuplicateRegistrations: true\r\n });\r\n}\r\n\r\nfunction __embind_register_std_string(rawType, name) {\r\n name = readLatin1String(name);\r\n var stdStringIsUTF8 = name === \"std::string\";\r\n registerType(rawType, {\r\n  name: name,\r\n  \"fromWireType\": function(value) {\r\n   var length = _asan_js_load_4u(value >> 2);\r\n   var str;\r\n   if (stdStringIsUTF8) {\r\n    var decodeStartPtr = value + 4;\r\n    for (var i = 0; i <= length; ++i) {\r\n     var currentBytePtr = value + 4 + i;\r\n     if (i == length || _asan_js_load_1u(currentBytePtr) == 0) {\r\n      var maxRead = currentBytePtr - decodeStartPtr;\r\n      var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\r\n      if (str === undefined) {\r\n       str = stringSegment;\r\n      } else {\r\n       str += String.fromCharCode(0);\r\n       str += stringSegment;\r\n      }\r\n      decodeStartPtr = currentBytePtr + 1;\r\n     }\r\n    }\r\n   } else {\r\n    var a = new Array(length);\r\n    for (var i = 0; i < length; ++i) {\r\n     a[i] = String.fromCharCode(_asan_js_load_1u(value + 4 + i));\r\n    }\r\n    str = a.join(\"\");\r\n   }\r\n   _free(value);\r\n   return str;\r\n  },\r\n  \"toWireType\": function(destructors, value) {\r\n   if (value instanceof ArrayBuffer) {\r\n    value = new Uint8Array(value);\r\n   }\r\n   var getLength;\r\n   var valueIsOfTypeString = typeof value === \"string\";\r\n   if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\r\n    throwBindingError(\"Cannot pass non-string to std::string\");\r\n   }\r\n   if (stdStringIsUTF8 && valueIsOfTypeString) {\r\n    getLength = (() => lengthBytesUTF8(value));\r\n   } else {\r\n    getLength = (() => value.length);\r\n   }\r\n   var length = getLength();\r\n   var ptr = _malloc(4 + length + 1);\r\n   _asan_js_store_4u(ptr >> 2, length);\r\n   if (stdStringIsUTF8 && valueIsOfTypeString) {\r\n    stringToUTF8(value, ptr + 4, length + 1);\r\n   } else {\r\n    if (valueIsOfTypeString) {\r\n     for (var i = 0; i < length; ++i) {\r\n      var charCode = value.charCodeAt(i);\r\n      if (charCode > 255) {\r\n       _free(ptr);\r\n       throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\r\n      }\r\n      _asan_js_store_1u(ptr + 4 + i, charCode);\r\n     }\r\n    } else {\r\n     for (var i = 0; i < length; ++i) {\r\n      _asan_js_store_1u(ptr + 4 + i, value[i]);\r\n     }\r\n    }\r\n   }\r\n   if (destructors !== null) {\r\n    destructors.push(_free, ptr);\r\n   }\r\n   return ptr;\r\n  },\r\n  \"argPackAdvance\": 8,\r\n  \"readValueFromPointer\": simpleReadValueFromPointer,\r\n  destructorFunction: function(ptr) {\r\n   _free(ptr);\r\n  }\r\n });\r\n}\r\n\r\nfunction __embind_register_std_wstring(rawType, charSize, name) {\r\n name = readLatin1String(name);\r\n var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\r\n if (charSize === 2) {\r\n  decodeString = UTF16ToString;\r\n  encodeString = stringToUTF16;\r\n  lengthBytesUTF = lengthBytesUTF16;\r\n  getHeap = (() => HEAPU16);\r\n  shift = 1;\r\n } else if (charSize === 4) {\r\n  decodeString = UTF32ToString;\r\n  encodeString = stringToUTF32;\r\n  lengthBytesUTF = lengthBytesUTF32;\r\n  getHeap = (() => HEAPU32);\r\n  shift = 2;\r\n }\r\n registerType(rawType, {\r\n  name: name,\r\n  \"fromWireType\": function(value) {\r\n   var length = _asan_js_load_4u(value >> 2);\r\n   var HEAP = getHeap();\r\n   var str;\r\n   var decodeStartPtr = value + 4;\r\n   for (var i = 0; i <= length; ++i) {\r\n    var currentBytePtr = value + 4 + i * charSize;\r\n    if (i == length || HEAP[currentBytePtr >> shift] == 0) {\r\n     var maxReadBytes = currentBytePtr - decodeStartPtr;\r\n     var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\r\n     if (str === undefined) {\r\n      str = stringSegment;\r\n     } else {\r\n      str += String.fromCharCode(0);\r\n      str += stringSegment;\r\n     }\r\n     decodeStartPtr = currentBytePtr + charSize;\r\n    }\r\n   }\r\n   _free(value);\r\n   return str;\r\n  },\r\n  \"toWireType\": function(destructors, value) {\r\n   if (!(typeof value === \"string\")) {\r\n    throwBindingError(\"Cannot pass non-string to C++ string type \" + name);\r\n   }\r\n   var length = lengthBytesUTF(value);\r\n   var ptr = _malloc(4 + length + charSize);\r\n   _asan_js_store_4u(ptr >> 2, length >> shift);\r\n   encodeString(value, ptr + 4, length + charSize);\r\n   if (destructors !== null) {\r\n    destructors.push(_free, ptr);\r\n   }\r\n   return ptr;\r\n  },\r\n  \"argPackAdvance\": 8,\r\n  \"readValueFromPointer\": simpleReadValueFromPointer,\r\n  destructorFunction: function(ptr) {\r\n   _free(ptr);\r\n  }\r\n });\r\n}\r\n\r\nfunction __embind_register_void(rawType, name) {\r\n name = readLatin1String(name);\r\n registerType(rawType, {\r\n  isVoid: true,\r\n  name: name,\r\n  \"argPackAdvance\": 0,\r\n  \"fromWireType\": function() {\r\n   return undefined;\r\n  },\r\n  \"toWireType\": function(destructors, o) {\r\n   return undefined;\r\n  }\r\n });\r\n}\r\n\r\nfunction __emval_incref(handle) {\r\n if (handle > 4) {\r\n  emval_handle_array[handle].refcount += 1;\r\n }\r\n}\r\n\r\nfunction requireRegisteredType(rawType, humanName) {\r\n var impl = registeredTypes[rawType];\r\n if (undefined === impl) {\r\n  throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\r\n }\r\n return impl;\r\n}\r\n\r\nfunction __emval_take_value(type, argv) {\r\n type = requireRegisteredType(type, \"_emval_take_value\");\r\n var v = type[\"readValueFromPointer\"](argv);\r\n return Emval.toHandle(v);\r\n}\r\n\r\nfunction _abort() {\r\n abort(\"native code called abort()\");\r\n}\r\n\r\nvar readAsmConstArgsArray = [];\r\n\r\nfunction readAsmConstArgs(sigPtr, buf) {\r\n assert(Array.isArray(readAsmConstArgsArray));\r\n assert(buf % 16 == 0);\r\n readAsmConstArgsArray.length = 0;\r\n var ch;\r\n buf >>= 2;\r\n while (ch = _asan_js_load_1u(sigPtr++)) {\r\n  assert(ch === 100 || ch === 102 || ch === 105);\r\n  var readAsmConstArgsDouble = ch < 105;\r\n  if (readAsmConstArgsDouble && buf & 1) buf++;\r\n  readAsmConstArgsArray.push(readAsmConstArgsDouble ? _asan_js_load_d(buf++ >> 1) : _asan_js_load_4(buf));\r\n  ++buf;\r\n }\r\n return readAsmConstArgsArray;\r\n}\r\n\r\nfunction _emscripten_asm_const_int(code, sigPtr, argbuf) {\r\n var args = readAsmConstArgs(sigPtr, argbuf);\r\n if (!ASM_CONSTS.hasOwnProperty(code)) abort(\"No EM_ASM constant found at address \" + code);\r\n return ASM_CONSTS[code].apply(null, args);\r\n}\r\n\r\nfunction _emscripten_asm_const_double(a0, a1, a2) {\r\n return _emscripten_asm_const_int(a0, a1, a2);\r\n}\r\n\r\nfunction syscallMmap2(addr, len, prot, flags, fd, off) {\r\n off <<= 12;\r\n var ptr;\r\n var allocated = false;\r\n if ((flags & 16) !== 0 && addr % 65536 !== 0) {\r\n  return -28;\r\n }\r\n if ((flags & 32) !== 0) {\r\n  ptr = mmapAlloc(len);\r\n  if (!ptr) return -48;\r\n  allocated = true;\r\n } else {\r\n  var info = FS.getStream(fd);\r\n  if (!info) return -8;\r\n  var res = FS.mmap(info, addr, len, off, prot, flags);\r\n  ptr = res.ptr;\r\n  allocated = res.allocated;\r\n }\r\n SYSCALLS.mappings[ptr] = {\r\n  malloc: ptr,\r\n  len: len,\r\n  allocated: allocated,\r\n  fd: fd,\r\n  prot: prot,\r\n  flags: flags,\r\n  offset: off\r\n };\r\n return ptr;\r\n}\r\n\r\nfunction withBuiltinMalloc(func) {\r\n var prev_malloc = typeof _malloc !== \"undefined\" ? _malloc : undefined;\r\n var prev_memalign = typeof _memalign !== \"undefined\" ? _memalign : undefined;\r\n var prev_free = typeof _free !== \"undefined\" ? _free : undefined;\r\n _malloc = _emscripten_builtin_malloc;\r\n _memalign = _emscripten_builtin_memalign;\r\n _free = _emscripten_builtin_free;\r\n try {\r\n  return func();\r\n } finally {\r\n  _malloc = prev_malloc;\r\n  _memalign = prev_memalign;\r\n  _free = prev_free;\r\n }\r\n}\r\n\r\nfunction _emscripten_builtin_mmap2(addr, len, prot, flags, fd, off) {\r\n return withBuiltinMalloc(function() {\r\n  return syscallMmap2(addr, len, prot, flags, fd, off);\r\n });\r\n}\r\n\r\nfunction syscallMunmap(addr, len) {\r\n var info = SYSCALLS.mappings[addr];\r\n if (len === 0 || !info) {\r\n  return -28;\r\n }\r\n if (len === info.len) {\r\n  var stream = FS.getStream(info.fd);\r\n  if (stream) {\r\n   if (info.prot & 2) {\r\n    SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);\r\n   }\r\n   FS.munmap(stream);\r\n  }\r\n  SYSCALLS.mappings[addr] = null;\r\n  if (info.allocated) {\r\n   _free(info.malloc);\r\n  }\r\n }\r\n return 0;\r\n}\r\n\r\nfunction _emscripten_builtin_munmap(addr, len) {\r\n return withBuiltinMalloc(function() {\r\n  return syscallMunmap(addr, len);\r\n });\r\n}\r\n\r\nfunction _emscripten_console_error(str) {\r\n assert(typeof str === \"number\");\r\n console.error(UTF8ToString(str));\r\n}\r\n\r\nfunction _emscripten_get_heap_max() {\r\n return HEAPU8.length;\r\n}\r\n\r\nfunction _emscripten_get_module_name(buf, length) {\r\n return stringToUTF8(wasmBinaryFile, buf, length);\r\n}\r\n\r\nvar _emscripten_get_now;\r\n\r\n_emscripten_get_now = (() => performance.now());\r\n\r\nvar UNWIND_CACHE = {};\r\n\r\nfunction convertFrameToPC(frame) {\r\n assert(wasmOffsetConverter);\r\n var match;\r\n if (match = /\\bwasm-function\\[\\d+\\]:(0x[0-9a-f]+)/.exec(frame)) {\r\n  return +match[1];\r\n } else if (match = /\\bwasm-function\\[(\\d+)\\]:(\\d+)/.exec(frame)) {\r\n  return wasmOffsetConverter.convert(+match[1], +match[2]);\r\n } else if (match = /:(\\d+):\\d+(?:\\)|$)/.exec(frame)) {\r\n  return 2147483648 | +match[1];\r\n }\r\n return 0;\r\n}\r\n\r\nfunction convertPCtoSourceLocation(pc) {\r\n if (UNWIND_CACHE.last_get_source_pc == pc) return UNWIND_CACHE.last_source;\r\n var match;\r\n var source;\r\n if (!source) {\r\n  var frame = UNWIND_CACHE[pc];\r\n  if (!frame) return null;\r\n  if (match = /\\((.*):(\\d+):(\\d+)\\)$/.exec(frame)) {\r\n   source = {\r\n    file: match[1],\r\n    line: match[2],\r\n    column: match[3]\r\n   };\r\n  } else if (match = /@(.*):(\\d+):(\\d+)/.exec(frame)) {\r\n   source = {\r\n    file: match[1],\r\n    line: match[2],\r\n    column: match[3]\r\n   };\r\n  }\r\n }\r\n UNWIND_CACHE.last_get_source_pc = pc;\r\n UNWIND_CACHE.last_source = source;\r\n return source;\r\n}\r\n\r\nfunction _emscripten_pc_get_column(pc) {\r\n var result = convertPCtoSourceLocation(pc);\r\n return result ? result.column || 0 : 0;\r\n}\r\n\r\nfunction _emscripten_pc_get_file(pc) {\r\n return withBuiltinMalloc(function() {\r\n  var result = convertPCtoSourceLocation(pc);\r\n  if (!result) return 0;\r\n  if (_emscripten_pc_get_file.ret) _free(_emscripten_pc_get_file.ret);\r\n  _emscripten_pc_get_file.ret = allocateUTF8(result.file);\r\n  return _emscripten_pc_get_file.ret;\r\n });\r\n}\r\n\r\nfunction _emscripten_pc_get_function(pc) {\r\n return withBuiltinMalloc(function() {\r\n  var name;\r\n  if (pc & 2147483648) {\r\n   var frame = UNWIND_CACHE[pc];\r\n   if (!frame) return 0;\r\n   var match;\r\n   if (match = /^\\s+at (.*) \\(.*\\)$/.exec(frame)) {\r\n    name = match[1];\r\n   } else if (match = /^(.+?)@/.exec(frame)) {\r\n    name = match[1];\r\n   } else {\r\n    return 0;\r\n   }\r\n  } else {\r\n   name = wasmOffsetConverter.getName(pc);\r\n  }\r\n  if (_emscripten_pc_get_function.ret) _free(_emscripten_pc_get_function.ret);\r\n  _emscripten_pc_get_function.ret = allocateUTF8(name);\r\n  return _emscripten_pc_get_function.ret;\r\n });\r\n}\r\n\r\nfunction _emscripten_pc_get_line(pc) {\r\n var result = convertPCtoSourceLocation(pc);\r\n return result ? result.line : 0;\r\n}\r\n\r\nfunction abortOnCannotGrowMemory(requestedSize) {\r\n abort(\"Cannot enlarge memory arrays to size \" + requestedSize + \" bytes (OOM). Either (1) compile with  -s INITIAL_MEMORY=X  with X higher than the current value \" + HEAP8.length + \", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 \");\r\n}\r\n\r\nfunction _emscripten_resize_heap(requestedSize) {\r\n var oldSize = HEAPU8.length;\r\n requestedSize = requestedSize >>> 0;\r\n abortOnCannotGrowMemory(requestedSize);\r\n}\r\n\r\nfunction _emscripten_return_address(level) {\r\n var callstack = new Error().stack.split(\"\\n\");\r\n if (callstack[0] == \"Error\") {\r\n  callstack.shift();\r\n }\r\n return convertFrameToPC(callstack[level + 2]);\r\n}\r\n\r\nfunction saveInUnwindCache(callstack) {\r\n callstack.forEach(function(frame) {\r\n  var pc = convertFrameToPC(frame);\r\n  if (pc) {\r\n   UNWIND_CACHE[pc] = frame;\r\n  }\r\n });\r\n}\r\n\r\nfunction _emscripten_stack_snapshot() {\r\n var callstack = new Error().stack.split(\"\\n\");\r\n if (callstack[0] == \"Error\") {\r\n  callstack.shift();\r\n }\r\n saveInUnwindCache(callstack);\r\n UNWIND_CACHE.last_addr = convertFrameToPC(callstack[2]);\r\n UNWIND_CACHE.last_stack = callstack;\r\n return UNWIND_CACHE.last_addr;\r\n}\r\n\r\nfunction _emscripten_stack_unwind_buffer(addr, buffer, count) {\r\n var stack;\r\n if (UNWIND_CACHE.last_addr == addr) {\r\n  stack = UNWIND_CACHE.last_stack;\r\n } else {\r\n  stack = new Error().stack.split(\"\\n\");\r\n  if (stack[0] == \"Error\") {\r\n   stack.shift();\r\n  }\r\n  saveInUnwindCache(stack);\r\n }\r\n var offset = 2;\r\n while (stack[offset] && convertFrameToPC(stack[offset]) != addr) {\r\n  ++offset;\r\n }\r\n for (var i = 0; i < count && stack[i + offset]; ++i) {\r\n  _asan_js_store_4(buffer + i * 4 >> 2, convertFrameToPC(stack[i + offset]));\r\n }\r\n return i;\r\n}\r\n\r\nvar ENV = {};\r\n\r\nfunction getExecutableName() {\r\n return thisProgram || \"./this.program\";\r\n}\r\n\r\nfunction getEnvStrings() {\r\n if (!getEnvStrings.strings) {\r\n  var lang = (typeof navigator === \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\r\n  var env = {\r\n   \"USER\": \"web_user\",\r\n   \"LOGNAME\": \"web_user\",\r\n   \"PATH\": \"/\",\r\n   \"PWD\": \"/\",\r\n   \"HOME\": \"/home/web_user\",\r\n   \"LANG\": lang,\r\n   \"_\": getExecutableName()\r\n  };\r\n  for (var x in ENV) {\r\n   if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x];\r\n  }\r\n  var strings = [];\r\n  for (var x in env) {\r\n   strings.push(x + \"=\" + env[x]);\r\n  }\r\n  getEnvStrings.strings = strings;\r\n }\r\n return getEnvStrings.strings;\r\n}\r\n\r\nfunction _environ_get(__environ, environ_buf) {\r\n var bufSize = 0;\r\n getEnvStrings().forEach(function(string, i) {\r\n  var ptr = environ_buf + bufSize;\r\n  _asan_js_store_4(__environ + i * 4 >> 2, ptr);\r\n  writeAsciiToMemory(string, ptr);\r\n  bufSize += string.length + 1;\r\n });\r\n return 0;\r\n}\r\n\r\nfunction _environ_sizes_get(penviron_count, penviron_buf_size) {\r\n var strings = getEnvStrings();\r\n _asan_js_store_4(penviron_count >> 2, strings.length);\r\n var bufSize = 0;\r\n strings.forEach(function(string) {\r\n  bufSize += string.length + 1;\r\n });\r\n _asan_js_store_4(penviron_buf_size >> 2, bufSize);\r\n return 0;\r\n}\r\n\r\nfunction _fd_close(fd) {\r\n try {\r\n  var stream = SYSCALLS.getStreamFromFD(fd);\r\n  FS.close(stream);\r\n  return 0;\r\n } catch (e) {\r\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\r\n  return e.errno;\r\n }\r\n}\r\n\r\nfunction _fd_read(fd, iov, iovcnt, pnum) {\r\n try {\r\n  var stream = SYSCALLS.getStreamFromFD(fd);\r\n  var num = SYSCALLS.doReadv(stream, iov, iovcnt);\r\n  _asan_js_store_4(pnum >> 2, num);\r\n  return 0;\r\n } catch (e) {\r\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\r\n  return e.errno;\r\n }\r\n}\r\n\r\nfunction _fd_write(fd, iov, iovcnt, pnum) {\r\n try {\r\n  var stream = SYSCALLS.getStreamFromFD(fd);\r\n  var num = SYSCALLS.doWritev(stream, iov, iovcnt);\r\n  _asan_js_store_4(pnum >> 2, num);\r\n  return 0;\r\n } catch (e) {\r\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\r\n  return e.errno;\r\n }\r\n}\r\n\r\nfunction _proc_exit(code) {\r\n procExit(code);\r\n}\r\n\r\nfunction _setTempRet0(val) {\r\n setTempRet0(val);\r\n}\r\n\r\nvar FSNode = function(parent, name, mode, rdev) {\r\n if (!parent) {\r\n  parent = this;\r\n }\r\n this.parent = parent;\r\n this.mount = parent.mount;\r\n this.mounted = null;\r\n this.id = FS.nextInode++;\r\n this.name = name;\r\n this.mode = mode;\r\n this.node_ops = {};\r\n this.stream_ops = {};\r\n this.rdev = rdev;\r\n};\r\n\r\nvar readMode = 292 | 73;\r\n\r\nvar writeMode = 146;\r\n\r\nObject.defineProperties(FSNode.prototype, {\r\n read: {\r\n  get: function() {\r\n   return (this.mode & readMode) === readMode;\r\n  },\r\n  set: function(val) {\r\n   val ? this.mode |= readMode : this.mode &= ~readMode;\r\n  }\r\n },\r\n write: {\r\n  get: function() {\r\n   return (this.mode & writeMode) === writeMode;\r\n  },\r\n  set: function(val) {\r\n   val ? this.mode |= writeMode : this.mode &= ~writeMode;\r\n  }\r\n },\r\n isFolder: {\r\n  get: function() {\r\n   return FS.isDir(this.mode);\r\n  }\r\n },\r\n isDevice: {\r\n  get: function() {\r\n   return FS.isChrdev(this.mode);\r\n  }\r\n }\r\n});\r\n\r\nFS.FSNode = FSNode;\r\n\r\nFS.staticInit();\r\n\r\nERRNO_CODES = {\r\n \"EPERM\": 63,\r\n \"ENOENT\": 44,\r\n \"ESRCH\": 71,\r\n \"EINTR\": 27,\r\n \"EIO\": 29,\r\n \"ENXIO\": 60,\r\n \"E2BIG\": 1,\r\n \"ENOEXEC\": 45,\r\n \"EBADF\": 8,\r\n \"ECHILD\": 12,\r\n \"EAGAIN\": 6,\r\n \"EWOULDBLOCK\": 6,\r\n \"ENOMEM\": 48,\r\n \"EACCES\": 2,\r\n \"EFAULT\": 21,\r\n \"ENOTBLK\": 105,\r\n \"EBUSY\": 10,\r\n \"EEXIST\": 20,\r\n \"EXDEV\": 75,\r\n \"ENODEV\": 43,\r\n \"ENOTDIR\": 54,\r\n \"EISDIR\": 31,\r\n \"EINVAL\": 28,\r\n \"ENFILE\": 41,\r\n \"EMFILE\": 33,\r\n \"ENOTTY\": 59,\r\n \"ETXTBSY\": 74,\r\n \"EFBIG\": 22,\r\n \"ENOSPC\": 51,\r\n \"ESPIPE\": 70,\r\n \"EROFS\": 69,\r\n \"EMLINK\": 34,\r\n \"EPIPE\": 64,\r\n \"EDOM\": 18,\r\n \"ERANGE\": 68,\r\n \"ENOMSG\": 49,\r\n \"EIDRM\": 24,\r\n \"ECHRNG\": 106,\r\n \"EL2NSYNC\": 156,\r\n \"EL3HLT\": 107,\r\n \"EL3RST\": 108,\r\n \"ELNRNG\": 109,\r\n \"EUNATCH\": 110,\r\n \"ENOCSI\": 111,\r\n \"EL2HLT\": 112,\r\n \"EDEADLK\": 16,\r\n \"ENOLCK\": 46,\r\n \"EBADE\": 113,\r\n \"EBADR\": 114,\r\n \"EXFULL\": 115,\r\n \"ENOANO\": 104,\r\n \"EBADRQC\": 103,\r\n \"EBADSLT\": 102,\r\n \"EDEADLOCK\": 16,\r\n \"EBFONT\": 101,\r\n \"ENOSTR\": 100,\r\n \"ENODATA\": 116,\r\n \"ETIME\": 117,\r\n \"ENOSR\": 118,\r\n \"ENONET\": 119,\r\n \"ENOPKG\": 120,\r\n \"EREMOTE\": 121,\r\n \"ENOLINK\": 47,\r\n \"EADV\": 122,\r\n \"ESRMNT\": 123,\r\n \"ECOMM\": 124,\r\n \"EPROTO\": 65,\r\n \"EMULTIHOP\": 36,\r\n \"EDOTDOT\": 125,\r\n \"EBADMSG\": 9,\r\n \"ENOTUNIQ\": 126,\r\n \"EBADFD\": 127,\r\n \"EREMCHG\": 128,\r\n \"ELIBACC\": 129,\r\n \"ELIBBAD\": 130,\r\n \"ELIBSCN\": 131,\r\n \"ELIBMAX\": 132,\r\n \"ELIBEXEC\": 133,\r\n \"ENOSYS\": 52,\r\n \"ENOTEMPTY\": 55,\r\n \"ENAMETOOLONG\": 37,\r\n \"ELOOP\": 32,\r\n \"EOPNOTSUPP\": 138,\r\n \"EPFNOSUPPORT\": 139,\r\n \"ECONNRESET\": 15,\r\n \"ENOBUFS\": 42,\r\n \"EAFNOSUPPORT\": 5,\r\n \"EPROTOTYPE\": 67,\r\n \"ENOTSOCK\": 57,\r\n \"ENOPROTOOPT\": 50,\r\n \"ESHUTDOWN\": 140,\r\n \"ECONNREFUSED\": 14,\r\n \"EADDRINUSE\": 3,\r\n \"ECONNABORTED\": 13,\r\n \"ENETUNREACH\": 40,\r\n \"ENETDOWN\": 38,\r\n \"ETIMEDOUT\": 73,\r\n \"EHOSTDOWN\": 142,\r\n \"EHOSTUNREACH\": 23,\r\n \"EINPROGRESS\": 26,\r\n \"EALREADY\": 7,\r\n \"EDESTADDRREQ\": 17,\r\n \"EMSGSIZE\": 35,\r\n \"EPROTONOSUPPORT\": 66,\r\n \"ESOCKTNOSUPPORT\": 137,\r\n \"EADDRNOTAVAIL\": 4,\r\n \"ENETRESET\": 39,\r\n \"EISCONN\": 30,\r\n \"ENOTCONN\": 53,\r\n \"ETOOMANYREFS\": 141,\r\n \"EUSERS\": 136,\r\n \"EDQUOT\": 19,\r\n \"ESTALE\": 72,\r\n \"ENOTSUP\": 138,\r\n \"ENOMEDIUM\": 148,\r\n \"EILSEQ\": 25,\r\n \"EOVERFLOW\": 61,\r\n \"ECANCELED\": 11,\r\n \"ENOTRECOVERABLE\": 56,\r\n \"EOWNERDEAD\": 62,\r\n \"ESTRPIPE\": 135\r\n};\r\n\r\nembind_init_charCodes();\r\n\r\nBindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\r\n\r\nInternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\r\n\r\ninit_ClassHandle();\r\n\r\ninit_embind();\r\n\r\ninit_RegisteredPointer();\r\n\r\nUnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\r\n\r\ninit_emval();\r\n\r\nvar ASSERTIONS = true;\r\n\r\nfunction intArrayFromString(stringy, dontAddNull, length) {\r\n var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\r\n var u8array = new Array(len);\r\n var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\r\n if (dontAddNull) u8array.length = numBytesWritten;\r\n return u8array;\r\n}\r\n\r\nvar asmLibraryArg = {\r\n \"__assert_fail\": ___assert_fail,\r\n \"__syscall_dup\": ___syscall_dup,\r\n \"__syscall_open\": ___syscall_open,\r\n \"__syscall_stat64\": ___syscall_stat64,\r\n \"_embind_register_bigint\": __embind_register_bigint,\r\n \"_embind_register_bool\": __embind_register_bool,\r\n \"_embind_register_class\": __embind_register_class,\r\n \"_embind_register_class_constructor\": __embind_register_class_constructor,\r\n \"_embind_register_class_function\": __embind_register_class_function,\r\n \"_embind_register_emval\": __embind_register_emval,\r\n \"_embind_register_float\": __embind_register_float,\r\n \"_embind_register_function\": __embind_register_function,\r\n \"_embind_register_integer\": __embind_register_integer,\r\n \"_embind_register_memory_view\": __embind_register_memory_view,\r\n \"_embind_register_std_string\": __embind_register_std_string,\r\n \"_embind_register_std_wstring\": __embind_register_std_wstring,\r\n \"_embind_register_void\": __embind_register_void,\r\n \"_emval_decref\": __emval_decref,\r\n \"_emval_incref\": __emval_incref,\r\n \"_emval_take_value\": __emval_take_value,\r\n \"abort\": _abort,\r\n \"emscripten_asm_const_double\": _emscripten_asm_const_double,\r\n \"emscripten_asm_const_int\": _emscripten_asm_const_int,\r\n \"emscripten_builtin_mmap2\": _emscripten_builtin_mmap2,\r\n \"emscripten_builtin_munmap\": _emscripten_builtin_munmap,\r\n \"emscripten_console_error\": _emscripten_console_error,\r\n \"emscripten_get_heap_max\": _emscripten_get_heap_max,\r\n \"emscripten_get_module_name\": _emscripten_get_module_name,\r\n \"emscripten_get_now\": _emscripten_get_now,\r\n \"emscripten_pc_get_column\": _emscripten_pc_get_column,\r\n \"emscripten_pc_get_file\": _emscripten_pc_get_file,\r\n \"emscripten_pc_get_function\": _emscripten_pc_get_function,\r\n \"emscripten_pc_get_line\": _emscripten_pc_get_line,\r\n \"emscripten_resize_heap\": _emscripten_resize_heap,\r\n \"emscripten_return_address\": _emscripten_return_address,\r\n \"emscripten_stack_snapshot\": _emscripten_stack_snapshot,\r\n \"emscripten_stack_unwind_buffer\": _emscripten_stack_unwind_buffer,\r\n \"environ_get\": _environ_get,\r\n \"environ_sizes_get\": _environ_sizes_get,\r\n \"fd_close\": _fd_close,\r\n \"fd_read\": _fd_read,\r\n \"fd_write\": _fd_write,\r\n \"proc_exit\": _proc_exit,\r\n \"setTempRet0\": _setTempRet0\r\n};\r\n\r\nvar asm = createWasm();\r\n\r\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = createExportWrapper(\"__wasm_call_ctors\");\r\n\r\nvar ___getTypeName = Module[\"___getTypeName\"] = createExportWrapper(\"__getTypeName\");\r\n\r\nvar ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = createExportWrapper(\"__embind_register_native_and_builtin_types\");\r\n\r\nvar ___errno_location = Module[\"___errno_location\"] = createExportWrapper(\"__errno_location\");\r\n\r\nvar ___stdio_exit = Module[\"___stdio_exit\"] = createExportWrapper(\"__stdio_exit\");\r\n\r\nvar ___funcs_on_exit = Module[\"___funcs_on_exit\"] = createExportWrapper(\"__funcs_on_exit\");\r\n\r\nvar _malloc = Module[\"_malloc\"] = createExportWrapper(\"malloc\");\r\n\r\nvar _free = Module[\"_free\"] = createExportWrapper(\"free\");\r\n\r\nvar _memalign = Module[\"_memalign\"] = createExportWrapper(\"memalign\");\r\n\r\nvar _emscripten_builtin_malloc = Module[\"_emscripten_builtin_malloc\"] = createExportWrapper(\"emscripten_builtin_malloc\");\r\n\r\nvar _emscripten_builtin_free = Module[\"_emscripten_builtin_free\"] = createExportWrapper(\"emscripten_builtin_free\");\r\n\r\nvar _emscripten_builtin_memalign = Module[\"_emscripten_builtin_memalign\"] = createExportWrapper(\"emscripten_builtin_memalign\");\r\n\r\nvar _emscripten_stack_init = Module[\"_emscripten_stack_init\"] = function() {\r\n return (_emscripten_stack_init = Module[\"_emscripten_stack_init\"] = Module[\"asm\"][\"emscripten_stack_init\"]).apply(null, arguments);\r\n};\r\n\r\nvar _emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = function() {\r\n return (_emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = Module[\"asm\"][\"emscripten_stack_get_free\"]).apply(null, arguments);\r\n};\r\n\r\nvar _emscripten_stack_get_base = Module[\"_emscripten_stack_get_base\"] = function() {\r\n return (_emscripten_stack_get_base = Module[\"_emscripten_stack_get_base\"] = Module[\"asm\"][\"emscripten_stack_get_base\"]).apply(null, arguments);\r\n};\r\n\r\nvar _emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = function() {\r\n return (_emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = Module[\"asm\"][\"emscripten_stack_get_end\"]).apply(null, arguments);\r\n};\r\n\r\nvar stackSave = Module[\"stackSave\"] = createExportWrapper(\"stackSave\");\r\n\r\nvar stackRestore = Module[\"stackRestore\"] = createExportWrapper(\"stackRestore\");\r\n\r\nvar stackAlloc = Module[\"stackAlloc\"] = createExportWrapper(\"stackAlloc\");\r\n\r\nvar __ZN6__asan9FakeStack17AddrIsInFakeStackEm = Module[\"__ZN6__asan9FakeStack17AddrIsInFakeStackEm\"] = createExportWrapper(\"_ZN6__asan9FakeStack17AddrIsInFakeStackEm\");\r\n\r\nvar __ZN6__asan9FakeStack8AllocateEmmm = Module[\"__ZN6__asan9FakeStack8AllocateEmmm\"] = createExportWrapper(\"_ZN6__asan9FakeStack8AllocateEmmm\");\r\n\r\nvar _asan_c_load_1 = Module[\"_asan_c_load_1\"] = createExportWrapper(\"asan_c_load_1\");\r\n\r\nvar _asan_c_load_1u = Module[\"_asan_c_load_1u\"] = createExportWrapper(\"asan_c_load_1u\");\r\n\r\nvar _asan_c_load_2 = Module[\"_asan_c_load_2\"] = createExportWrapper(\"asan_c_load_2\");\r\n\r\nvar _asan_c_load_2u = Module[\"_asan_c_load_2u\"] = createExportWrapper(\"asan_c_load_2u\");\r\n\r\nvar _asan_c_load_4 = Module[\"_asan_c_load_4\"] = createExportWrapper(\"asan_c_load_4\");\r\n\r\nvar _asan_c_load_4u = Module[\"_asan_c_load_4u\"] = createExportWrapper(\"asan_c_load_4u\");\r\n\r\nvar _asan_c_load_f = Module[\"_asan_c_load_f\"] = createExportWrapper(\"asan_c_load_f\");\r\n\r\nvar _asan_c_load_d = Module[\"_asan_c_load_d\"] = createExportWrapper(\"asan_c_load_d\");\r\n\r\nvar _asan_c_store_1 = Module[\"_asan_c_store_1\"] = createExportWrapper(\"asan_c_store_1\");\r\n\r\nvar _asan_c_store_1u = Module[\"_asan_c_store_1u\"] = createExportWrapper(\"asan_c_store_1u\");\r\n\r\nvar _asan_c_store_2 = Module[\"_asan_c_store_2\"] = createExportWrapper(\"asan_c_store_2\");\r\n\r\nvar _asan_c_store_2u = Module[\"_asan_c_store_2u\"] = createExportWrapper(\"asan_c_store_2u\");\r\n\r\nvar _asan_c_store_4 = Module[\"_asan_c_store_4\"] = createExportWrapper(\"asan_c_store_4\");\r\n\r\nvar _asan_c_store_4u = Module[\"_asan_c_store_4u\"] = createExportWrapper(\"asan_c_store_4u\");\r\n\r\nvar _asan_c_store_f = Module[\"_asan_c_store_f\"] = createExportWrapper(\"asan_c_store_f\");\r\n\r\nvar _asan_c_store_d = Module[\"_asan_c_store_d\"] = createExportWrapper(\"asan_c_store_d\");\r\n\r\nvar dynCall_jii = Module[\"dynCall_jii\"] = createExportWrapper(\"dynCall_jii\");\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayFromString\")) Module[\"intArrayFromString\"] = (() => abort(\"'intArrayFromString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayToString\")) Module[\"intArrayToString\"] = (() => abort(\"'intArrayToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ccall\")) Module[\"ccall\"] = (() => abort(\"'ccall' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"cwrap\")) Module[\"cwrap\"] = (() => abort(\"'cwrap' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"setValue\")) Module[\"setValue\"] = (() => abort(\"'setValue' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getValue\")) Module[\"getValue\"] = (() => abort(\"'getValue' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"allocate\")) Module[\"allocate\"] = (() => abort(\"'allocate' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF8ArrayToString\")) Module[\"UTF8ArrayToString\"] = (() => abort(\"'UTF8ArrayToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF8ToString\")) Module[\"UTF8ToString\"] = (() => abort(\"'UTF8ToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8Array\")) Module[\"stringToUTF8Array\"] = (() => abort(\"'stringToUTF8Array' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8\")) Module[\"stringToUTF8\"] = (() => abort(\"'stringToUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF8\")) Module[\"lengthBytesUTF8\"] = (() => abort(\"'lengthBytesUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = (() => abort(\"'stackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreRun\")) Module[\"addOnPreRun\"] = (() => abort(\"'addOnPreRun' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnInit\")) Module[\"addOnInit\"] = (() => abort(\"'addOnInit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreMain\")) Module[\"addOnPreMain\"] = (() => abort(\"'addOnPreMain' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnExit\")) Module[\"addOnExit\"] = (() => abort(\"'addOnExit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPostRun\")) Module[\"addOnPostRun\"] = (() => abort(\"'addOnPostRun' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"writeStringToMemory\")) Module[\"writeStringToMemory\"] = (() => abort(\"'writeStringToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"writeArrayToMemory\")) Module[\"writeArrayToMemory\"] = (() => abort(\"'writeArrayToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"writeAsciiToMemory\")) Module[\"writeAsciiToMemory\"] = (() => abort(\"'writeAsciiToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"addRunDependency\")) Module[\"addRunDependency\"] = (() => abort(\"'addRunDependency' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"removeRunDependency\")) Module[\"removeRunDependency\"] = (() => abort(\"'removeRunDependency' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createFolder\")) Module[\"FS_createFolder\"] = (() => abort(\"'FS_createFolder' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createPath\")) Module[\"FS_createPath\"] = (() => abort(\"'FS_createPath' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createDataFile\")) Module[\"FS_createDataFile\"] = (() => abort(\"'FS_createDataFile' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createPreloadedFile\")) Module[\"FS_createPreloadedFile\"] = (() => abort(\"'FS_createPreloadedFile' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createLazyFile\")) Module[\"FS_createLazyFile\"] = (() => abort(\"'FS_createLazyFile' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createLink\")) Module[\"FS_createLink\"] = (() => abort(\"'FS_createLink' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createDevice\")) Module[\"FS_createDevice\"] = (() => abort(\"'FS_createDevice' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_unlink\")) Module[\"FS_unlink\"] = (() => abort(\"'FS_unlink' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getLEB\")) Module[\"getLEB\"] = (() => abort(\"'getLEB' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getFunctionTables\")) Module[\"getFunctionTables\"] = (() => abort(\"'getFunctionTables' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"alignFunctionTables\")) Module[\"alignFunctionTables\"] = (() => abort(\"'alignFunctionTables' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFunctions\")) Module[\"registerFunctions\"] = (() => abort(\"'registerFunctions' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"addFunction\")) Module[\"addFunction\"] = (() => abort(\"'addFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"removeFunction\")) Module[\"removeFunction\"] = (() => abort(\"'removeFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = (() => abort(\"'getFuncWrapper' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"prettyPrint\")) Module[\"prettyPrint\"] = (() => abort(\"'prettyPrint' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = (() => abort(\"'dynCall' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getCompilerSetting\")) Module[\"getCompilerSetting\"] = (() => abort(\"'getCompilerSetting' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"print\")) Module[\"print\"] = (() => abort(\"'print' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"printErr\")) Module[\"printErr\"] = (() => abort(\"'printErr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getTempRet0\")) Module[\"getTempRet0\"] = (() => abort(\"'getTempRet0' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"setTempRet0\")) Module[\"setTempRet0\"] = (() => abort(\"'setTempRet0' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"callMain\")) Module[\"callMain\"] = (() => abort(\"'callMain' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"abort\")) Module[\"abort\"] = (() => abort(\"'abort' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"keepRuntimeAlive\")) Module[\"keepRuntimeAlive\"] = (() => abort(\"'keepRuntimeAlive' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"WasmOffsetConverter\")) Module[\"WasmOffsetConverter\"] = (() => abort(\"'WasmOffsetConverter' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"zeroMemory\")) Module[\"zeroMemory\"] = (() => abort(\"'zeroMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToNewUTF8\")) Module[\"stringToNewUTF8\"] = (() => abort(\"'stringToNewUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"setFileTime\")) Module[\"setFileTime\"] = (() => abort(\"'setFileTime' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"abortOnCannotGrowMemory\")) Module[\"abortOnCannotGrowMemory\"] = (() => abort(\"'abortOnCannotGrowMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emscripten_realloc_buffer\")) Module[\"emscripten_realloc_buffer\"] = (() => abort(\"'emscripten_realloc_buffer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ENV\")) Module[\"ENV\"] = (() => abort(\"'ENV' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"withStackSave\")) Module[\"withStackSave\"] = (() => abort(\"'withStackSave' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_CODES\")) Module[\"ERRNO_CODES\"] = (() => abort(\"'ERRNO_CODES' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_MESSAGES\")) Module[\"ERRNO_MESSAGES\"] = (() => abort(\"'ERRNO_MESSAGES' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"setErrNo\")) Module[\"setErrNo\"] = (() => abort(\"'setErrNo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"inetPton4\")) Module[\"inetPton4\"] = (() => abort(\"'inetPton4' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"inetNtop4\")) Module[\"inetNtop4\"] = (() => abort(\"'inetNtop4' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"inetPton6\")) Module[\"inetPton6\"] = (() => abort(\"'inetPton6' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"inetNtop6\")) Module[\"inetNtop6\"] = (() => abort(\"'inetNtop6' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"readSockaddr\")) Module[\"readSockaddr\"] = (() => abort(\"'readSockaddr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"writeSockaddr\")) Module[\"writeSockaddr\"] = (() => abort(\"'writeSockaddr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"DNS\")) Module[\"DNS\"] = (() => abort(\"'DNS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getHostByName\")) Module[\"getHostByName\"] = (() => abort(\"'getHostByName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"Protocols\")) Module[\"Protocols\"] = (() => abort(\"'Protocols' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"Sockets\")) Module[\"Sockets\"] = (() => abort(\"'Sockets' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getRandomDevice\")) Module[\"getRandomDevice\"] = (() => abort(\"'getRandomDevice' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"traverseStack\")) Module[\"traverseStack\"] = (() => abort(\"'traverseStack' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"convertFrameToPC\")) Module[\"convertFrameToPC\"] = (() => abort(\"'convertFrameToPC' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"UNWIND_CACHE\")) Module[\"UNWIND_CACHE\"] = (() => abort(\"'UNWIND_CACHE' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"saveInUnwindCache\")) Module[\"saveInUnwindCache\"] = (() => abort(\"'saveInUnwindCache' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"convertPCtoSourceLocation\")) Module[\"convertPCtoSourceLocation\"] = (() => abort(\"'convertPCtoSourceLocation' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"withBuiltinMalloc\")) Module[\"withBuiltinMalloc\"] = (() => abort(\"'withBuiltinMalloc' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"readAsmConstArgsArray\")) Module[\"readAsmConstArgsArray\"] = (() => abort(\"'readAsmConstArgsArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"readAsmConstArgs\")) Module[\"readAsmConstArgs\"] = (() => abort(\"'readAsmConstArgs' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"mainThreadEM_ASM\")) Module[\"mainThreadEM_ASM\"] = (() => abort(\"'mainThreadEM_ASM' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"jstoi_q\")) Module[\"jstoi_q\"] = (() => abort(\"'jstoi_q' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"jstoi_s\")) Module[\"jstoi_s\"] = (() => abort(\"'jstoi_s' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getExecutableName\")) Module[\"getExecutableName\"] = (() => abort(\"'getExecutableName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"listenOnce\")) Module[\"listenOnce\"] = (() => abort(\"'listenOnce' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"autoResumeAudioContext\")) Module[\"autoResumeAudioContext\"] = (() => abort(\"'autoResumeAudioContext' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCallLegacy\")) Module[\"dynCallLegacy\"] = (() => abort(\"'dynCallLegacy' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getDynCaller\")) Module[\"getDynCaller\"] = (() => abort(\"'getDynCaller' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = (() => abort(\"'dynCall' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"callRuntimeCallbacks\")) Module[\"callRuntimeCallbacks\"] = (() => abort(\"'callRuntimeCallbacks' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"wasmTableMirror\")) Module[\"wasmTableMirror\"] = (() => abort(\"'wasmTableMirror' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"setWasmTableEntry\")) Module[\"setWasmTableEntry\"] = (() => abort(\"'setWasmTableEntry' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getWasmTableEntry\")) Module[\"getWasmTableEntry\"] = (() => abort(\"'getWasmTableEntry' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"handleException\")) Module[\"handleException\"] = (() => abort(\"'handleException' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"runtimeKeepalivePush\")) Module[\"runtimeKeepalivePush\"] = (() => abort(\"'runtimeKeepalivePush' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"runtimeKeepalivePop\")) Module[\"runtimeKeepalivePop\"] = (() => abort(\"'runtimeKeepalivePop' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"callUserCallback\")) Module[\"callUserCallback\"] = (() => abort(\"'callUserCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"maybeExit\")) Module[\"maybeExit\"] = (() => abort(\"'maybeExit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"safeSetTimeout\")) Module[\"safeSetTimeout\"] = (() => abort(\"'safeSetTimeout' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"asmjsMangle\")) Module[\"asmjsMangle\"] = (() => abort(\"'asmjsMangle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"asyncLoad\")) Module[\"asyncLoad\"] = (() => abort(\"'asyncLoad' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"alignMemory\")) Module[\"alignMemory\"] = (() => abort(\"'alignMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"mmapAlloc\")) Module[\"mmapAlloc\"] = (() => abort(\"'mmapAlloc' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"reallyNegative\")) Module[\"reallyNegative\"] = (() => abort(\"'reallyNegative' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"unSign\")) Module[\"unSign\"] = (() => abort(\"'unSign' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"reSign\")) Module[\"reSign\"] = (() => abort(\"'reSign' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"formatString\")) Module[\"formatString\"] = (() => abort(\"'formatString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH\")) Module[\"PATH\"] = (() => abort(\"'PATH' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH_FS\")) Module[\"PATH_FS\"] = (() => abort(\"'PATH_FS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"SYSCALLS\")) Module[\"SYSCALLS\"] = (() => abort(\"'SYSCALLS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"syscallMmap2\")) Module[\"syscallMmap2\"] = (() => abort(\"'syscallMmap2' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"syscallMunmap\")) Module[\"syscallMunmap\"] = (() => abort(\"'syscallMunmap' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getSocketFromFD\")) Module[\"getSocketFromFD\"] = (() => abort(\"'getSocketFromFD' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getSocketAddress\")) Module[\"getSocketAddress\"] = (() => abort(\"'getSocketAddress' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"JSEvents\")) Module[\"JSEvents\"] = (() => abort(\"'JSEvents' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerKeyEventCallback\")) Module[\"registerKeyEventCallback\"] = (() => abort(\"'registerKeyEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"specialHTMLTargets\")) Module[\"specialHTMLTargets\"] = (() => abort(\"'specialHTMLTargets' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"maybeCStringToJsString\")) Module[\"maybeCStringToJsString\"] = (() => abort(\"'maybeCStringToJsString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"findEventTarget\")) Module[\"findEventTarget\"] = (() => abort(\"'findEventTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"findCanvasEventTarget\")) Module[\"findCanvasEventTarget\"] = (() => abort(\"'findCanvasEventTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getBoundingClientRect\")) Module[\"getBoundingClientRect\"] = (() => abort(\"'getBoundingClientRect' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"fillMouseEventData\")) Module[\"fillMouseEventData\"] = (() => abort(\"'fillMouseEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerMouseEventCallback\")) Module[\"registerMouseEventCallback\"] = (() => abort(\"'registerMouseEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerWheelEventCallback\")) Module[\"registerWheelEventCallback\"] = (() => abort(\"'registerWheelEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerUiEventCallback\")) Module[\"registerUiEventCallback\"] = (() => abort(\"'registerUiEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFocusEventCallback\")) Module[\"registerFocusEventCallback\"] = (() => abort(\"'registerFocusEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"fillDeviceOrientationEventData\")) Module[\"fillDeviceOrientationEventData\"] = (() => abort(\"'fillDeviceOrientationEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerDeviceOrientationEventCallback\")) Module[\"registerDeviceOrientationEventCallback\"] = (() => abort(\"'registerDeviceOrientationEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"fillDeviceMotionEventData\")) Module[\"fillDeviceMotionEventData\"] = (() => abort(\"'fillDeviceMotionEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerDeviceMotionEventCallback\")) Module[\"registerDeviceMotionEventCallback\"] = (() => abort(\"'registerDeviceMotionEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"screenOrientation\")) Module[\"screenOrientation\"] = (() => abort(\"'screenOrientation' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"fillOrientationChangeEventData\")) Module[\"fillOrientationChangeEventData\"] = (() => abort(\"'fillOrientationChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerOrientationChangeEventCallback\")) Module[\"registerOrientationChangeEventCallback\"] = (() => abort(\"'registerOrientationChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"fillFullscreenChangeEventData\")) Module[\"fillFullscreenChangeEventData\"] = (() => abort(\"'fillFullscreenChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFullscreenChangeEventCallback\")) Module[\"registerFullscreenChangeEventCallback\"] = (() => abort(\"'registerFullscreenChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerRestoreOldStyle\")) Module[\"registerRestoreOldStyle\"] = (() => abort(\"'registerRestoreOldStyle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"hideEverythingExceptGivenElement\")) Module[\"hideEverythingExceptGivenElement\"] = (() => abort(\"'hideEverythingExceptGivenElement' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"restoreHiddenElements\")) Module[\"restoreHiddenElements\"] = (() => abort(\"'restoreHiddenElements' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"setLetterbox\")) Module[\"setLetterbox\"] = (() => abort(\"'setLetterbox' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"currentFullscreenStrategy\")) Module[\"currentFullscreenStrategy\"] = (() => abort(\"'currentFullscreenStrategy' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"restoreOldWindowedStyle\")) Module[\"restoreOldWindowedStyle\"] = (() => abort(\"'restoreOldWindowedStyle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"softFullscreenResizeWebGLRenderTarget\")) Module[\"softFullscreenResizeWebGLRenderTarget\"] = (() => abort(\"'softFullscreenResizeWebGLRenderTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"doRequestFullscreen\")) Module[\"doRequestFullscreen\"] = (() => abort(\"'doRequestFullscreen' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"fillPointerlockChangeEventData\")) Module[\"fillPointerlockChangeEventData\"] = (() => abort(\"'fillPointerlockChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerPointerlockChangeEventCallback\")) Module[\"registerPointerlockChangeEventCallback\"] = (() => abort(\"'registerPointerlockChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerPointerlockErrorEventCallback\")) Module[\"registerPointerlockErrorEventCallback\"] = (() => abort(\"'registerPointerlockErrorEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"requestPointerLock\")) Module[\"requestPointerLock\"] = (() => abort(\"'requestPointerLock' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"fillVisibilityChangeEventData\")) Module[\"fillVisibilityChangeEventData\"] = (() => abort(\"'fillVisibilityChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerVisibilityChangeEventCallback\")) Module[\"registerVisibilityChangeEventCallback\"] = (() => abort(\"'registerVisibilityChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerTouchEventCallback\")) Module[\"registerTouchEventCallback\"] = (() => abort(\"'registerTouchEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"fillGamepadEventData\")) Module[\"fillGamepadEventData\"] = (() => abort(\"'fillGamepadEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerGamepadEventCallback\")) Module[\"registerGamepadEventCallback\"] = (() => abort(\"'registerGamepadEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerBeforeUnloadEventCallback\")) Module[\"registerBeforeUnloadEventCallback\"] = (() => abort(\"'registerBeforeUnloadEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"fillBatteryEventData\")) Module[\"fillBatteryEventData\"] = (() => abort(\"'fillBatteryEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"battery\")) Module[\"battery\"] = (() => abort(\"'battery' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerBatteryEventCallback\")) Module[\"registerBatteryEventCallback\"] = (() => abort(\"'registerBatteryEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"setCanvasElementSize\")) Module[\"setCanvasElementSize\"] = (() => abort(\"'setCanvasElementSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getCanvasElementSize\")) Module[\"getCanvasElementSize\"] = (() => abort(\"'getCanvasElementSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"demangle\")) Module[\"demangle\"] = (() => abort(\"'demangle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"demangleAll\")) Module[\"demangleAll\"] = (() => abort(\"'demangleAll' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"jsStackTrace\")) Module[\"jsStackTrace\"] = (() => abort(\"'jsStackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = (() => abort(\"'stackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getEnvStrings\")) Module[\"getEnvStrings\"] = (() => abort(\"'getEnvStrings' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"checkWasiClock\")) Module[\"checkWasiClock\"] = (() => abort(\"'checkWasiClock' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64\")) Module[\"writeI53ToI64\"] = (() => abort(\"'writeI53ToI64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Clamped\")) Module[\"writeI53ToI64Clamped\"] = (() => abort(\"'writeI53ToI64Clamped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Signaling\")) Module[\"writeI53ToI64Signaling\"] = (() => abort(\"'writeI53ToI64Signaling' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Clamped\")) Module[\"writeI53ToU64Clamped\"] = (() => abort(\"'writeI53ToU64Clamped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Signaling\")) Module[\"writeI53ToU64Signaling\"] = (() => abort(\"'writeI53ToU64Signaling' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"readI53FromI64\")) Module[\"readI53FromI64\"] = (() => abort(\"'readI53FromI64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"readI53FromU64\")) Module[\"readI53FromU64\"] = (() => abort(\"'readI53FromU64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"convertI32PairToI53\")) Module[\"convertI32PairToI53\"] = (() => abort(\"'convertI32PairToI53' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"convertU32PairToI53\")) Module[\"convertU32PairToI53\"] = (() => abort(\"'convertU32PairToI53' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"setImmediateWrapped\")) Module[\"setImmediateWrapped\"] = (() => abort(\"'setImmediateWrapped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"clearImmediateWrapped\")) Module[\"clearImmediateWrapped\"] = (() => abort(\"'clearImmediateWrapped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"polyfillSetImmediate\")) Module[\"polyfillSetImmediate\"] = (() => abort(\"'polyfillSetImmediate' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"uncaughtExceptionCount\")) Module[\"uncaughtExceptionCount\"] = (() => abort(\"'uncaughtExceptionCount' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"exceptionLast\")) Module[\"exceptionLast\"] = (() => abort(\"'exceptionLast' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"exceptionCaught\")) Module[\"exceptionCaught\"] = (() => abort(\"'exceptionCaught' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ExceptionInfo\")) Module[\"ExceptionInfo\"] = (() => abort(\"'ExceptionInfo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"CatchInfo\")) Module[\"CatchInfo\"] = (() => abort(\"'CatchInfo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"exception_addRef\")) Module[\"exception_addRef\"] = (() => abort(\"'exception_addRef' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"exception_decRef\")) Module[\"exception_decRef\"] = (() => abort(\"'exception_decRef' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"Browser\")) Module[\"Browser\"] = (() => abort(\"'Browser' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"funcWrappers\")) Module[\"funcWrappers\"] = (() => abort(\"'funcWrappers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = (() => abort(\"'getFuncWrapper' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"setMainLoop\")) Module[\"setMainLoop\"] = (() => abort(\"'setMainLoop' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"wget\")) Module[\"wget\"] = (() => abort(\"'wget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"FS\")) Module[\"FS\"] = (() => abort(\"'FS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"MEMFS\")) Module[\"MEMFS\"] = (() => abort(\"'MEMFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"TTY\")) Module[\"TTY\"] = (() => abort(\"'TTY' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"PIPEFS\")) Module[\"PIPEFS\"] = (() => abort(\"'PIPEFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"SOCKFS\")) Module[\"SOCKFS\"] = (() => abort(\"'SOCKFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"_setNetworkCallback\")) Module[\"_setNetworkCallback\"] = (() => abort(\"'_setNetworkCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"tempFixedLengthArray\")) Module[\"tempFixedLengthArray\"] = (() => abort(\"'tempFixedLengthArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"miniTempWebGLFloatBuffers\")) Module[\"miniTempWebGLFloatBuffers\"] = (() => abort(\"'miniTempWebGLFloatBuffers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"heapObjectForWebGLType\")) Module[\"heapObjectForWebGLType\"] = (() => abort(\"'heapObjectForWebGLType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"heapAccessShiftForWebGLHeap\")) Module[\"heapAccessShiftForWebGLHeap\"] = (() => abort(\"'heapAccessShiftForWebGLHeap' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"GL\")) Module[\"GL\"] = (() => abort(\"'GL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet\")) Module[\"emscriptenWebGLGet\"] = (() => abort(\"'emscriptenWebGLGet' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"computeUnpackAlignedImageSize\")) Module[\"computeUnpackAlignedImageSize\"] = (() => abort(\"'computeUnpackAlignedImageSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData\")) Module[\"emscriptenWebGLGetTexPixelData\"] = (() => abort(\"'emscriptenWebGLGetTexPixelData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform\")) Module[\"emscriptenWebGLGetUniform\"] = (() => abort(\"'emscriptenWebGLGetUniform' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"webglGetUniformLocation\")) Module[\"webglGetUniformLocation\"] = (() => abort(\"'webglGetUniformLocation' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"webglPrepareUniformLocationsBeforeFirstUse\")) Module[\"webglPrepareUniformLocationsBeforeFirstUse\"] = (() => abort(\"'webglPrepareUniformLocationsBeforeFirstUse' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"webglGetLeftBracePos\")) Module[\"webglGetLeftBracePos\"] = (() => abort(\"'webglGetLeftBracePos' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib\")) Module[\"emscriptenWebGLGetVertexAttrib\"] = (() => abort(\"'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"writeGLArray\")) Module[\"writeGLArray\"] = (() => abort(\"'writeGLArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"AL\")) Module[\"AL\"] = (() => abort(\"'AL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_unicode\")) Module[\"SDL_unicode\"] = (() => abort(\"'SDL_unicode' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_ttfContext\")) Module[\"SDL_ttfContext\"] = (() => abort(\"'SDL_ttfContext' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_audio\")) Module[\"SDL_audio\"] = (() => abort(\"'SDL_audio' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL\")) Module[\"SDL\"] = (() => abort(\"'SDL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_gfx\")) Module[\"SDL_gfx\"] = (() => abort(\"'SDL_gfx' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"GLUT\")) Module[\"GLUT\"] = (() => abort(\"'GLUT' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"EGL\")) Module[\"EGL\"] = (() => abort(\"'EGL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"GLFW_Window\")) Module[\"GLFW_Window\"] = (() => abort(\"'GLFW_Window' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"GLFW\")) Module[\"GLFW\"] = (() => abort(\"'GLFW' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"GLEW\")) Module[\"GLEW\"] = (() => abort(\"'GLEW' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"IDBStore\")) Module[\"IDBStore\"] = (() => abort(\"'IDBStore' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"runAndAbortIfError\")) Module[\"runAndAbortIfError\"] = (() => abort(\"'runAndAbortIfError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"InternalError\")) Module[\"InternalError\"] = (() => abort(\"'InternalError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"BindingError\")) Module[\"BindingError\"] = (() => abort(\"'BindingError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"UnboundTypeError\")) Module[\"UnboundTypeError\"] = (() => abort(\"'UnboundTypeError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"PureVirtualError\")) Module[\"PureVirtualError\"] = (() => abort(\"'PureVirtualError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"init_embind\")) Module[\"init_embind\"] = (() => abort(\"'init_embind' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"throwInternalError\")) Module[\"throwInternalError\"] = (() => abort(\"'throwInternalError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"throwBindingError\")) Module[\"throwBindingError\"] = (() => abort(\"'throwBindingError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"throwUnboundTypeError\")) Module[\"throwUnboundTypeError\"] = (() => abort(\"'throwUnboundTypeError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ensureOverloadTable\")) Module[\"ensureOverloadTable\"] = (() => abort(\"'ensureOverloadTable' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"exposePublicSymbol\")) Module[\"exposePublicSymbol\"] = (() => abort(\"'exposePublicSymbol' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"replacePublicSymbol\")) Module[\"replacePublicSymbol\"] = (() => abort(\"'replacePublicSymbol' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"extendError\")) Module[\"extendError\"] = (() => abort(\"'extendError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"createNamedFunction\")) Module[\"createNamedFunction\"] = (() => abort(\"'createNamedFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registeredInstances\")) Module[\"registeredInstances\"] = (() => abort(\"'registeredInstances' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getBasestPointer\")) Module[\"getBasestPointer\"] = (() => abort(\"'getBasestPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerInheritedInstance\")) Module[\"registerInheritedInstance\"] = (() => abort(\"'registerInheritedInstance' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"unregisterInheritedInstance\")) Module[\"unregisterInheritedInstance\"] = (() => abort(\"'unregisterInheritedInstance' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getInheritedInstance\")) Module[\"getInheritedInstance\"] = (() => abort(\"'getInheritedInstance' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getInheritedInstanceCount\")) Module[\"getInheritedInstanceCount\"] = (() => abort(\"'getInheritedInstanceCount' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getLiveInheritedInstances\")) Module[\"getLiveInheritedInstances\"] = (() => abort(\"'getLiveInheritedInstances' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registeredTypes\")) Module[\"registeredTypes\"] = (() => abort(\"'registeredTypes' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"awaitingDependencies\")) Module[\"awaitingDependencies\"] = (() => abort(\"'awaitingDependencies' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"typeDependencies\")) Module[\"typeDependencies\"] = (() => abort(\"'typeDependencies' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registeredPointers\")) Module[\"registeredPointers\"] = (() => abort(\"'registeredPointers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"registerType\")) Module[\"registerType\"] = (() => abort(\"'registerType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"whenDependentTypesAreResolved\")) Module[\"whenDependentTypesAreResolved\"] = (() => abort(\"'whenDependentTypesAreResolved' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"embind_charCodes\")) Module[\"embind_charCodes\"] = (() => abort(\"'embind_charCodes' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"embind_init_charCodes\")) Module[\"embind_init_charCodes\"] = (() => abort(\"'embind_init_charCodes' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"readLatin1String\")) Module[\"readLatin1String\"] = (() => abort(\"'readLatin1String' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getTypeName\")) Module[\"getTypeName\"] = (() => abort(\"'getTypeName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"heap32VectorToArray\")) Module[\"heap32VectorToArray\"] = (() => abort(\"'heap32VectorToArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"requireRegisteredType\")) Module[\"requireRegisteredType\"] = (() => abort(\"'requireRegisteredType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getShiftFromSize\")) Module[\"getShiftFromSize\"] = (() => abort(\"'getShiftFromSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"integerReadValueFromPointer\")) Module[\"integerReadValueFromPointer\"] = (() => abort(\"'integerReadValueFromPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"enumReadValueFromPointer\")) Module[\"enumReadValueFromPointer\"] = (() => abort(\"'enumReadValueFromPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"floatReadValueFromPointer\")) Module[\"floatReadValueFromPointer\"] = (() => abort(\"'floatReadValueFromPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"simpleReadValueFromPointer\")) Module[\"simpleReadValueFromPointer\"] = (() => abort(\"'simpleReadValueFromPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"runDestructors\")) Module[\"runDestructors\"] = (() => abort(\"'runDestructors' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"new_\")) Module[\"new_\"] = (() => abort(\"'new_' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"craftInvokerFunction\")) Module[\"craftInvokerFunction\"] = (() => abort(\"'craftInvokerFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"embind__requireFunction\")) Module[\"embind__requireFunction\"] = (() => abort(\"'embind__requireFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"tupleRegistrations\")) Module[\"tupleRegistrations\"] = (() => abort(\"'tupleRegistrations' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"structRegistrations\")) Module[\"structRegistrations\"] = (() => abort(\"'structRegistrations' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"genericPointerToWireType\")) Module[\"genericPointerToWireType\"] = (() => abort(\"'genericPointerToWireType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"constNoSmartPtrRawPointerToWireType\")) Module[\"constNoSmartPtrRawPointerToWireType\"] = (() => abort(\"'constNoSmartPtrRawPointerToWireType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"nonConstNoSmartPtrRawPointerToWireType\")) Module[\"nonConstNoSmartPtrRawPointerToWireType\"] = (() => abort(\"'nonConstNoSmartPtrRawPointerToWireType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"init_RegisteredPointer\")) Module[\"init_RegisteredPointer\"] = (() => abort(\"'init_RegisteredPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer\")) Module[\"RegisteredPointer\"] = (() => abort(\"'RegisteredPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_getPointee\")) Module[\"RegisteredPointer_getPointee\"] = (() => abort(\"'RegisteredPointer_getPointee' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_destructor\")) Module[\"RegisteredPointer_destructor\"] = (() => abort(\"'RegisteredPointer_destructor' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_deleteObject\")) Module[\"RegisteredPointer_deleteObject\"] = (() => abort(\"'RegisteredPointer_deleteObject' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_fromWireType\")) Module[\"RegisteredPointer_fromWireType\"] = (() => abort(\"'RegisteredPointer_fromWireType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"runDestructor\")) Module[\"runDestructor\"] = (() => abort(\"'runDestructor' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"releaseClassHandle\")) Module[\"releaseClassHandle\"] = (() => abort(\"'releaseClassHandle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"finalizationRegistry\")) Module[\"finalizationRegistry\"] = (() => abort(\"'finalizationRegistry' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"detachFinalizer_deps\")) Module[\"detachFinalizer_deps\"] = (() => abort(\"'detachFinalizer_deps' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"detachFinalizer\")) Module[\"detachFinalizer\"] = (() => abort(\"'detachFinalizer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"attachFinalizer\")) Module[\"attachFinalizer\"] = (() => abort(\"'attachFinalizer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"makeClassHandle\")) Module[\"makeClassHandle\"] = (() => abort(\"'makeClassHandle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"init_ClassHandle\")) Module[\"init_ClassHandle\"] = (() => abort(\"'init_ClassHandle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle\")) Module[\"ClassHandle\"] = (() => abort(\"'ClassHandle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_isAliasOf\")) Module[\"ClassHandle_isAliasOf\"] = (() => abort(\"'ClassHandle_isAliasOf' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"throwInstanceAlreadyDeleted\")) Module[\"throwInstanceAlreadyDeleted\"] = (() => abort(\"'throwInstanceAlreadyDeleted' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_clone\")) Module[\"ClassHandle_clone\"] = (() => abort(\"'ClassHandle_clone' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_delete\")) Module[\"ClassHandle_delete\"] = (() => abort(\"'ClassHandle_delete' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"deletionQueue\")) Module[\"deletionQueue\"] = (() => abort(\"'deletionQueue' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_isDeleted\")) Module[\"ClassHandle_isDeleted\"] = (() => abort(\"'ClassHandle_isDeleted' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_deleteLater\")) Module[\"ClassHandle_deleteLater\"] = (() => abort(\"'ClassHandle_deleteLater' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"flushPendingDeletes\")) Module[\"flushPendingDeletes\"] = (() => abort(\"'flushPendingDeletes' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"delayFunction\")) Module[\"delayFunction\"] = (() => abort(\"'delayFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"setDelayFunction\")) Module[\"setDelayFunction\"] = (() => abort(\"'setDelayFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredClass\")) Module[\"RegisteredClass\"] = (() => abort(\"'RegisteredClass' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"shallowCopyInternalPointer\")) Module[\"shallowCopyInternalPointer\"] = (() => abort(\"'shallowCopyInternalPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"downcastPointer\")) Module[\"downcastPointer\"] = (() => abort(\"'downcastPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"upcastPointer\")) Module[\"upcastPointer\"] = (() => abort(\"'upcastPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"validateThis\")) Module[\"validateThis\"] = (() => abort(\"'validateThis' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"char_0\")) Module[\"char_0\"] = (() => abort(\"'char_0' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"char_9\")) Module[\"char_9\"] = (() => abort(\"'char_9' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"makeLegalFunctionName\")) Module[\"makeLegalFunctionName\"] = (() => abort(\"'makeLegalFunctionName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_handle_array\")) Module[\"emval_handle_array\"] = (() => abort(\"'emval_handle_array' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_free_list\")) Module[\"emval_free_list\"] = (() => abort(\"'emval_free_list' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_symbols\")) Module[\"emval_symbols\"] = (() => abort(\"'emval_symbols' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"init_emval\")) Module[\"init_emval\"] = (() => abort(\"'init_emval' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"count_emval_handles\")) Module[\"count_emval_handles\"] = (() => abort(\"'count_emval_handles' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"get_first_emval\")) Module[\"get_first_emval\"] = (() => abort(\"'get_first_emval' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"getStringOrSymbol\")) Module[\"getStringOrSymbol\"] = (() => abort(\"'getStringOrSymbol' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"Emval\")) Module[\"Emval\"] = (() => abort(\"'Emval' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_newers\")) Module[\"emval_newers\"] = (() => abort(\"'emval_newers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"craftEmvalAllocator\")) Module[\"craftEmvalAllocator\"] = (() => abort(\"'craftEmvalAllocator' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_get_global\")) Module[\"emval_get_global\"] = (() => abort(\"'emval_get_global' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_methodCallers\")) Module[\"emval_methodCallers\"] = (() => abort(\"'emval_methodCallers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_registeredMethods\")) Module[\"emval_registeredMethods\"] = (() => abort(\"'emval_registeredMethods' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"warnOnce\")) Module[\"warnOnce\"] = (() => abort(\"'warnOnce' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"stackSave\")) Module[\"stackSave\"] = (() => abort(\"'stackSave' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"stackRestore\")) Module[\"stackRestore\"] = (() => abort(\"'stackRestore' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"stackAlloc\")) Module[\"stackAlloc\"] = (() => abort(\"'stackAlloc' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"AsciiToString\")) Module[\"AsciiToString\"] = (() => abort(\"'AsciiToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToAscii\")) Module[\"stringToAscii\"] = (() => abort(\"'stringToAscii' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF16ToString\")) Module[\"UTF16ToString\"] = (() => abort(\"'UTF16ToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF16\")) Module[\"stringToUTF16\"] = (() => abort(\"'stringToUTF16' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF16\")) Module[\"lengthBytesUTF16\"] = (() => abort(\"'lengthBytesUTF16' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF32ToString\")) Module[\"UTF32ToString\"] = (() => abort(\"'UTF32ToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF32\")) Module[\"stringToUTF32\"] = (() => abort(\"'stringToUTF32' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF32\")) Module[\"lengthBytesUTF32\"] = (() => abort(\"'lengthBytesUTF32' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8\")) Module[\"allocateUTF8\"] = (() => abort(\"'allocateUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8OnStack\")) Module[\"allocateUTF8OnStack\"] = (() => abort(\"'allocateUTF8OnStack' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\r\n\r\nModule[\"writeStackCookie\"] = writeStackCookie;\r\n\r\nModule[\"checkStackCookie\"] = checkStackCookie;\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NORMAL\")) Object.defineProperty(Module, \"ALLOC_NORMAL\", {\r\n configurable: true,\r\n get: function() {\r\n  abort(\"'ALLOC_NORMAL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\r\n }\r\n});\r\n\r\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_STACK\")) Object.defineProperty(Module, \"ALLOC_STACK\", {\r\n configurable: true,\r\n get: function() {\r\n  abort(\"'ALLOC_STACK' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\r\n }\r\n});\r\n\r\nvar calledRun;\r\n\r\nfunction ExitStatus(status) {\r\n this.name = \"ExitStatus\";\r\n this.message = \"Program terminated with exit(\" + status + \")\";\r\n this.status = status;\r\n}\r\n\r\ndependenciesFulfilled = function runCaller() {\r\n if (!calledRun) run();\r\n if (!calledRun) dependenciesFulfilled = runCaller;\r\n};\r\n\r\nfunction stackCheckInit() {\r\n _emscripten_stack_init();\r\n writeStackCookie();\r\n}\r\n\r\nfunction run(args) {\r\n args = args || arguments_;\r\n if (runDependencies > 0) {\r\n  return;\r\n }\r\n stackCheckInit();\r\n preRun();\r\n if (runDependencies > 0) {\r\n  return;\r\n }\r\n function doRun() {\r\n  if (calledRun) return;\r\n  calledRun = true;\r\n  Module[\"calledRun\"] = true;\r\n  if (ABORT) return;\r\n  initRuntime();\r\n  readyPromiseResolve(Module);\r\n  if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\r\n  assert(!Module[\"_main\"], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\r\n  postRun();\r\n }\r\n if (Module[\"setStatus\"]) {\r\n  Module[\"setStatus\"](\"Running...\");\r\n  setTimeout(function() {\r\n   setTimeout(function() {\r\n    Module[\"setStatus\"](\"\");\r\n   }, 1);\r\n   doRun();\r\n  }, 1);\r\n } else {\r\n  doRun();\r\n }\r\n checkStackCookie();\r\n}\r\n\r\nModule[\"run\"] = run;\r\n\r\nfunction procExit(code) {\r\n EXITSTATUS = code;\r\n if (!keepRuntimeAlive()) {\r\n  if (Module[\"onExit\"]) Module[\"onExit\"](code);\r\n  ABORT = true;\r\n }\r\n quit_(code, new ExitStatus(code));\r\n}\r\n\r\nif (Module[\"preInit\"]) {\r\n if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [ Module[\"preInit\"] ];\r\n while (Module[\"preInit\"].length > 0) {\r\n  Module[\"preInit\"].pop()();\r\n }\r\n}\r\n\r\nrun();\r\n\r\n\r\n  return createMLSGenModule.ready\r\n}\r\n);\r\n})();\r\nif (true)\r\n  module.exports = createMLSGenModule;\r\nelse {}\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./dist/mlsGen.js?");

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/axios */ \"./node_modules/axios/lib/axios.js\");\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/index.js?");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar transitionalDefaults = __webpack_require__(/*! ../defaults/transitional */ \"./node_modules/axios/lib/defaults/transitional.js\");\nvar AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./node_modules/axios/lib/core/AxiosError.js\");\nvar CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ \"./node_modules/axios/lib/cancel/CanceledError.js\");\nvar parseProtocol = __webpack_require__(/*! ../helpers/parseProtocol */ \"./node_modules/axios/lib/helpers/parseProtocol.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || transitionalDefaults;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    var protocol = parseProtocol(fullPath);\n\n    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/adapters/xhr.js?");

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"./node_modules/axios/lib/core/Axios.js\");\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/axios/lib/defaults/index.js\");\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = __webpack_require__(/*! ./cancel/CanceledError */ \"./node_modules/axios/lib/cancel/CanceledError.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"./node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\naxios.VERSION = (__webpack_require__(/*! ./env/data */ \"./node_modules/axios/lib/env/data.js\").version);\naxios.toFormData = __webpack_require__(/*! ./helpers/toFormData */ \"./node_modules/axios/lib/helpers/toFormData.js\");\n\n// Expose AxiosError class\naxios.AxiosError = __webpack_require__(/*! ../lib/core/AxiosError */ \"./node_modules/axios/lib/core/AxiosError.js\");\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"./node_modules/axios/lib/helpers/spread.js\");\n\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \"./node_modules/axios/lib/helpers/isAxiosError.js\");\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports[\"default\"] = axios;\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar CanceledError = __webpack_require__(/*! ./CanceledError */ \"./node_modules/axios/lib/cancel/CanceledError.js\");\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n\n  // eslint-disable-next-line func-names\n  this.promise.then(function(cancel) {\n    if (!token._listeners) return;\n\n    var i;\n    var l = token._listeners.length;\n\n    for (i = 0; i < l; i++) {\n      token._listeners[i](cancel);\n    }\n    token._listeners = null;\n  });\n\n  // eslint-disable-next-line func-names\n  this.promise.then = function(onfulfilled) {\n    var _resolve;\n    // eslint-disable-next-line func-names\n    var promise = new Promise(function(resolve) {\n      token.subscribe(resolve);\n      _resolve = resolve;\n    }).then(onfulfilled);\n\n    promise.cancel = function reject() {\n      token.unsubscribe(_resolve);\n    };\n\n    return promise;\n  };\n\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new CanceledError(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Subscribe to the cancel signal\n */\n\nCancelToken.prototype.subscribe = function subscribe(listener) {\n  if (this.reason) {\n    listener(this.reason);\n    return;\n  }\n\n  if (this._listeners) {\n    this._listeners.push(listener);\n  } else {\n    this._listeners = [listener];\n  }\n};\n\n/**\n * Unsubscribe from the cancel signal\n */\n\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n  if (!this._listeners) {\n    return;\n  }\n  var index = this._listeners.indexOf(listener);\n  if (index !== -1) {\n    this._listeners.splice(index, 1);\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/cancel/CancelToken.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CanceledError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CanceledError.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./node_modules/axios/lib/core/AxiosError.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction CanceledError(message) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);\n  this.name = 'CanceledError';\n}\n\nutils.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\nmodule.exports = CanceledError;\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/cancel/CanceledError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/cancel/isCancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar buildFullPath = __webpack_require__(/*! ./buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\nvar validator = __webpack_require__(/*! ../helpers/validator */ \"./node_modules/axios/lib/helpers/validator.js\");\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(configOrUrl, config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof configOrUrl === 'string') {\n    config = config || {};\n    config.url = configOrUrl;\n  } else {\n    config = configOrUrl || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean),\n      forcedJSONParsing: validators.transitional(validators.boolean),\n      clarifyTimeoutError: validators.transitional(validators.boolean)\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  var fullPath = buildFullPath(config.baseURL, config.url);\n  return buildURL(fullPath, config.params, config.paramsSerializer);\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method: method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url: url,\n        data: data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nmodule.exports = Axios;\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/core/Axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosError.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosError.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\n\nvar prototype = AxiosError.prototype;\nvar descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED'\n// eslint-disable-next-line func-names\n].forEach(function(code) {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = function(error, code, config, request, response, customProps) {\n  var axiosError = Object.create(prototype);\n\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\nmodule.exports = AxiosError;\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/core/AxiosError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/core/InterceptorManager.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \"./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \"./node_modules/axios/lib/helpers/combineURLs.js\");\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/core/buildFullPath.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults/index.js\");\nvar CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ \"./node_modules/axios/lib/cancel/CanceledError.js\");\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/core/dispatchRequest.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  var mergeMap = {\n    'url': valueFromConfig2,\n    'method': valueFromConfig2,\n    'data': valueFromConfig2,\n    'baseURL': defaultToConfig2,\n    'transformRequest': defaultToConfig2,\n    'transformResponse': defaultToConfig2,\n    'paramsSerializer': defaultToConfig2,\n    'timeout': defaultToConfig2,\n    'timeoutMessage': defaultToConfig2,\n    'withCredentials': defaultToConfig2,\n    'adapter': defaultToConfig2,\n    'responseType': defaultToConfig2,\n    'xsrfCookieName': defaultToConfig2,\n    'xsrfHeaderName': defaultToConfig2,\n    'onUploadProgress': defaultToConfig2,\n    'onDownloadProgress': defaultToConfig2,\n    'decompress': defaultToConfig2,\n    'maxContentLength': defaultToConfig2,\n    'maxBodyLength': defaultToConfig2,\n    'beforeRedirect': defaultToConfig2,\n    'transport': defaultToConfig2,\n    'httpAgent': defaultToConfig2,\n    'httpsAgent': defaultToConfig2,\n    'cancelToken': defaultToConfig2,\n    'socketPath': defaultToConfig2,\n    'responseEncoding': defaultToConfig2,\n    'validateStatus': mergeDirectKeys\n  };\n\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/core/mergeConfig.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar AxiosError = __webpack_require__(/*! ./AxiosError */ \"./node_modules/axios/lib/core/AxiosError.js\");\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/core/settle.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults/index.js\");\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/core/transformData.js?");

/***/ }),

/***/ "./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ../helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\nvar AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./node_modules/axios/lib/core/AxiosError.js\");\nvar transitionalDefaults = __webpack_require__(/*! ./transitional */ \"./node_modules/axios/lib/defaults/transitional.js\");\nvar toFormData = __webpack_require__(/*! ../helpers/toFormData */ \"./node_modules/axios/lib/helpers/toFormData.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ../adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ../adapters/http */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n\n    var isObjectPayload = utils.isObject(data);\n    var contentType = headers && headers['Content-Type'];\n\n    var isFileList;\n\n    if ((isFileList = utils.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {\n      var _FormData = this.env && this.env.FormData;\n      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());\n    } else if (isObjectPayload || contentType === 'application/json') {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: __webpack_require__(/*! ./env/FormData */ \"./node_modules/axios/lib/helpers/null.js\")\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/defaults/index.js?");

/***/ }),

/***/ "./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/defaults/transitional.js?");

/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ (function(module) {

eval("module.exports = {\n  \"version\": \"0.27.2\"\n};\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/env/data.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/bind.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/buildURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ (function(module) {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/combineURLs.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/cookies.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ (function(module) {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/isAbsoluteURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/isAxiosError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/isURLSameOrigin.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/normalizeHeaderName.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/null.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/null.js ***!
  \************************************************/
/***/ (function(module) {

eval("// eslint-disable-next-line strict\nmodule.exports = null;\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/null.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/parseHeaders.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseProtocol.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*********************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = function parseProtocol(url) {\n  var match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/parseProtocol.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ (function(module) {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/spread.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/toFormData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toFormData.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Convert a data object to FormData\n * @param {Object} obj\n * @param {?Object} [formData]\n * @returns {Object}\n **/\n\nfunction toFormData(obj, formData) {\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new FormData();\n\n  var stack = [];\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  function build(data, parentKey) {\n    if (utils.isPlainObject(data) || utils.isArray(data)) {\n      if (stack.indexOf(data) !== -1) {\n        throw Error('Circular reference detected in ' + parentKey);\n      }\n\n      stack.push(data);\n\n      utils.forEach(data, function each(value, key) {\n        if (utils.isUndefined(value)) return;\n        var fullKey = parentKey ? parentKey + '.' + key : key;\n        var arr;\n\n        if (value && !parentKey && typeof value === 'object') {\n          if (utils.endsWith(key, '{}')) {\n            // eslint-disable-next-line no-param-reassign\n            value = JSON.stringify(value);\n          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {\n            // eslint-disable-next-line func-names\n            arr.forEach(function(el) {\n              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));\n            });\n            return;\n          }\n        }\n\n        build(value, fullKey);\n      });\n\n      stack.pop();\n    } else {\n      formData.append(parentKey, convertValue(data));\n    }\n  }\n\n  build(obj);\n\n  return formData;\n}\n\nmodule.exports = toFormData;\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/toFormData.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar VERSION = (__webpack_require__(/*! ../env/data */ \"./node_modules/axios/lib/env/data.js\").version);\nvar AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./node_modules/axios/lib/core/AxiosError.js\");\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nmodule.exports = {\n  assertOptions: assertOptions,\n  validators: validators\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/helpers/validator.js?");

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n// eslint-disable-next-line func-names\nvar kindOf = (function(cache) {\n  // eslint-disable-next-line func-names\n  return function(thing) {\n    var str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n  };\n})(Object.create(null));\n\nfunction kindOfTest(type) {\n  type = type.toLowerCase();\n  return function isKindOf(thing) {\n    return kindOf(thing) === type;\n  };\n}\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nvar isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nvar isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nvar isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nvar isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nvar isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} thing The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(thing) {\n  var pattern = '[object FormData]';\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) ||\n    toString.call(thing) === pattern ||\n    (isFunction(thing.toString) && thing.toString() === pattern)\n  );\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nvar isURLSearchParams = kindOfTest('URLSearchParams');\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n */\n\nfunction inherits(constructor, superConstructor, props, descriptors) {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function} [filter]\n * @returns {Object}\n */\n\nfunction toFlatObject(sourceObj, destObj, filter) {\n  var props;\n  var i;\n  var prop;\n  var merged = {};\n\n  destObj = destObj || {};\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if (!merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = Object.getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/*\n * determines whether a string ends with the characters of a specified string\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n * @returns {boolean}\n */\nfunction endsWith(str, searchString, position) {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  var lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object\n * @param {*} [thing]\n * @returns {Array}\n */\nfunction toArray(thing) {\n  if (!thing) return null;\n  var i = thing.length;\n  if (isUndefined(i)) return null;\n  var arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n// eslint-disable-next-line func-names\nvar isTypedArray = (function(TypedArray) {\n  // eslint-disable-next-line func-names\n  return function(thing) {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM,\n  inherits: inherits,\n  toFlatObject: toFlatObject,\n  kindOf: kindOf,\n  kindOfTest: kindOfTest,\n  endsWith: endsWith,\n  toArray: toArray,\n  isTypedArray: isTypedArray,\n  isFileList: isFileList\n};\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/axios/lib/utils.js?");

/***/ }),

/***/ "./node_modules/dijkstrajs/dijkstra.js":
/*!*********************************************!*\
  !*** ./node_modules/dijkstrajs/dijkstra.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";
eval("\n\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\nvar dijkstra = {\n  single_source_shortest_paths: function(graph, s, d) {\n    // Predecessor map for each node that has been encountered.\n    // node ID => predecessor node ID\n    var predecessors = {};\n\n    // Costs of shortest paths from s to all nodes encountered.\n    // node ID => cost\n    var costs = {};\n    costs[s] = 0;\n\n    // Costs of shortest paths from s to all nodes encountered; differs from\n    // `costs` in that it provides easy access to the node that currently has\n    // the known shortest path from s.\n    // XXX: Do we actually need both `costs` and `open`?\n    var open = dijkstra.PriorityQueue.make();\n    open.push(s, 0);\n\n    var closest,\n        u, v,\n        cost_of_s_to_u,\n        adjacent_nodes,\n        cost_of_e,\n        cost_of_s_to_u_plus_cost_of_e,\n        cost_of_s_to_v,\n        first_visit;\n    while (!open.empty()) {\n      // In the nodes remaining in graph that have a known cost from s,\n      // find the node, u, that currently has the shortest path from s.\n      closest = open.pop();\n      u = closest.value;\n      cost_of_s_to_u = closest.cost;\n\n      // Get nodes adjacent to u...\n      adjacent_nodes = graph[u] || {};\n\n      // ...and explore the edges that connect u to those nodes, updating\n      // the cost of the shortest paths to any or all of those nodes as\n      // necessary. v is the node across the current edge from u.\n      for (v in adjacent_nodes) {\n        if (adjacent_nodes.hasOwnProperty(v)) {\n          // Get the cost of the edge running from u to v.\n          cost_of_e = adjacent_nodes[v];\n\n          // Cost of s to u plus the cost of u to v across e--this is *a*\n          // cost from s to v that may or may not be less than the current\n          // known cost to v.\n          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n          // If we haven't visited v yet OR if the current known cost from s to\n          // v is greater than the new cost we just found (cost of s to u plus\n          // cost of u to v across e), update v's cost in the cost list and\n          // update v's predecessor in the predecessor list (it's now u).\n          cost_of_s_to_v = costs[v];\n          first_visit = (typeof costs[v] === 'undefined');\n          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n            costs[v] = cost_of_s_to_u_plus_cost_of_e;\n            open.push(v, cost_of_s_to_u_plus_cost_of_e);\n            predecessors[v] = u;\n          }\n        }\n      }\n    }\n\n    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {\n      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n      throw new Error(msg);\n    }\n\n    return predecessors;\n  },\n\n  extract_shortest_path_from_predecessor_list: function(predecessors, d) {\n    var nodes = [];\n    var u = d;\n    var predecessor;\n    while (u) {\n      nodes.push(u);\n      predecessor = predecessors[u];\n      u = predecessors[u];\n    }\n    nodes.reverse();\n    return nodes;\n  },\n\n  find_path: function(graph, s, d) {\n    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n    return dijkstra.extract_shortest_path_from_predecessor_list(\n      predecessors, d);\n  },\n\n  /**\n   * A very naive priority queue implementation.\n   */\n  PriorityQueue: {\n    make: function (opts) {\n      var T = dijkstra.PriorityQueue,\n          t = {},\n          key;\n      opts = opts || {};\n      for (key in T) {\n        if (T.hasOwnProperty(key)) {\n          t[key] = T[key];\n        }\n      }\n      t.queue = [];\n      t.sorter = opts.sorter || T.default_sorter;\n      return t;\n    },\n\n    default_sorter: function (a, b) {\n      return a.cost - b.cost;\n    },\n\n    /**\n     * Add a new item to the queue and ensure the highest priority element\n     * is at the front of the queue.\n     */\n    push: function (value, cost) {\n      var item = {value: value, cost: cost};\n      this.queue.push(item);\n      this.queue.sort(this.sorter);\n    },\n\n    /**\n     * Return the highest priority element in the queue.\n     */\n    pop: function () {\n      return this.queue.shift();\n    },\n\n    empty: function () {\n      return this.queue.length === 0;\n    }\n  }\n};\n\n\n// node.js module exports\nif (true) {\n  module.exports = dijkstra;\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/dijkstrajs/dijkstra.js?");

/***/ }),

/***/ "./node_modules/encode-utf8/index.js":
/*!*******************************************!*\
  !*** ./node_modules/encode-utf8/index.js ***!
  \*******************************************/
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = function encodeUtf8 (input) {\n  var result = []\n  var size = input.length\n\n  for (var index = 0; index < size; index++) {\n    var point = input.charCodeAt(index)\n\n    if (point >= 0xD800 && point <= 0xDBFF && size > index + 1) {\n      var second = input.charCodeAt(index + 1)\n\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        point = (point - 0xD800) * 0x400 + second - 0xDC00 + 0x10000\n        index += 1\n      }\n    }\n\n    // US-ASCII\n    if (point < 0x80) {\n      result.push(point)\n      continue\n    }\n\n    // 2-byte UTF-8\n    if (point < 0x800) {\n      result.push((point >> 6) | 192)\n      result.push((point & 63) | 128)\n      continue\n    }\n\n    // 3-byte UTF-8\n    if (point < 0xD800 || (point >= 0xE000 && point < 0x10000)) {\n      result.push((point >> 12) | 224)\n      result.push(((point >> 6) & 63) | 128)\n      result.push((point & 63) | 128)\n      continue\n    }\n\n    // 4-byte UTF-8\n    if (point >= 0x10000 && point <= 0x10FFFF) {\n      result.push((point >> 18) | 240)\n      result.push(((point >> 12) & 63) | 128)\n      result.push(((point >> 6) & 63) | 128)\n      result.push((point & 63) | 128)\n      continue\n    }\n\n    // Invalid character\n    result.push(0xEF, 0xBF, 0xBD)\n  }\n\n  return new Uint8Array(result).buffer\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/encode-utf8/index.js?");

/***/ }),

/***/ "./node_modules/peerjs/dist/peerjs.min.js":
/*!************************************************!*\
  !*** ./node_modules/peerjs/dist/peerjs.min.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("parcelRequire=function(e,r,t,n){var i,o=\"function\"==typeof parcelRequire&&parcelRequire,u=undefined;function f(t,n){if(!r[t]){if(!e[t]){var i=\"function\"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if( true&&\"string\"==typeof t)return __webpack_require__(\"./node_modules/peerjs/dist sync recursive\")(t);var c=new Error(\"Cannot find module '\"+t+\"'\");throw c.code=\"MODULE_NOT_FOUND\",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]); true?module.exports=l:0}if(parcelRequire=f,i)throw i;return f}({\"EgBh\":[function(require,module,exports) {\nvar e={};e.useBlobBuilder=function(){try{return new Blob([]),!1}catch(e){return!0}}(),e.useArrayBufferView=!e.useBlobBuilder&&function(){try{return 0===new Blob([new Uint8Array([])]).size}catch(e){return!0}}(),module.exports.binaryFeatures=e;var r=module.exports.BlobBuilder;function t(){this._pieces=[],this._parts=[]}\"undefined\"!=typeof window&&(r=module.exports.BlobBuilder=window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder||window.BlobBuilder),t.prototype.append=function(e){\"number\"==typeof e?this._pieces.push(e):(this.flush(),this._parts.push(e))},t.prototype.flush=function(){if(this._pieces.length>0){var r=new Uint8Array(this._pieces);e.useArrayBufferView||(r=r.buffer),this._parts.push(r),this._pieces=[]}},t.prototype.getBuffer=function(){if(this.flush(),e.useBlobBuilder){for(var t=new r,i=0,u=this._parts.length;i<u;i++)t.append(this._parts[i]);return t.getBlob()}return new Blob(this._parts)},module.exports.BufferBuilder=t;\n},{}],\"kdPp\":[function(require,module,exports) {\nvar t=require(\"./bufferbuilder\").BufferBuilder,e=require(\"./bufferbuilder\").binaryFeatures,i={unpack:function(t){return new r(t).unpack()},pack:function(t){var e=new n;return e.pack(t),e.getBuffer()}};function r(t){this.index=0,this.dataBuffer=t,this.dataView=new Uint8Array(this.dataBuffer),this.length=this.dataBuffer.byteLength}function n(){this.bufferBuilder=new t}function u(t){var e=t.charCodeAt(0);return e<=2047?\"00\":e<=65535?\"000\":e<=2097151?\"0000\":e<=67108863?\"00000\":\"000000\"}function a(t){return t.length>600?new Blob([t]).size:t.replace(/[^\\u0000-\\u007F]/g,u).length}module.exports=i,r.prototype.unpack=function(){var t,e=this.unpack_uint8();if(e<128)return e;if((224^e)<32)return(224^e)-32;if((t=160^e)<=15)return this.unpack_raw(t);if((t=176^e)<=15)return this.unpack_string(t);if((t=144^e)<=15)return this.unpack_array(t);if((t=128^e)<=15)return this.unpack_map(t);switch(e){case 192:return null;case 193:return;case 194:return!1;case 195:return!0;case 202:return this.unpack_float();case 203:return this.unpack_double();case 204:return this.unpack_uint8();case 205:return this.unpack_uint16();case 206:return this.unpack_uint32();case 207:return this.unpack_uint64();case 208:return this.unpack_int8();case 209:return this.unpack_int16();case 210:return this.unpack_int32();case 211:return this.unpack_int64();case 212:case 213:case 214:case 215:return;case 216:return t=this.unpack_uint16(),this.unpack_string(t);case 217:return t=this.unpack_uint32(),this.unpack_string(t);case 218:return t=this.unpack_uint16(),this.unpack_raw(t);case 219:return t=this.unpack_uint32(),this.unpack_raw(t);case 220:return t=this.unpack_uint16(),this.unpack_array(t);case 221:return t=this.unpack_uint32(),this.unpack_array(t);case 222:return t=this.unpack_uint16(),this.unpack_map(t);case 223:return t=this.unpack_uint32(),this.unpack_map(t)}},r.prototype.unpack_uint8=function(){var t=255&this.dataView[this.index];return this.index++,t},r.prototype.unpack_uint16=function(){var t=this.read(2),e=256*(255&t[0])+(255&t[1]);return this.index+=2,e},r.prototype.unpack_uint32=function(){var t=this.read(4),e=256*(256*(256*t[0]+t[1])+t[2])+t[3];return this.index+=4,e},r.prototype.unpack_uint64=function(){var t=this.read(8),e=256*(256*(256*(256*(256*(256*(256*t[0]+t[1])+t[2])+t[3])+t[4])+t[5])+t[6])+t[7];return this.index+=8,e},r.prototype.unpack_int8=function(){var t=this.unpack_uint8();return t<128?t:t-256},r.prototype.unpack_int16=function(){var t=this.unpack_uint16();return t<32768?t:t-65536},r.prototype.unpack_int32=function(){var t=this.unpack_uint32();return t<Math.pow(2,31)?t:t-Math.pow(2,32)},r.prototype.unpack_int64=function(){var t=this.unpack_uint64();return t<Math.pow(2,63)?t:t-Math.pow(2,64)},r.prototype.unpack_raw=function(t){if(this.length<this.index+t)throw new Error(\"BinaryPackFailure: index is out of range \"+this.index+\" \"+t+\" \"+this.length);var e=this.dataBuffer.slice(this.index,this.index+t);return this.index+=t,e},r.prototype.unpack_string=function(t){for(var e,i,r=this.read(t),n=0,u=\"\";n<t;)(e=r[n])<128?(u+=String.fromCharCode(e),n++):(192^e)<32?(i=(192^e)<<6|63&r[n+1],u+=String.fromCharCode(i),n+=2):(i=(15&e)<<12|(63&r[n+1])<<6|63&r[n+2],u+=String.fromCharCode(i),n+=3);return this.index+=t,u},r.prototype.unpack_array=function(t){for(var e=new Array(t),i=0;i<t;i++)e[i]=this.unpack();return e},r.prototype.unpack_map=function(t){for(var e={},i=0;i<t;i++){var r=this.unpack(),n=this.unpack();e[r]=n}return e},r.prototype.unpack_float=function(){var t=this.unpack_uint32(),e=(t>>23&255)-127;return(0===t>>31?1:-1)*(8388607&t|8388608)*Math.pow(2,e-23)},r.prototype.unpack_double=function(){var t=this.unpack_uint32(),e=this.unpack_uint32(),i=(t>>20&2047)-1023;return(0===t>>31?1:-1)*((1048575&t|1048576)*Math.pow(2,i-20)+e*Math.pow(2,i-52))},r.prototype.read=function(t){var e=this.index;if(e+t<=this.length)return this.dataView.subarray(e,e+t);throw new Error(\"BinaryPackFailure: read index out of range\")},n.prototype.getBuffer=function(){return this.bufferBuilder.getBuffer()},n.prototype.pack=function(t){var i=typeof t;if(\"string\"===i)this.pack_string(t);else if(\"number\"===i)Math.floor(t)===t?this.pack_integer(t):this.pack_double(t);else if(\"boolean\"===i)!0===t?this.bufferBuilder.append(195):!1===t&&this.bufferBuilder.append(194);else if(\"undefined\"===i)this.bufferBuilder.append(192);else{if(\"object\"!==i)throw new Error('Type \"'+i+'\" not yet supported');if(null===t)this.bufferBuilder.append(192);else{var r=t.constructor;if(r==Array)this.pack_array(t);else if(r==Blob||r==File||t instanceof Blob||t instanceof File)this.pack_bin(t);else if(r==ArrayBuffer)e.useArrayBufferView?this.pack_bin(new Uint8Array(t)):this.pack_bin(t);else if(\"BYTES_PER_ELEMENT\"in t)e.useArrayBufferView?this.pack_bin(new Uint8Array(t.buffer)):this.pack_bin(t.buffer);else if(r==Object||r.toString().startsWith(\"class\"))this.pack_object(t);else if(r==Date)this.pack_string(t.toString());else{if(\"function\"!=typeof t.toBinaryPack)throw new Error('Type \"'+r.toString()+'\" not yet supported');this.bufferBuilder.append(t.toBinaryPack())}}}this.bufferBuilder.flush()},n.prototype.pack_bin=function(t){var e=t.length||t.byteLength||t.size;if(e<=15)this.pack_uint8(160+e);else if(e<=65535)this.bufferBuilder.append(218),this.pack_uint16(e);else{if(!(e<=4294967295))throw new Error(\"Invalid length\");this.bufferBuilder.append(219),this.pack_uint32(e)}this.bufferBuilder.append(t)},n.prototype.pack_string=function(t){var e=a(t);if(e<=15)this.pack_uint8(176+e);else if(e<=65535)this.bufferBuilder.append(216),this.pack_uint16(e);else{if(!(e<=4294967295))throw new Error(\"Invalid length\");this.bufferBuilder.append(217),this.pack_uint32(e)}this.bufferBuilder.append(t)},n.prototype.pack_array=function(t){var e=t.length;if(e<=15)this.pack_uint8(144+e);else if(e<=65535)this.bufferBuilder.append(220),this.pack_uint16(e);else{if(!(e<=4294967295))throw new Error(\"Invalid length\");this.bufferBuilder.append(221),this.pack_uint32(e)}for(var i=0;i<e;i++)this.pack(t[i])},n.prototype.pack_integer=function(t){if(t>=-32&&t<=127)this.bufferBuilder.append(255&t);else if(t>=0&&t<=255)this.bufferBuilder.append(204),this.pack_uint8(t);else if(t>=-128&&t<=127)this.bufferBuilder.append(208),this.pack_int8(t);else if(t>=0&&t<=65535)this.bufferBuilder.append(205),this.pack_uint16(t);else if(t>=-32768&&t<=32767)this.bufferBuilder.append(209),this.pack_int16(t);else if(t>=0&&t<=4294967295)this.bufferBuilder.append(206),this.pack_uint32(t);else if(t>=-2147483648&&t<=2147483647)this.bufferBuilder.append(210),this.pack_int32(t);else if(t>=-0x8000000000000000&&t<=0x8000000000000000)this.bufferBuilder.append(211),this.pack_int64(t);else{if(!(t>=0&&t<=0x10000000000000000))throw new Error(\"Invalid integer\");this.bufferBuilder.append(207),this.pack_uint64(t)}},n.prototype.pack_double=function(t){var e=0;t<0&&(e=1,t=-t);var i=Math.floor(Math.log(t)/Math.LN2),r=t/Math.pow(2,i)-1,n=Math.floor(r*Math.pow(2,52)),u=Math.pow(2,32),a=e<<31|i+1023<<20|n/u&1048575,p=n%u;this.bufferBuilder.append(203),this.pack_int32(a),this.pack_int32(p)},n.prototype.pack_object=function(t){var e=Object.keys(t).length;if(e<=15)this.pack_uint8(128+e);else if(e<=65535)this.bufferBuilder.append(222),this.pack_uint16(e);else{if(!(e<=4294967295))throw new Error(\"Invalid length\");this.bufferBuilder.append(223),this.pack_uint32(e)}for(var i in t)t.hasOwnProperty(i)&&(this.pack(i),this.pack(t[i]))},n.prototype.pack_uint8=function(t){this.bufferBuilder.append(t)},n.prototype.pack_uint16=function(t){this.bufferBuilder.append(t>>8),this.bufferBuilder.append(255&t)},n.prototype.pack_uint32=function(t){var e=4294967295&t;this.bufferBuilder.append((4278190080&e)>>>24),this.bufferBuilder.append((16711680&e)>>>16),this.bufferBuilder.append((65280&e)>>>8),this.bufferBuilder.append(255&e)},n.prototype.pack_uint64=function(t){var e=t/Math.pow(2,32),i=t%Math.pow(2,32);this.bufferBuilder.append((4278190080&e)>>>24),this.bufferBuilder.append((16711680&e)>>>16),this.bufferBuilder.append((65280&e)>>>8),this.bufferBuilder.append(255&e),this.bufferBuilder.append((4278190080&i)>>>24),this.bufferBuilder.append((16711680&i)>>>16),this.bufferBuilder.append((65280&i)>>>8),this.bufferBuilder.append(255&i)},n.prototype.pack_int8=function(t){this.bufferBuilder.append(255&t)},n.prototype.pack_int16=function(t){this.bufferBuilder.append((65280&t)>>8),this.bufferBuilder.append(255&t)},n.prototype.pack_int32=function(t){this.bufferBuilder.append(t>>>24&255),this.bufferBuilder.append((16711680&t)>>>16),this.bufferBuilder.append((65280&t)>>>8),this.bufferBuilder.append(255&t)},n.prototype.pack_int64=function(t){var e=Math.floor(t/Math.pow(2,32)),i=t%Math.pow(2,32);this.bufferBuilder.append((4278190080&e)>>>24),this.bufferBuilder.append((16711680&e)>>>16),this.bufferBuilder.append((65280&e)>>>8),this.bufferBuilder.append(255&e),this.bufferBuilder.append((4278190080&i)>>>24),this.bufferBuilder.append((16711680&i)>>>16),this.bufferBuilder.append((65280&i)>>>8),this.bufferBuilder.append(255&i)};\n},{\"./bufferbuilder\":\"EgBh\"}],\"iSxC\":[function(require,module,exports) {\n\"use strict\";function e(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function t(e){return(t=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.extractVersion=o,exports.wrapPeerConnectionEvent=i,exports.disableLog=s,exports.disableWarnings=a,exports.log=p,exports.deprecated=u,exports.detectBrowser=c,exports.compactObject=f,exports.walkStats=l,exports.filterStats=v;var n=!0,r=!0;function o(e,t,n){var r=e.match(t);return r&&r.length>=n&&parseInt(r[n],10)}function i(e,t,n){if(e.RTCPeerConnection){var r=e.RTCPeerConnection.prototype,o=r.addEventListener;r.addEventListener=function(e,r){if(e!==t)return o.apply(this,arguments);var i=function(e){var t=n(e);t&&(r.handleEvent?r.handleEvent(t):r(t))};return this._eventMap=this._eventMap||{},this._eventMap[t]||(this._eventMap[t]=new Map),this._eventMap[t].set(r,i),o.apply(this,[e,i])};var i=r.removeEventListener;r.removeEventListener=function(e,n){if(e!==t||!this._eventMap||!this._eventMap[t])return i.apply(this,arguments);if(!this._eventMap[t].has(n))return i.apply(this,arguments);var r=this._eventMap[t].get(n);return this._eventMap[t].delete(n),0===this._eventMap[t].size&&delete this._eventMap[t],0===Object.keys(this._eventMap).length&&delete this._eventMap,i.apply(this,[e,r])},Object.defineProperty(r,\"on\"+t,{get:function(){return this[\"_on\"+t]},set:function(e){this[\"_on\"+t]&&(this.removeEventListener(t,this[\"_on\"+t]),delete this[\"_on\"+t]),e&&this.addEventListener(t,this[\"_on\"+t]=e)},enumerable:!0,configurable:!0})}}function s(e){return\"boolean\"!=typeof e?new Error(\"Argument type: \"+t(e)+\". Please use a boolean.\"):(n=e,e?\"adapter.js logging disabled\":\"adapter.js logging enabled\")}function a(e){return\"boolean\"!=typeof e?new Error(\"Argument type: \"+t(e)+\". Please use a boolean.\"):(r=!e,\"adapter.js deprecation warnings \"+(e?\"disabled\":\"enabled\"))}function p(){if(\"object\"===(\"undefined\"==typeof window?\"undefined\":t(window))){if(n)return;\"undefined\"!=typeof console&&\"function\"==typeof console.log&&console.log.apply(console,arguments)}}function u(e,t){r&&console.warn(e+\" is deprecated, please use \"+t+\" instead.\")}function c(e){var t={browser:null,version:null};if(void 0===e||!e.navigator)return t.browser=\"Not a browser.\",t;var{navigator:n}=e;if(n.mozGetUserMedia)t.browser=\"firefox\",t.version=o(n.userAgent,/Firefox\\/(\\d+)\\./,1);else if(n.webkitGetUserMedia||!1===e.isSecureContext&&e.webkitRTCPeerConnection&&!e.RTCIceGatherer)t.browser=\"chrome\",t.version=o(n.userAgent,/Chrom(e|ium)\\/(\\d+)\\./,2);else if(n.mediaDevices&&n.userAgent.match(/Edge\\/(\\d+).(\\d+)$/))t.browser=\"edge\",t.version=o(n.userAgent,/Edge\\/(\\d+).(\\d+)$/,2);else{if(!e.RTCPeerConnection||!n.userAgent.match(/AppleWebKit\\/(\\d+)\\./))return t.browser=\"Not a supported browser.\",t;t.browser=\"safari\",t.version=o(n.userAgent,/AppleWebKit\\/(\\d+)\\./,1),t.supportsUnifiedPlan=e.RTCRtpTransceiver&&\"currentDirection\"in e.RTCRtpTransceiver.prototype}return t}function d(e){return\"[object Object]\"===Object.prototype.toString.call(e)}function f(t){return d(t)?Object.keys(t).reduce(function(n,r){var o=d(t[r]),i=o?f(t[r]):t[r],s=o&&!Object.keys(i).length;return void 0===i||s?n:Object.assign(n,e({},r,i))},{}):t}function l(e,t,n){t&&!n.has(t.id)&&(n.set(t.id,t),Object.keys(t).forEach(function(r){r.endsWith(\"Id\")?l(e,e.get(t[r]),n):r.endsWith(\"Ids\")&&t[r].forEach(function(t){l(e,e.get(t),n)})}))}function v(e,t,n){var r=n?\"outbound-rtp\":\"inbound-rtp\",o=new Map;if(null===t)return o;var i=[];return e.forEach(function(e){\"track\"===e.type&&e.trackIdentifier===t.id&&i.push(e)}),i.forEach(function(t){e.forEach(function(n){n.type===r&&n.trackId===t.id&&l(e,n,o)})}),o}\n},{}],\"s6SN\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetUserMedia=i;var e=t(require(\"../utils.js\"));function r(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return r=function(){return e},e}function t(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=r();if(t&&t.has(e))return t.get(e);var o={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=n?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(o,i,a):o[i]=e[i]}return o.default=e,t&&t.set(e,o),o}function o(e){return(o=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}var n=e.log;function i(e,r){var t=e&&e.navigator;if(t.mediaDevices){var i=function(e){if(\"object\"!==o(e)||e.mandatory||e.optional)return e;var r={};return Object.keys(e).forEach(function(t){if(\"require\"!==t&&\"advanced\"!==t&&\"mediaSource\"!==t){var n=\"object\"===o(e[t])?e[t]:{ideal:e[t]};void 0!==n.exact&&\"number\"==typeof n.exact&&(n.min=n.max=n.exact);var i=function(e,r){return e?e+r.charAt(0).toUpperCase()+r.slice(1):\"deviceId\"===r?\"sourceId\":r};if(void 0!==n.ideal){r.optional=r.optional||[];var a={};\"number\"==typeof n.ideal?(a[i(\"min\",t)]=n.ideal,r.optional.push(a),(a={})[i(\"max\",t)]=n.ideal,r.optional.push(a)):(a[i(\"\",t)]=n.ideal,r.optional.push(a))}void 0!==n.exact&&\"number\"!=typeof n.exact?(r.mandatory=r.mandatory||{},r.mandatory[i(\"\",t)]=n.exact):[\"min\",\"max\"].forEach(function(e){void 0!==n[e]&&(r.mandatory=r.mandatory||{},r.mandatory[i(e,t)]=n[e])})}}),e.advanced&&(r.optional=(r.optional||[]).concat(e.advanced)),r},a=function(e,a){if(r.version>=61)return a(e);if((e=JSON.parse(JSON.stringify(e)))&&\"object\"===o(e.audio)){var c=function(e,r,t){r in e&&!(t in e)&&(e[t]=e[r],delete e[r])};c((e=JSON.parse(JSON.stringify(e))).audio,\"autoGainControl\",\"googAutoGainControl\"),c(e.audio,\"noiseSuppression\",\"googNoiseSuppression\"),e.audio=i(e.audio)}if(e&&\"object\"===o(e.video)){var d=e.video.facingMode;d=d&&(\"object\"===o(d)?d:{ideal:d});var u,s=r.version<66;if(d&&(\"user\"===d.exact||\"environment\"===d.exact||\"user\"===d.ideal||\"environment\"===d.ideal)&&(!t.mediaDevices.getSupportedConstraints||!t.mediaDevices.getSupportedConstraints().facingMode||s))if(delete e.video.facingMode,\"environment\"===d.exact||\"environment\"===d.ideal?u=[\"back\",\"rear\"]:\"user\"!==d.exact&&\"user\"!==d.ideal||(u=[\"front\"]),u)return t.mediaDevices.enumerateDevices().then(function(r){var t=(r=r.filter(function(e){return\"videoinput\"===e.kind})).find(function(e){return u.some(function(r){return e.label.toLowerCase().includes(r)})});return!t&&r.length&&u.includes(\"back\")&&(t=r[r.length-1]),t&&(e.video.deviceId=d.exact?{exact:t.deviceId}:{ideal:t.deviceId}),e.video=i(e.video),n(\"chrome: \"+JSON.stringify(e)),a(e)});e.video=i(e.video)}return n(\"chrome: \"+JSON.stringify(e)),a(e)},c=function(e){return r.version>=64?e:{name:{PermissionDeniedError:\"NotAllowedError\",PermissionDismissedError:\"NotAllowedError\",InvalidStateError:\"NotAllowedError\",DevicesNotFoundError:\"NotFoundError\",ConstraintNotSatisfiedError:\"OverconstrainedError\",TrackStartError:\"NotReadableError\",MediaDeviceFailedDueToShutdown:\"NotAllowedError\",MediaDeviceKillSwitchOn:\"NotAllowedError\",TabCaptureError:\"AbortError\",ScreenCaptureError:\"AbortError\",DeviceCaptureError:\"AbortError\"}[e.name]||e.name,message:e.message,constraint:e.constraint||e.constraintName,toString:function(){return this.name+(this.message&&\": \")+this.message}}};if(t.getUserMedia=function(e,r,o){a(e,function(e){t.webkitGetUserMedia(e,r,function(e){o&&o(c(e))})})}.bind(t),t.mediaDevices.getUserMedia){var d=t.mediaDevices.getUserMedia.bind(t.mediaDevices);t.mediaDevices.getUserMedia=function(e){return a(e,function(e){return d(e).then(function(r){if(e.audio&&!r.getAudioTracks().length||e.video&&!r.getVideoTracks().length)throw r.getTracks().forEach(function(e){e.stop()}),new DOMException(\"\",\"NotFoundError\");return r},function(e){return Promise.reject(c(e))})})}}}}\n},{\"../utils.js\":\"iSxC\"}],\"VHa8\":[function(require,module,exports) {\n\"use strict\";function e(e,i){e.navigator.mediaDevices&&\"getDisplayMedia\"in e.navigator.mediaDevices||e.navigator.mediaDevices&&(\"function\"==typeof i?e.navigator.mediaDevices.getDisplayMedia=function(a){return i(a).then(function(i){var t=a.video&&a.video.width,o=a.video&&a.video.height,d=a.video&&a.video.frameRate;return a.video={mandatory:{chromeMediaSource:\"desktop\",chromeMediaSourceId:i,maxFrameRate:d||3}},t&&(a.video.mandatory.maxWidth=t),o&&(a.video.mandatory.maxHeight=o),e.navigator.mediaDevices.getUserMedia(a)})}:console.error(\"shimGetDisplayMedia: getSourceId argument is not a function\"))}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetDisplayMedia=e;\n},{}],\"uI5X\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimMediaStream=a,exports.shimOnTrack=c,exports.shimGetSendersWithDtmf=p,exports.shimGetStats=d,exports.shimSenderReceiverGetStats=h,exports.shimAddTrackRemoveTrackWithNative=f,exports.shimAddTrackRemoveTrack=m,exports.shimPeerConnection=u,exports.fixNegotiationNeeded=l,Object.defineProperty(exports,\"shimGetUserMedia\",{enumerable:!0,get:function(){return t.shimGetUserMedia}}),Object.defineProperty(exports,\"shimGetDisplayMedia\",{enumerable:!0,get:function(){return r.shimGetDisplayMedia}});var e=i(require(\"../utils.js\")),t=require(\"./getusermedia\"),r=require(\"./getdisplaymedia\");function n(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return n=function(){return e},e}function i(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=n();if(t&&t.has(e))return t.get(e);var r={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if(Object.prototype.hasOwnProperty.call(e,o)){var s=i?Object.getOwnPropertyDescriptor(e,o):null;s&&(s.get||s.set)?Object.defineProperty(r,o,s):r[o]=e[o]}return r.default=e,t&&t.set(e,r),r}function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e){return(s=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function a(e){e.MediaStream=e.MediaStream||e.webkitMediaStream}function c(t){if(\"object\"!==s(t)||!t.RTCPeerConnection||\"ontrack\"in t.RTCPeerConnection.prototype)e.wrapPeerConnectionEvent(t,\"track\",function(e){return e.transceiver||Object.defineProperty(e,\"transceiver\",{value:{receiver:e.receiver}}),e});else{Object.defineProperty(t.RTCPeerConnection.prototype,\"ontrack\",{get:function(){return this._ontrack},set:function(e){this._ontrack&&this.removeEventListener(\"track\",this._ontrack),this.addEventListener(\"track\",this._ontrack=e)},enumerable:!0,configurable:!0});var r=t.RTCPeerConnection.prototype.setRemoteDescription;t.RTCPeerConnection.prototype.setRemoteDescription=function(){var e=this;return this._ontrackpoly||(this._ontrackpoly=function(r){r.stream.addEventListener(\"addtrack\",function(n){var i;i=t.RTCPeerConnection.prototype.getReceivers?e.getReceivers().find(function(e){return e.track&&e.track.id===n.track.id}):{track:n.track};var o=new Event(\"track\");o.track=n.track,o.receiver=i,o.transceiver={receiver:i},o.streams=[r.stream],e.dispatchEvent(o)}),r.stream.getTracks().forEach(function(n){var i;i=t.RTCPeerConnection.prototype.getReceivers?e.getReceivers().find(function(e){return e.track&&e.track.id===n.id}):{track:n};var o=new Event(\"track\");o.track=n,o.receiver=i,o.transceiver={receiver:i},o.streams=[r.stream],e.dispatchEvent(o)})},this.addEventListener(\"addstream\",this._ontrackpoly)),r.apply(this,arguments)}}}function p(e){if(\"object\"===s(e)&&e.RTCPeerConnection&&!(\"getSenders\"in e.RTCPeerConnection.prototype)&&\"createDTMFSender\"in e.RTCPeerConnection.prototype){var t=function(e,t){return{track:t,get dtmf(){return void 0===this._dtmf&&(\"audio\"===t.kind?this._dtmf=e.createDTMFSender(t):this._dtmf=null),this._dtmf},_pc:e}};if(!e.RTCPeerConnection.prototype.getSenders){e.RTCPeerConnection.prototype.getSenders=function(){return this._senders=this._senders||[],this._senders.slice()};var r=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addTrack=function(e,n){var i=r.apply(this,arguments);return i||(i=t(this,e),this._senders.push(i)),i};var n=e.RTCPeerConnection.prototype.removeTrack;e.RTCPeerConnection.prototype.removeTrack=function(e){n.apply(this,arguments);var t=this._senders.indexOf(e);-1!==t&&this._senders.splice(t,1)}}var i=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(e){var r=this;this._senders=this._senders||[],i.apply(this,[e]),e.getTracks().forEach(function(e){r._senders.push(t(r,e))})};var o=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){var t=this;this._senders=this._senders||[],o.apply(this,[e]),e.getTracks().forEach(function(e){var r=t._senders.find(function(t){return t.track===e});r&&t._senders.splice(t._senders.indexOf(r),1)})}}else if(\"object\"===s(e)&&e.RTCPeerConnection&&\"getSenders\"in e.RTCPeerConnection.prototype&&\"createDTMFSender\"in e.RTCPeerConnection.prototype&&e.RTCRtpSender&&!(\"dtmf\"in e.RTCRtpSender.prototype)){var a=e.RTCPeerConnection.prototype.getSenders;e.RTCPeerConnection.prototype.getSenders=function(){var e=this,t=a.apply(this,[]);return t.forEach(function(t){return t._pc=e}),t},Object.defineProperty(e.RTCRtpSender.prototype,\"dtmf\",{get:function(){return void 0===this._dtmf&&(\"audio\"===this.track.kind?this._dtmf=this._pc.createDTMFSender(this.track):this._dtmf=null),this._dtmf}})}}function d(e){if(e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(){var e=this,[r,n,i]=arguments;if(arguments.length>0&&\"function\"==typeof r)return t.apply(this,arguments);if(0===t.length&&(0===arguments.length||\"function\"!=typeof r))return t.apply(this,[]);var o=function(e){var t={};return e.result().forEach(function(e){var r={id:e.id,timestamp:e.timestamp,type:{localcandidate:\"local-candidate\",remotecandidate:\"remote-candidate\"}[e.type]||e.type};e.names().forEach(function(t){r[t]=e.stat(t)}),t[r.id]=r}),t},s=function(e){return new Map(Object.keys(e).map(function(t){return[t,e[t]]}))};if(arguments.length>=2){return t.apply(this,[function(e){n(s(o(e)))},r])}return new Promise(function(r,n){t.apply(e,[function(e){r(s(o(e)))},n])}).then(n,i)}}}function h(t){if(\"object\"===s(t)&&t.RTCPeerConnection&&t.RTCRtpSender&&t.RTCRtpReceiver){if(!(\"getStats\"in t.RTCRtpSender.prototype)){var r=t.RTCPeerConnection.prototype.getSenders;r&&(t.RTCPeerConnection.prototype.getSenders=function(){var e=this,t=r.apply(this,[]);return t.forEach(function(t){return t._pc=e}),t});var n=t.RTCPeerConnection.prototype.addTrack;n&&(t.RTCPeerConnection.prototype.addTrack=function(){var e=n.apply(this,arguments);return e._pc=this,e}),t.RTCRtpSender.prototype.getStats=function(){var t=this;return this._pc.getStats().then(function(r){return e.filterStats(r,t.track,!0)})}}if(!(\"getStats\"in t.RTCRtpReceiver.prototype)){var i=t.RTCPeerConnection.prototype.getReceivers;i&&(t.RTCPeerConnection.prototype.getReceivers=function(){var e=this,t=i.apply(this,[]);return t.forEach(function(t){return t._pc=e}),t}),e.wrapPeerConnectionEvent(t,\"track\",function(e){return e.receiver._pc=e.srcElement,e}),t.RTCRtpReceiver.prototype.getStats=function(){var t=this;return this._pc.getStats().then(function(r){return e.filterStats(r,t.track,!1)})}}if(\"getStats\"in t.RTCRtpSender.prototype&&\"getStats\"in t.RTCRtpReceiver.prototype){var o=t.RTCPeerConnection.prototype.getStats;t.RTCPeerConnection.prototype.getStats=function(){if(arguments.length>0&&arguments[0]instanceof t.MediaStreamTrack){var e,r,n,i=arguments[0];return this.getSenders().forEach(function(t){t.track===i&&(e?n=!0:e=t)}),this.getReceivers().forEach(function(e){return e.track===i&&(r?n=!0:r=e),e.track===i}),n||e&&r?Promise.reject(new DOMException(\"There are more than one sender or receiver for the track.\",\"InvalidAccessError\")):e?e.getStats():r?r.getStats():Promise.reject(new DOMException(\"There is no sender or receiver for the track.\",\"InvalidAccessError\"))}return o.apply(this,arguments)}}}}function f(e){e.RTCPeerConnection.prototype.getLocalStreams=function(){var e=this;return this._shimmedLocalStreams=this._shimmedLocalStreams||{},Object.keys(this._shimmedLocalStreams).map(function(t){return e._shimmedLocalStreams[t][0]})};var t=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addTrack=function(e,r){if(!r)return t.apply(this,arguments);this._shimmedLocalStreams=this._shimmedLocalStreams||{};var n=t.apply(this,arguments);return this._shimmedLocalStreams[r.id]?-1===this._shimmedLocalStreams[r.id].indexOf(n)&&this._shimmedLocalStreams[r.id].push(n):this._shimmedLocalStreams[r.id]=[r,n],n};var r=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(e){var t=this;this._shimmedLocalStreams=this._shimmedLocalStreams||{},e.getTracks().forEach(function(e){if(t.getSenders().find(function(t){return t.track===e}))throw new DOMException(\"Track already exists.\",\"InvalidAccessError\")});var n=this.getSenders();r.apply(this,arguments);var i=this.getSenders().filter(function(e){return-1===n.indexOf(e)});this._shimmedLocalStreams[e.id]=[e].concat(i)};var n=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},delete this._shimmedLocalStreams[e.id],n.apply(this,arguments)};var i=e.RTCPeerConnection.prototype.removeTrack;e.RTCPeerConnection.prototype.removeTrack=function(e){var t=this;return this._shimmedLocalStreams=this._shimmedLocalStreams||{},e&&Object.keys(this._shimmedLocalStreams).forEach(function(r){var n=t._shimmedLocalStreams[r].indexOf(e);-1!==n&&t._shimmedLocalStreams[r].splice(n,1),1===t._shimmedLocalStreams[r].length&&delete t._shimmedLocalStreams[r]}),i.apply(this,arguments)}}function m(e,t){if(e.RTCPeerConnection){if(e.RTCPeerConnection.prototype.addTrack&&t.version>=65)return f(e);var r=e.RTCPeerConnection.prototype.getLocalStreams;e.RTCPeerConnection.prototype.getLocalStreams=function(){var e=this,t=r.apply(this);return this._reverseStreams=this._reverseStreams||{},t.map(function(t){return e._reverseStreams[t.id]})};var n=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(t){var r=this;if(this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},t.getTracks().forEach(function(e){if(r.getSenders().find(function(t){return t.track===e}))throw new DOMException(\"Track already exists.\",\"InvalidAccessError\")}),!this._reverseStreams[t.id]){var i=new e.MediaStream(t.getTracks());this._streams[t.id]=i,this._reverseStreams[i.id]=t,t=i}n.apply(this,[t])};var i=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},i.apply(this,[this._streams[e.id]||e]),delete this._reverseStreams[this._streams[e.id]?this._streams[e.id].id:e.id],delete this._streams[e.id]},e.RTCPeerConnection.prototype.addTrack=function(t,r){var n=this;if(\"closed\"===this.signalingState)throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\",\"InvalidStateError\");var i=[].slice.call(arguments,1);if(1!==i.length||!i[0].getTracks().find(function(e){return e===t}))throw new DOMException(\"The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.\",\"NotSupportedError\");if(this.getSenders().find(function(e){return e.track===t}))throw new DOMException(\"Track already exists.\",\"InvalidAccessError\");this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{};var o=this._streams[r.id];if(o)o.addTrack(t),Promise.resolve().then(function(){n.dispatchEvent(new Event(\"negotiationneeded\"))});else{var s=new e.MediaStream([t]);this._streams[r.id]=s,this._reverseStreams[s.id]=r,this.addStream(s)}return this.getSenders().find(function(e){return e.track===t})},[\"createOffer\",\"createAnswer\"].forEach(function(t){var r=e.RTCPeerConnection.prototype[t],n=o({},t,function(){var e=this,t=arguments;return arguments.length&&\"function\"==typeof arguments[0]?r.apply(this,[function(r){var n=c(e,r);t[0].apply(null,[n])},function(e){t[1]&&t[1].apply(null,e)},arguments[2]]):r.apply(this,arguments).then(function(t){return c(e,t)})});e.RTCPeerConnection.prototype[t]=n[t]});var s=e.RTCPeerConnection.prototype.setLocalDescription;e.RTCPeerConnection.prototype.setLocalDescription=function(){return arguments.length&&arguments[0].type?(arguments[0]=(e=this,t=arguments[0],r=t.sdp,Object.keys(e._reverseStreams||[]).forEach(function(t){var n=e._reverseStreams[t],i=e._streams[n.id];r=r.replace(new RegExp(n.id,\"g\"),i.id)}),new RTCSessionDescription({type:t.type,sdp:r})),s.apply(this,arguments)):s.apply(this,arguments);var e,t,r};var a=Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype,\"localDescription\");Object.defineProperty(e.RTCPeerConnection.prototype,\"localDescription\",{get:function(){var e=a.get.apply(this);return\"\"===e.type?e:c(this,e)}}),e.RTCPeerConnection.prototype.removeTrack=function(e){var t,r=this;if(\"closed\"===this.signalingState)throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\",\"InvalidStateError\");if(!e._pc)throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\",\"TypeError\");if(!(e._pc===this))throw new DOMException(\"Sender was not created by this connection.\",\"InvalidAccessError\");this._streams=this._streams||{},Object.keys(this._streams).forEach(function(n){r._streams[n].getTracks().find(function(t){return e.track===t})&&(t=r._streams[n])}),t&&(1===t.getTracks().length?this.removeStream(this._reverseStreams[t.id]):t.removeTrack(e.track),this.dispatchEvent(new Event(\"negotiationneeded\")))}}function c(e,t){var r=t.sdp;return Object.keys(e._reverseStreams||[]).forEach(function(t){var n=e._reverseStreams[t],i=e._streams[n.id];r=r.replace(new RegExp(i.id,\"g\"),n.id)}),new RTCSessionDescription({type:t.type,sdp:r})}}function u(e,t){!e.RTCPeerConnection&&e.webkitRTCPeerConnection&&(e.RTCPeerConnection=e.webkitRTCPeerConnection),e.RTCPeerConnection&&t.version<53&&[\"setLocalDescription\",\"setRemoteDescription\",\"addIceCandidate\"].forEach(function(t){var r=e.RTCPeerConnection.prototype[t],n=o({},t,function(){return arguments[0]=new(\"addIceCandidate\"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),r.apply(this,arguments)});e.RTCPeerConnection.prototype[t]=n[t]})}function l(t,r){e.wrapPeerConnectionEvent(t,\"negotiationneeded\",function(e){var t=e.target;if(!(r.version<72||t.getConfiguration&&\"plan-b\"===t.getConfiguration().sdpSemantics)||\"stable\"===t.signalingState)return e})}\n},{\"../utils.js\":\"iSxC\",\"./getusermedia\":\"s6SN\",\"./getdisplaymedia\":\"VHa8\"}],\"NZ1C\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.filterIceServers=n;var r=t(require(\"../utils\"));function e(){if(\"function\"!=typeof WeakMap)return null;var r=new WeakMap;return e=function(){return r},r}function t(r){if(r&&r.__esModule)return r;if(null===r||\"object\"!=typeof r&&\"function\"!=typeof r)return{default:r};var t=e();if(t&&t.has(r))return t.get(r);var n={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in r)if(Object.prototype.hasOwnProperty.call(r,i)){var f=u?Object.getOwnPropertyDescriptor(r,i):null;f&&(f.get||f.set)?Object.defineProperty(n,i,f):n[i]=r[i]}return n.default=r,t&&t.set(r,n),n}function n(e,t){var n=!1;return(e=JSON.parse(JSON.stringify(e))).filter(function(e){if(e&&(e.urls||e.url)){var t=e.urls||e.url;e.url&&!e.urls&&r.deprecated(\"RTCIceServer.url\",\"RTCIceServer.urls\");var u=\"string\"==typeof t;return u&&(t=[t]),t=t.filter(function(r){if(0===r.indexOf(\"stun:\"))return!1;var e=r.startsWith(\"turn\")&&!r.startsWith(\"turn:[\")&&r.includes(\"transport=udp\");return e&&!n?(n=!0,!0):e&&!n}),delete e.url,e.urls=u?t[0]:t,!!t.length}})}\n},{\"../utils\":\"iSxC\"}],\"YHvh\":[function(require,module,exports) {\n\"use strict\";var r={generateIdentifier:function(){return Math.random().toString(36).substr(2,10)}};r.localCName=r.generateIdentifier(),r.splitLines=function(r){return r.trim().split(\"\\n\").map(function(r){return r.trim()})},r.splitSections=function(r){return r.split(\"\\nm=\").map(function(r,e){return(e>0?\"m=\"+r:r).trim()+\"\\r\\n\"})},r.getDescription=function(e){var t=r.splitSections(e);return t&&t[0]},r.getMediaSections=function(e){var t=r.splitSections(e);return t.shift(),t},r.matchPrefix=function(e,t){return r.splitLines(e).filter(function(r){return 0===r.indexOf(t)})},r.parseCandidate=function(r){for(var e,t={foundation:(e=0===r.indexOf(\"a=candidate:\")?r.substring(12).split(\" \"):r.substring(10).split(\" \"))[0],component:parseInt(e[1],10),protocol:e[2].toLowerCase(),priority:parseInt(e[3],10),ip:e[4],address:e[4],port:parseInt(e[5],10),type:e[7]},a=8;a<e.length;a+=2)switch(e[a]){case\"raddr\":t.relatedAddress=e[a+1];break;case\"rport\":t.relatedPort=parseInt(e[a+1],10);break;case\"tcptype\":t.tcpType=e[a+1];break;case\"ufrag\":t.ufrag=e[a+1],t.usernameFragment=e[a+1];break;default:t[e[a]]=e[a+1]}return t},r.writeCandidate=function(r){var e=[];e.push(r.foundation),e.push(r.component),e.push(r.protocol.toUpperCase()),e.push(r.priority),e.push(r.address||r.ip),e.push(r.port);var t=r.type;return e.push(\"typ\"),e.push(t),\"host\"!==t&&r.relatedAddress&&r.relatedPort&&(e.push(\"raddr\"),e.push(r.relatedAddress),e.push(\"rport\"),e.push(r.relatedPort)),r.tcpType&&\"tcp\"===r.protocol.toLowerCase()&&(e.push(\"tcptype\"),e.push(r.tcpType)),(r.usernameFragment||r.ufrag)&&(e.push(\"ufrag\"),e.push(r.usernameFragment||r.ufrag)),\"candidate:\"+e.join(\" \")},r.parseIceOptions=function(r){return r.substr(14).split(\" \")},r.parseRtpMap=function(r){var e=r.substr(9).split(\" \"),t={payloadType:parseInt(e.shift(),10)};return e=e[0].split(\"/\"),t.name=e[0],t.clockRate=parseInt(e[1],10),t.channels=3===e.length?parseInt(e[2],10):1,t.numChannels=t.channels,t},r.writeRtpMap=function(r){var e=r.payloadType;void 0!==r.preferredPayloadType&&(e=r.preferredPayloadType);var t=r.channels||r.numChannels||1;return\"a=rtpmap:\"+e+\" \"+r.name+\"/\"+r.clockRate+(1!==t?\"/\"+t:\"\")+\"\\r\\n\"},r.parseExtmap=function(r){var e=r.substr(9).split(\" \");return{id:parseInt(e[0],10),direction:e[0].indexOf(\"/\")>0?e[0].split(\"/\")[1]:\"sendrecv\",uri:e[1]}},r.writeExtmap=function(r){return\"a=extmap:\"+(r.id||r.preferredId)+(r.direction&&\"sendrecv\"!==r.direction?\"/\"+r.direction:\"\")+\" \"+r.uri+\"\\r\\n\"},r.parseFmtp=function(r){for(var e,t={},a=r.substr(r.indexOf(\" \")+1).split(\";\"),n=0;n<a.length;n++)t[(e=a[n].trim().split(\"=\"))[0].trim()]=e[1];return t},r.writeFmtp=function(r){var e=\"\",t=r.payloadType;if(void 0!==r.preferredPayloadType&&(t=r.preferredPayloadType),r.parameters&&Object.keys(r.parameters).length){var a=[];Object.keys(r.parameters).forEach(function(e){r.parameters[e]?a.push(e+\"=\"+r.parameters[e]):a.push(e)}),e+=\"a=fmtp:\"+t+\" \"+a.join(\";\")+\"\\r\\n\"}return e},r.parseRtcpFb=function(r){var e=r.substr(r.indexOf(\" \")+1).split(\" \");return{type:e.shift(),parameter:e.join(\" \")}},r.writeRtcpFb=function(r){var e=\"\",t=r.payloadType;return void 0!==r.preferredPayloadType&&(t=r.preferredPayloadType),r.rtcpFeedback&&r.rtcpFeedback.length&&r.rtcpFeedback.forEach(function(r){e+=\"a=rtcp-fb:\"+t+\" \"+r.type+(r.parameter&&r.parameter.length?\" \"+r.parameter:\"\")+\"\\r\\n\"}),e},r.parseSsrcMedia=function(r){var e=r.indexOf(\" \"),t={ssrc:parseInt(r.substr(7,e-7),10)},a=r.indexOf(\":\",e);return a>-1?(t.attribute=r.substr(e+1,a-e-1),t.value=r.substr(a+1)):t.attribute=r.substr(e+1),t},r.parseSsrcGroup=function(r){var e=r.substr(13).split(\" \");return{semantics:e.shift(),ssrcs:e.map(function(r){return parseInt(r,10)})}},r.getMid=function(e){var t=r.matchPrefix(e,\"a=mid:\")[0];if(t)return t.substr(6)},r.parseFingerprint=function(r){var e=r.substr(14).split(\" \");return{algorithm:e[0].toLowerCase(),value:e[1]}},r.getDtlsParameters=function(e,t){return{role:\"auto\",fingerprints:r.matchPrefix(e+t,\"a=fingerprint:\").map(r.parseFingerprint)}},r.writeDtlsParameters=function(r,e){var t=\"a=setup:\"+e+\"\\r\\n\";return r.fingerprints.forEach(function(r){t+=\"a=fingerprint:\"+r.algorithm+\" \"+r.value+\"\\r\\n\"}),t},r.parseCryptoLine=function(r){var e=r.substr(9).split(\" \");return{tag:parseInt(e[0],10),cryptoSuite:e[1],keyParams:e[2],sessionParams:e.slice(3)}},r.writeCryptoLine=function(e){return\"a=crypto:\"+e.tag+\" \"+e.cryptoSuite+\" \"+(\"object\"==typeof e.keyParams?r.writeCryptoKeyParams(e.keyParams):e.keyParams)+(e.sessionParams?\" \"+e.sessionParams.join(\" \"):\"\")+\"\\r\\n\"},r.parseCryptoKeyParams=function(r){if(0!==r.indexOf(\"inline:\"))return null;var e=r.substr(7).split(\"|\");return{keyMethod:\"inline\",keySalt:e[0],lifeTime:e[1],mkiValue:e[2]?e[2].split(\":\")[0]:void 0,mkiLength:e[2]?e[2].split(\":\")[1]:void 0}},r.writeCryptoKeyParams=function(r){return r.keyMethod+\":\"+r.keySalt+(r.lifeTime?\"|\"+r.lifeTime:\"\")+(r.mkiValue&&r.mkiLength?\"|\"+r.mkiValue+\":\"+r.mkiLength:\"\")},r.getCryptoParameters=function(e,t){return r.matchPrefix(e+t,\"a=crypto:\").map(r.parseCryptoLine)},r.getIceParameters=function(e,t){var a=r.matchPrefix(e+t,\"a=ice-ufrag:\")[0],n=r.matchPrefix(e+t,\"a=ice-pwd:\")[0];return a&&n?{usernameFragment:a.substr(12),password:n.substr(10)}:null},r.writeIceParameters=function(r){return\"a=ice-ufrag:\"+r.usernameFragment+\"\\r\\na=ice-pwd:\"+r.password+\"\\r\\n\"},r.parseRtpParameters=function(e){for(var t={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},a=r.splitLines(e)[0].split(\" \"),n=3;n<a.length;n++){var s=a[n],i=r.matchPrefix(e,\"a=rtpmap:\"+s+\" \")[0];if(i){var p=r.parseRtpMap(i),c=r.matchPrefix(e,\"a=fmtp:\"+s+\" \");switch(p.parameters=c.length?r.parseFmtp(c[0]):{},p.rtcpFeedback=r.matchPrefix(e,\"a=rtcp-fb:\"+s+\" \").map(r.parseRtcpFb),t.codecs.push(p),p.name.toUpperCase()){case\"RED\":case\"ULPFEC\":t.fecMechanisms.push(p.name.toUpperCase())}}}return r.matchPrefix(e,\"a=extmap:\").forEach(function(e){t.headerExtensions.push(r.parseExtmap(e))}),t},r.writeRtpDescription=function(e,t){var a=\"\";a+=\"m=\"+e+\" \",a+=t.codecs.length>0?\"9\":\"0\",a+=\" UDP/TLS/RTP/SAVPF \",a+=t.codecs.map(function(r){return void 0!==r.preferredPayloadType?r.preferredPayloadType:r.payloadType}).join(\" \")+\"\\r\\n\",a+=\"c=IN IP4 0.0.0.0\\r\\n\",a+=\"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\",t.codecs.forEach(function(e){a+=r.writeRtpMap(e),a+=r.writeFmtp(e),a+=r.writeRtcpFb(e)});var n=0;return t.codecs.forEach(function(r){r.maxptime>n&&(n=r.maxptime)}),n>0&&(a+=\"a=maxptime:\"+n+\"\\r\\n\"),a+=\"a=rtcp-mux\\r\\n\",t.headerExtensions&&t.headerExtensions.forEach(function(e){a+=r.writeExtmap(e)}),a},r.parseRtpEncodingParameters=function(e){var t,a=[],n=r.parseRtpParameters(e),s=-1!==n.fecMechanisms.indexOf(\"RED\"),i=-1!==n.fecMechanisms.indexOf(\"ULPFEC\"),p=r.matchPrefix(e,\"a=ssrc:\").map(function(e){return r.parseSsrcMedia(e)}).filter(function(r){return\"cname\"===r.attribute}),c=p.length>0&&p[0].ssrc,o=r.matchPrefix(e,\"a=ssrc-group:FID\").map(function(r){return r.substr(17).split(\" \").map(function(r){return parseInt(r,10)})});o.length>0&&o[0].length>1&&o[0][0]===c&&(t=o[0][1]),n.codecs.forEach(function(r){if(\"RTX\"===r.name.toUpperCase()&&r.parameters.apt){var e={ssrc:c,codecPayloadType:parseInt(r.parameters.apt,10)};c&&t&&(e.rtx={ssrc:t}),a.push(e),s&&((e=JSON.parse(JSON.stringify(e))).fec={ssrc:c,mechanism:i?\"red+ulpfec\":\"red\"},a.push(e))}}),0===a.length&&c&&a.push({ssrc:c});var u=r.matchPrefix(e,\"b=\");return u.length&&(u=0===u[0].indexOf(\"b=TIAS:\")?parseInt(u[0].substr(7),10):0===u[0].indexOf(\"b=AS:\")?1e3*parseInt(u[0].substr(5),10)*.95-16e3:void 0,a.forEach(function(r){r.maxBitrate=u})),a},r.parseRtcpParameters=function(e){var t={},a=r.matchPrefix(e,\"a=ssrc:\").map(function(e){return r.parseSsrcMedia(e)}).filter(function(r){return\"cname\"===r.attribute})[0];a&&(t.cname=a.value,t.ssrc=a.ssrc);var n=r.matchPrefix(e,\"a=rtcp-rsize\");t.reducedSize=n.length>0,t.compound=0===n.length;var s=r.matchPrefix(e,\"a=rtcp-mux\");return t.mux=s.length>0,t},r.parseMsid=function(e){var t,a=r.matchPrefix(e,\"a=msid:\");if(1===a.length)return{stream:(t=a[0].substr(7).split(\" \"))[0],track:t[1]};var n=r.matchPrefix(e,\"a=ssrc:\").map(function(e){return r.parseSsrcMedia(e)}).filter(function(r){return\"msid\"===r.attribute});return n.length>0?{stream:(t=n[0].value.split(\" \"))[0],track:t[1]}:void 0},r.parseSctpDescription=function(e){var t,a=r.parseMLine(e),n=r.matchPrefix(e,\"a=max-message-size:\");n.length>0&&(t=parseInt(n[0].substr(19),10)),isNaN(t)&&(t=65536);var s=r.matchPrefix(e,\"a=sctp-port:\");if(s.length>0)return{port:parseInt(s[0].substr(12),10),protocol:a.fmt,maxMessageSize:t};if(r.matchPrefix(e,\"a=sctpmap:\").length>0){var i=r.matchPrefix(e,\"a=sctpmap:\")[0].substr(10).split(\" \");return{port:parseInt(i[0],10),protocol:i[1],maxMessageSize:t}}},r.writeSctpDescription=function(r,e){var t=[];return t=\"DTLS/SCTP\"!==r.protocol?[\"m=\"+r.kind+\" 9 \"+r.protocol+\" \"+e.protocol+\"\\r\\n\",\"c=IN IP4 0.0.0.0\\r\\n\",\"a=sctp-port:\"+e.port+\"\\r\\n\"]:[\"m=\"+r.kind+\" 9 \"+r.protocol+\" \"+e.port+\"\\r\\n\",\"c=IN IP4 0.0.0.0\\r\\n\",\"a=sctpmap:\"+e.port+\" \"+e.protocol+\" 65535\\r\\n\"],void 0!==e.maxMessageSize&&t.push(\"a=max-message-size:\"+e.maxMessageSize+\"\\r\\n\"),t.join(\"\")},r.generateSessionId=function(){return Math.random().toString().substr(2,21)},r.writeSessionBoilerplate=function(e,t,a){var n=void 0!==t?t:2;return\"v=0\\r\\no=\"+(a||\"thisisadapterortc\")+\" \"+(e||r.generateSessionId())+\" \"+n+\" IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\n\"},r.writeMediaSection=function(e,t,a,n){var s=r.writeRtpDescription(e.kind,t);if(s+=r.writeIceParameters(e.iceGatherer.getLocalParameters()),s+=r.writeDtlsParameters(e.dtlsTransport.getLocalParameters(),\"offer\"===a?\"actpass\":\"active\"),s+=\"a=mid:\"+e.mid+\"\\r\\n\",e.direction?s+=\"a=\"+e.direction+\"\\r\\n\":e.rtpSender&&e.rtpReceiver?s+=\"a=sendrecv\\r\\n\":e.rtpSender?s+=\"a=sendonly\\r\\n\":e.rtpReceiver?s+=\"a=recvonly\\r\\n\":s+=\"a=inactive\\r\\n\",e.rtpSender){var i=\"msid:\"+n.id+\" \"+e.rtpSender.track.id+\"\\r\\n\";s+=\"a=\"+i,s+=\"a=ssrc:\"+e.sendEncodingParameters[0].ssrc+\" \"+i,e.sendEncodingParameters[0].rtx&&(s+=\"a=ssrc:\"+e.sendEncodingParameters[0].rtx.ssrc+\" \"+i,s+=\"a=ssrc-group:FID \"+e.sendEncodingParameters[0].ssrc+\" \"+e.sendEncodingParameters[0].rtx.ssrc+\"\\r\\n\")}return s+=\"a=ssrc:\"+e.sendEncodingParameters[0].ssrc+\" cname:\"+r.localCName+\"\\r\\n\",e.rtpSender&&e.sendEncodingParameters[0].rtx&&(s+=\"a=ssrc:\"+e.sendEncodingParameters[0].rtx.ssrc+\" cname:\"+r.localCName+\"\\r\\n\"),s},r.getDirection=function(e,t){for(var a=r.splitLines(e),n=0;n<a.length;n++)switch(a[n]){case\"a=sendrecv\":case\"a=sendonly\":case\"a=recvonly\":case\"a=inactive\":return a[n].substr(2)}return t?r.getDirection(t):\"sendrecv\"},r.getKind=function(e){return r.splitLines(e)[0].split(\" \")[0].substr(2)},r.isRejected=function(r){return\"0\"===r.split(\" \",2)[1]},r.parseMLine=function(e){var t=r.splitLines(e)[0].substr(2).split(\" \");return{kind:t[0],port:parseInt(t[1],10),protocol:t[2],fmt:t.slice(3).join(\" \")}},r.parseOLine=function(e){var t=r.matchPrefix(e,\"o=\")[0].substr(2).split(\" \");return{username:t[0],sessionId:t[1],sessionVersion:parseInt(t[2],10),netType:t[3],addressType:t[4],address:t[5]}},r.isValidSDP=function(e){if(\"string\"!=typeof e||0===e.length)return!1;for(var t=r.splitLines(e),a=0;a<t.length;a++)if(t[a].length<2||\"=\"!==t[a].charAt(1))return!1;return!0},\"object\"==typeof module&&(module.exports=r);\n},{}],\"NJ2u\":[function(require,module,exports) {\n\"use strict\";var e=require(\"sdp\");function t(e){return{inboundrtp:\"inbound-rtp\",outboundrtp:\"outbound-rtp\",candidatepair:\"candidate-pair\",localcandidate:\"local-candidate\",remotecandidate:\"remote-candidate\"}[e.type]||e.type}function r(t,r,n,a,i){var s=e.writeRtpDescription(t.kind,r);if(s+=e.writeIceParameters(t.iceGatherer.getLocalParameters()),s+=e.writeDtlsParameters(t.dtlsTransport.getLocalParameters(),\"offer\"===n?\"actpass\":i||\"active\"),s+=\"a=mid:\"+t.mid+\"\\r\\n\",t.rtpSender&&t.rtpReceiver?s+=\"a=sendrecv\\r\\n\":t.rtpSender?s+=\"a=sendonly\\r\\n\":t.rtpReceiver?s+=\"a=recvonly\\r\\n\":s+=\"a=inactive\\r\\n\",t.rtpSender){var o=t.rtpSender._initialTrackId||t.rtpSender.track.id;t.rtpSender._initialTrackId=o;var c=\"msid:\"+(a?a.id:\"-\")+\" \"+o+\"\\r\\n\";s+=\"a=\"+c,s+=\"a=ssrc:\"+t.sendEncodingParameters[0].ssrc+\" \"+c,t.sendEncodingParameters[0].rtx&&(s+=\"a=ssrc:\"+t.sendEncodingParameters[0].rtx.ssrc+\" \"+c,s+=\"a=ssrc-group:FID \"+t.sendEncodingParameters[0].ssrc+\" \"+t.sendEncodingParameters[0].rtx.ssrc+\"\\r\\n\")}return s+=\"a=ssrc:\"+t.sendEncodingParameters[0].ssrc+\" cname:\"+e.localCName+\"\\r\\n\",t.rtpSender&&t.sendEncodingParameters[0].rtx&&(s+=\"a=ssrc:\"+t.sendEncodingParameters[0].rtx.ssrc+\" cname:\"+e.localCName+\"\\r\\n\"),s}function n(e,t){var r=!1;return(e=JSON.parse(JSON.stringify(e))).filter(function(e){if(e&&(e.urls||e.url)){var n=e.urls||e.url;e.url&&!e.urls&&console.warn(\"RTCIceServer.url is deprecated! Use urls instead.\");var a=\"string\"==typeof n;return a&&(n=[n]),n=n.filter(function(e){return 0===e.indexOf(\"turn:\")&&-1!==e.indexOf(\"transport=udp\")&&-1===e.indexOf(\"turn:[\")&&!r?(r=!0,!0):0===e.indexOf(\"stun:\")&&t>=14393&&-1===e.indexOf(\"?transport=udp\")}),delete e.url,e.urls=a?n[0]:n,!!n.length}})}function a(e,t){var r={codecs:[],headerExtensions:[],fecMechanisms:[]},n=function(e,t){e=parseInt(e,10);for(var r=0;r<t.length;r++)if(t[r].payloadType===e||t[r].preferredPayloadType===e)return t[r]},a=function(e,t,r,a){var i=n(e.parameters.apt,r),s=n(t.parameters.apt,a);return i&&s&&i.name.toLowerCase()===s.name.toLowerCase()};return e.codecs.forEach(function(n){for(var i=0;i<t.codecs.length;i++){var s=t.codecs[i];if(n.name.toLowerCase()===s.name.toLowerCase()&&n.clockRate===s.clockRate){if(\"rtx\"===n.name.toLowerCase()&&n.parameters&&s.parameters.apt&&!a(n,s,e.codecs,t.codecs))continue;(s=JSON.parse(JSON.stringify(s))).numChannels=Math.min(n.numChannels,s.numChannels),r.codecs.push(s),s.rtcpFeedback=s.rtcpFeedback.filter(function(e){for(var t=0;t<n.rtcpFeedback.length;t++)if(n.rtcpFeedback[t].type===e.type&&n.rtcpFeedback[t].parameter===e.parameter)return!0;return!1});break}}}),e.headerExtensions.forEach(function(e){for(var n=0;n<t.headerExtensions.length;n++){var a=t.headerExtensions[n];if(e.uri===a.uri){r.headerExtensions.push(a);break}}}),r}function i(e,t,r){return-1!=={offer:{setLocalDescription:[\"stable\",\"have-local-offer\"],setRemoteDescription:[\"stable\",\"have-remote-offer\"]},answer:{setLocalDescription:[\"have-remote-offer\",\"have-local-pranswer\"],setRemoteDescription:[\"have-local-offer\",\"have-remote-pranswer\"]}}[t][e].indexOf(r)}function s(e,t){var r=e.getRemoteCandidates().find(function(e){return t.foundation===e.foundation&&t.ip===e.ip&&t.port===e.port&&t.priority===e.priority&&t.protocol===e.protocol&&t.type===e.type});return r||e.addRemoteCandidate(t),!r}function o(e,t){var r=new Error(t);return r.name=e,r.code={NotSupportedError:9,InvalidStateError:11,InvalidAccessError:15,TypeError:void 0,OperationError:void 0}[e],r}module.exports=function(c,d){function p(e,t){t.addTrack(e),t.dispatchEvent(new c.MediaStreamTrackEvent(\"addtrack\",{track:e}))}function l(e,t,r,n){var a=new Event(\"track\");a.track=t,a.receiver=r,a.transceiver={receiver:r},a.streams=n,c.setTimeout(function(){e._dispatchEvent(\"track\",a)})}var f=function(t){var r=this,a=document.createDocumentFragment();if([\"addEventListener\",\"removeEventListener\",\"dispatchEvent\"].forEach(function(e){r[e]=a[e].bind(a)}),this.canTrickleIceCandidates=null,this.needNegotiation=!1,this.localStreams=[],this.remoteStreams=[],this._localDescription=null,this._remoteDescription=null,this.signalingState=\"stable\",this.iceConnectionState=\"new\",this.connectionState=\"new\",this.iceGatheringState=\"new\",t=JSON.parse(JSON.stringify(t||{})),this.usingBundle=\"max-bundle\"===t.bundlePolicy,\"negotiate\"===t.rtcpMuxPolicy)throw o(\"NotSupportedError\",\"rtcpMuxPolicy 'negotiate' is not supported\");switch(t.rtcpMuxPolicy||(t.rtcpMuxPolicy=\"require\"),t.iceTransportPolicy){case\"all\":case\"relay\":break;default:t.iceTransportPolicy=\"all\"}switch(t.bundlePolicy){case\"balanced\":case\"max-compat\":case\"max-bundle\":break;default:t.bundlePolicy=\"balanced\"}if(t.iceServers=n(t.iceServers||[],d),this._iceGatherers=[],t.iceCandidatePoolSize)for(var i=t.iceCandidatePoolSize;i>0;i--)this._iceGatherers.push(new c.RTCIceGatherer({iceServers:t.iceServers,gatherPolicy:t.iceTransportPolicy}));else t.iceCandidatePoolSize=0;this._config=t,this.transceivers=[],this._sdpSessionId=e.generateSessionId(),this._sdpSessionVersion=0,this._dtlsRole=void 0,this._isClosed=!1};Object.defineProperty(f.prototype,\"localDescription\",{configurable:!0,get:function(){return this._localDescription}}),Object.defineProperty(f.prototype,\"remoteDescription\",{configurable:!0,get:function(){return this._remoteDescription}}),f.prototype.onicecandidate=null,f.prototype.onaddstream=null,f.prototype.ontrack=null,f.prototype.onremovestream=null,f.prototype.onsignalingstatechange=null,f.prototype.oniceconnectionstatechange=null,f.prototype.onconnectionstatechange=null,f.prototype.onicegatheringstatechange=null,f.prototype.onnegotiationneeded=null,f.prototype.ondatachannel=null,f.prototype._dispatchEvent=function(e,t){this._isClosed||(this.dispatchEvent(t),\"function\"==typeof this[\"on\"+e]&&this[\"on\"+e](t))},f.prototype._emitGatheringStateChange=function(){var e=new Event(\"icegatheringstatechange\");this._dispatchEvent(\"icegatheringstatechange\",e)},f.prototype.getConfiguration=function(){return this._config},f.prototype.getLocalStreams=function(){return this.localStreams},f.prototype.getRemoteStreams=function(){return this.remoteStreams},f.prototype._createTransceiver=function(e,t){var r=this.transceivers.length>0,n={track:null,iceGatherer:null,iceTransport:null,dtlsTransport:null,localCapabilities:null,remoteCapabilities:null,rtpSender:null,rtpReceiver:null,kind:e,mid:null,sendEncodingParameters:null,recvEncodingParameters:null,stream:null,associatedRemoteMediaStreams:[],wantReceive:!0};if(this.usingBundle&&r)n.iceTransport=this.transceivers[0].iceTransport,n.dtlsTransport=this.transceivers[0].dtlsTransport;else{var a=this._createIceAndDtlsTransports();n.iceTransport=a.iceTransport,n.dtlsTransport=a.dtlsTransport}return t||this.transceivers.push(n),n},f.prototype.addTrack=function(e,t){if(this._isClosed)throw o(\"InvalidStateError\",\"Attempted to call addTrack on a closed peerconnection.\");var r;if(this.transceivers.find(function(t){return t.track===e}))throw o(\"InvalidAccessError\",\"Track already exists.\");for(var n=0;n<this.transceivers.length;n++)this.transceivers[n].track||this.transceivers[n].kind!==e.kind||(r=this.transceivers[n]);return r||(r=this._createTransceiver(e.kind)),this._maybeFireNegotiationNeeded(),-1===this.localStreams.indexOf(t)&&this.localStreams.push(t),r.track=e,r.stream=t,r.rtpSender=new c.RTCRtpSender(e,r.dtlsTransport),r.rtpSender},f.prototype.addStream=function(e){var t=this;if(d>=15025)e.getTracks().forEach(function(r){t.addTrack(r,e)});else{var r=e.clone();e.getTracks().forEach(function(e,t){var n=r.getTracks()[t];e.addEventListener(\"enabled\",function(e){n.enabled=e.enabled})}),r.getTracks().forEach(function(e){t.addTrack(e,r)})}},f.prototype.removeTrack=function(e){if(this._isClosed)throw o(\"InvalidStateError\",\"Attempted to call removeTrack on a closed peerconnection.\");if(!(e instanceof c.RTCRtpSender))throw new TypeError(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\");var t=this.transceivers.find(function(t){return t.rtpSender===e});if(!t)throw o(\"InvalidAccessError\",\"Sender was not created by this connection.\");var r=t.stream;t.rtpSender.stop(),t.rtpSender=null,t.track=null,t.stream=null,-1===this.transceivers.map(function(e){return e.stream}).indexOf(r)&&this.localStreams.indexOf(r)>-1&&this.localStreams.splice(this.localStreams.indexOf(r),1),this._maybeFireNegotiationNeeded()},f.prototype.removeStream=function(e){var t=this;e.getTracks().forEach(function(e){var r=t.getSenders().find(function(t){return t.track===e});r&&t.removeTrack(r)})},f.prototype.getSenders=function(){return this.transceivers.filter(function(e){return!!e.rtpSender}).map(function(e){return e.rtpSender})},f.prototype.getReceivers=function(){return this.transceivers.filter(function(e){return!!e.rtpReceiver}).map(function(e){return e.rtpReceiver})},f.prototype._createIceGatherer=function(e,t){var r=this;if(t&&e>0)return this.transceivers[0].iceGatherer;if(this._iceGatherers.length)return this._iceGatherers.shift();var n=new c.RTCIceGatherer({iceServers:this._config.iceServers,gatherPolicy:this._config.iceTransportPolicy});return Object.defineProperty(n,\"state\",{value:\"new\",writable:!0}),this.transceivers[e].bufferedCandidateEvents=[],this.transceivers[e].bufferCandidates=function(t){var a=!t.candidate||0===Object.keys(t.candidate).length;n.state=a?\"completed\":\"gathering\",null!==r.transceivers[e].bufferedCandidateEvents&&r.transceivers[e].bufferedCandidateEvents.push(t)},n.addEventListener(\"localcandidate\",this.transceivers[e].bufferCandidates),n},f.prototype._gather=function(t,r){var n=this,a=this.transceivers[r].iceGatherer;if(!a.onlocalcandidate){var i=this.transceivers[r].bufferedCandidateEvents;this.transceivers[r].bufferedCandidateEvents=null,a.removeEventListener(\"localcandidate\",this.transceivers[r].bufferCandidates),a.onlocalcandidate=function(i){if(!(n.usingBundle&&r>0)){var s=new Event(\"icecandidate\");s.candidate={sdpMid:t,sdpMLineIndex:r};var o=i.candidate,c=!o||0===Object.keys(o).length;if(c)\"new\"!==a.state&&\"gathering\"!==a.state||(a.state=\"completed\");else{\"new\"===a.state&&(a.state=\"gathering\"),o.component=1,o.ufrag=a.getLocalParameters().usernameFragment;var d=e.writeCandidate(o);s.candidate=Object.assign(s.candidate,e.parseCandidate(d)),s.candidate.candidate=d,s.candidate.toJSON=function(){return{candidate:s.candidate.candidate,sdpMid:s.candidate.sdpMid,sdpMLineIndex:s.candidate.sdpMLineIndex,usernameFragment:s.candidate.usernameFragment}}}var p=e.getMediaSections(n._localDescription.sdp);p[s.candidate.sdpMLineIndex]+=c?\"a=end-of-candidates\\r\\n\":\"a=\"+s.candidate.candidate+\"\\r\\n\",n._localDescription.sdp=e.getDescription(n._localDescription.sdp)+p.join(\"\");var l=n.transceivers.every(function(e){return e.iceGatherer&&\"completed\"===e.iceGatherer.state});\"gathering\"!==n.iceGatheringState&&(n.iceGatheringState=\"gathering\",n._emitGatheringStateChange()),c||n._dispatchEvent(\"icecandidate\",s),l&&(n._dispatchEvent(\"icecandidate\",new Event(\"icecandidate\")),n.iceGatheringState=\"complete\",n._emitGatheringStateChange())}},c.setTimeout(function(){i.forEach(function(e){a.onlocalcandidate(e)})},0)}},f.prototype._createIceAndDtlsTransports=function(){var e=this,t=new c.RTCIceTransport(null);t.onicestatechange=function(){e._updateIceConnectionState(),e._updateConnectionState()};var r=new c.RTCDtlsTransport(t);return r.ondtlsstatechange=function(){e._updateConnectionState()},r.onerror=function(){Object.defineProperty(r,\"state\",{value:\"failed\",writable:!0}),e._updateConnectionState()},{iceTransport:t,dtlsTransport:r}},f.prototype._disposeIceAndDtlsTransports=function(e){var t=this.transceivers[e].iceGatherer;t&&(delete t.onlocalcandidate,delete this.transceivers[e].iceGatherer);var r=this.transceivers[e].iceTransport;r&&(delete r.onicestatechange,delete this.transceivers[e].iceTransport);var n=this.transceivers[e].dtlsTransport;n&&(delete n.ondtlsstatechange,delete n.onerror,delete this.transceivers[e].dtlsTransport)},f.prototype._transceive=function(t,r,n){var i=a(t.localCapabilities,t.remoteCapabilities);r&&t.rtpSender&&(i.encodings=t.sendEncodingParameters,i.rtcp={cname:e.localCName,compound:t.rtcpParameters.compound},t.recvEncodingParameters.length&&(i.rtcp.ssrc=t.recvEncodingParameters[0].ssrc),t.rtpSender.send(i)),n&&t.rtpReceiver&&i.codecs.length>0&&(\"video\"===t.kind&&t.recvEncodingParameters&&d<15019&&t.recvEncodingParameters.forEach(function(e){delete e.rtx}),t.recvEncodingParameters.length?i.encodings=t.recvEncodingParameters:i.encodings=[{}],i.rtcp={compound:t.rtcpParameters.compound},t.rtcpParameters.cname&&(i.rtcp.cname=t.rtcpParameters.cname),t.sendEncodingParameters.length&&(i.rtcp.ssrc=t.sendEncodingParameters[0].ssrc),t.rtpReceiver.receive(i))},f.prototype.setLocalDescription=function(t){var r,n,s=this;if(-1===[\"offer\",\"answer\"].indexOf(t.type))return Promise.reject(o(\"TypeError\",'Unsupported type \"'+t.type+'\"'));if(!i(\"setLocalDescription\",t.type,s.signalingState)||s._isClosed)return Promise.reject(o(\"InvalidStateError\",\"Can not set local \"+t.type+\" in state \"+s.signalingState));if(\"offer\"===t.type)r=e.splitSections(t.sdp),n=r.shift(),r.forEach(function(t,r){var n=e.parseRtpParameters(t);s.transceivers[r].localCapabilities=n}),s.transceivers.forEach(function(e,t){s._gather(e.mid,t)});else if(\"answer\"===t.type){r=e.splitSections(s._remoteDescription.sdp),n=r.shift();var c=e.matchPrefix(n,\"a=ice-lite\").length>0;r.forEach(function(t,r){var i=s.transceivers[r],o=i.iceGatherer,d=i.iceTransport,p=i.dtlsTransport,l=i.localCapabilities,f=i.remoteCapabilities;if(!(e.isRejected(t)&&0===e.matchPrefix(t,\"a=bundle-only\").length)&&!i.rejected){var u=e.getIceParameters(t,n),v=e.getDtlsParameters(t,n);c&&(v.role=\"server\"),s.usingBundle&&0!==r||(s._gather(i.mid,r),\"new\"===d.state&&d.start(o,u,c?\"controlling\":\"controlled\"),\"new\"===p.state&&p.start(v));var h=a(l,f);s._transceive(i,h.codecs.length>0,!1)}})}return s._localDescription={type:t.type,sdp:t.sdp},\"offer\"===t.type?s._updateSignalingState(\"have-local-offer\"):s._updateSignalingState(\"stable\"),Promise.resolve()},f.prototype.setRemoteDescription=function(t){var r=this;if(-1===[\"offer\",\"answer\"].indexOf(t.type))return Promise.reject(o(\"TypeError\",'Unsupported type \"'+t.type+'\"'));if(!i(\"setRemoteDescription\",t.type,r.signalingState)||r._isClosed)return Promise.reject(o(\"InvalidStateError\",\"Can not set remote \"+t.type+\" in state \"+r.signalingState));var n={};r.remoteStreams.forEach(function(e){n[e.id]=e});var f=[],u=e.splitSections(t.sdp),v=u.shift(),h=e.matchPrefix(v,\"a=ice-lite\").length>0,m=e.matchPrefix(v,\"a=group:BUNDLE \").length>0;r.usingBundle=m;var g=e.matchPrefix(v,\"a=ice-options:\")[0];return r.canTrickleIceCandidates=!!g&&g.substr(14).split(\" \").indexOf(\"trickle\")>=0,u.forEach(function(i,o){var l=e.splitLines(i),u=e.getKind(i),g=e.isRejected(i)&&0===e.matchPrefix(i,\"a=bundle-only\").length,y=l[0].substr(2).split(\" \")[2],S=e.getDirection(i,v),T=e.parseMsid(i),E=e.getMid(i)||e.generateIdentifier();if(g||\"application\"===u&&(\"DTLS/SCTP\"===y||\"UDP/DTLS/SCTP\"===y))r.transceivers[o]={mid:E,kind:u,protocol:y,rejected:!0};else{var C,P,w,R,_,k,b,x,D;!g&&r.transceivers[o]&&r.transceivers[o].rejected&&(r.transceivers[o]=r._createTransceiver(u,!0));var I,L,M=e.parseRtpParameters(i);g||(I=e.getIceParameters(i,v),(L=e.getDtlsParameters(i,v)).role=\"client\"),b=e.parseRtpEncodingParameters(i);var O=e.parseRtcpParameters(i),G=e.matchPrefix(i,\"a=end-of-candidates\",v).length>0,j=e.matchPrefix(i,\"a=candidate:\").map(function(t){return e.parseCandidate(t)}).filter(function(e){return 1===e.component});if((\"offer\"===t.type||\"answer\"===t.type)&&!g&&m&&o>0&&r.transceivers[o]&&(r._disposeIceAndDtlsTransports(o),r.transceivers[o].iceGatherer=r.transceivers[0].iceGatherer,r.transceivers[o].iceTransport=r.transceivers[0].iceTransport,r.transceivers[o].dtlsTransport=r.transceivers[0].dtlsTransport,r.transceivers[o].rtpSender&&r.transceivers[o].rtpSender.setTransport(r.transceivers[0].dtlsTransport),r.transceivers[o].rtpReceiver&&r.transceivers[o].rtpReceiver.setTransport(r.transceivers[0].dtlsTransport)),\"offer\"!==t.type||g){if(\"answer\"===t.type&&!g){P=(C=r.transceivers[o]).iceGatherer,w=C.iceTransport,R=C.dtlsTransport,_=C.rtpReceiver,k=C.sendEncodingParameters,x=C.localCapabilities,r.transceivers[o].recvEncodingParameters=b,r.transceivers[o].remoteCapabilities=M,r.transceivers[o].rtcpParameters=O,j.length&&\"new\"===w.state&&(!h&&!G||m&&0!==o?j.forEach(function(e){s(C.iceTransport,e)}):w.setRemoteCandidates(j)),m&&0!==o||(\"new\"===w.state&&w.start(P,I,\"controlling\"),\"new\"===R.state&&R.start(L)),!a(C.localCapabilities,C.remoteCapabilities).codecs.filter(function(e){return\"rtx\"===e.name.toLowerCase()}).length&&C.sendEncodingParameters[0].rtx&&delete C.sendEncodingParameters[0].rtx,r._transceive(C,\"sendrecv\"===S||\"recvonly\"===S,\"sendrecv\"===S||\"sendonly\"===S),!_||\"sendrecv\"!==S&&\"sendonly\"!==S?delete C.rtpReceiver:(D=_.track,T?(n[T.stream]||(n[T.stream]=new c.MediaStream),p(D,n[T.stream]),f.push([D,_,n[T.stream]])):(n.default||(n.default=new c.MediaStream),p(D,n.default),f.push([D,_,n.default])))}}else{(C=r.transceivers[o]||r._createTransceiver(u)).mid=E,C.iceGatherer||(C.iceGatherer=r._createIceGatherer(o,m)),j.length&&\"new\"===C.iceTransport.state&&(!G||m&&0!==o?j.forEach(function(e){s(C.iceTransport,e)}):C.iceTransport.setRemoteCandidates(j)),x=c.RTCRtpReceiver.getCapabilities(u),d<15019&&(x.codecs=x.codecs.filter(function(e){return\"rtx\"!==e.name})),k=C.sendEncodingParameters||[{ssrc:1001*(2*o+2)}];var N,A=!1;if(\"sendrecv\"===S||\"sendonly\"===S){if(A=!C.rtpReceiver,_=C.rtpReceiver||new c.RTCRtpReceiver(C.dtlsTransport,u),A)D=_.track,T&&\"-\"===T.stream||(T?(n[T.stream]||(n[T.stream]=new c.MediaStream,Object.defineProperty(n[T.stream],\"id\",{get:function(){return T.stream}})),Object.defineProperty(D,\"id\",{get:function(){return T.track}}),N=n[T.stream]):(n.default||(n.default=new c.MediaStream),N=n.default)),N&&(p(D,N),C.associatedRemoteMediaStreams.push(N)),f.push([D,_,N])}else C.rtpReceiver&&C.rtpReceiver.track&&(C.associatedRemoteMediaStreams.forEach(function(e){var t,r,n=e.getTracks().find(function(e){return e.id===C.rtpReceiver.track.id});n&&(t=n,(r=e).removeTrack(t),r.dispatchEvent(new c.MediaStreamTrackEvent(\"removetrack\",{track:t})))}),C.associatedRemoteMediaStreams=[]);C.localCapabilities=x,C.remoteCapabilities=M,C.rtpReceiver=_,C.rtcpParameters=O,C.sendEncodingParameters=k,C.recvEncodingParameters=b,r._transceive(r.transceivers[o],!1,A)}}}),void 0===r._dtlsRole&&(r._dtlsRole=\"offer\"===t.type?\"active\":\"passive\"),r._remoteDescription={type:t.type,sdp:t.sdp},\"offer\"===t.type?r._updateSignalingState(\"have-remote-offer\"):r._updateSignalingState(\"stable\"),Object.keys(n).forEach(function(e){var t=n[e];if(t.getTracks().length){if(-1===r.remoteStreams.indexOf(t)){r.remoteStreams.push(t);var a=new Event(\"addstream\");a.stream=t,c.setTimeout(function(){r._dispatchEvent(\"addstream\",a)})}f.forEach(function(e){var n=e[0],a=e[1];t.id===e[2].id&&l(r,n,a,[t])})}}),f.forEach(function(e){e[2]||l(r,e[0],e[1],[])}),c.setTimeout(function(){r&&r.transceivers&&r.transceivers.forEach(function(e){e.iceTransport&&\"new\"===e.iceTransport.state&&e.iceTransport.getRemoteCandidates().length>0&&(console.warn(\"Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification\"),e.iceTransport.addRemoteCandidate({}))})},4e3),Promise.resolve()},f.prototype.close=function(){this.transceivers.forEach(function(e){e.iceTransport&&e.iceTransport.stop(),e.dtlsTransport&&e.dtlsTransport.stop(),e.rtpSender&&e.rtpSender.stop(),e.rtpReceiver&&e.rtpReceiver.stop()}),this._isClosed=!0,this._updateSignalingState(\"closed\")},f.prototype._updateSignalingState=function(e){this.signalingState=e;var t=new Event(\"signalingstatechange\");this._dispatchEvent(\"signalingstatechange\",t)},f.prototype._maybeFireNegotiationNeeded=function(){var e=this;\"stable\"===this.signalingState&&!0!==this.needNegotiation&&(this.needNegotiation=!0,c.setTimeout(function(){if(e.needNegotiation){e.needNegotiation=!1;var t=new Event(\"negotiationneeded\");e._dispatchEvent(\"negotiationneeded\",t)}},0))},f.prototype._updateIceConnectionState=function(){var e,t={new:0,closed:0,checking:0,connected:0,completed:0,disconnected:0,failed:0};if(this.transceivers.forEach(function(e){e.iceTransport&&!e.rejected&&t[e.iceTransport.state]++}),e=\"new\",t.failed>0?e=\"failed\":t.checking>0?e=\"checking\":t.disconnected>0?e=\"disconnected\":t.new>0?e=\"new\":t.connected>0?e=\"connected\":t.completed>0&&(e=\"completed\"),e!==this.iceConnectionState){this.iceConnectionState=e;var r=new Event(\"iceconnectionstatechange\");this._dispatchEvent(\"iceconnectionstatechange\",r)}},f.prototype._updateConnectionState=function(){var e,t={new:0,closed:0,connecting:0,connected:0,completed:0,disconnected:0,failed:0};if(this.transceivers.forEach(function(e){e.iceTransport&&e.dtlsTransport&&!e.rejected&&(t[e.iceTransport.state]++,t[e.dtlsTransport.state]++)}),t.connected+=t.completed,e=\"new\",t.failed>0?e=\"failed\":t.connecting>0?e=\"connecting\":t.disconnected>0?e=\"disconnected\":t.new>0?e=\"new\":t.connected>0&&(e=\"connected\"),e!==this.connectionState){this.connectionState=e;var r=new Event(\"connectionstatechange\");this._dispatchEvent(\"connectionstatechange\",r)}},f.prototype.createOffer=function(){var t=this;if(t._isClosed)return Promise.reject(o(\"InvalidStateError\",\"Can not call createOffer after close\"));var n=t.transceivers.filter(function(e){return\"audio\"===e.kind}).length,a=t.transceivers.filter(function(e){return\"video\"===e.kind}).length,i=arguments[0];if(i){if(i.mandatory||i.optional)throw new TypeError(\"Legacy mandatory/optional constraints not supported.\");void 0!==i.offerToReceiveAudio&&(n=!0===i.offerToReceiveAudio?1:!1===i.offerToReceiveAudio?0:i.offerToReceiveAudio),void 0!==i.offerToReceiveVideo&&(a=!0===i.offerToReceiveVideo?1:!1===i.offerToReceiveVideo?0:i.offerToReceiveVideo)}for(t.transceivers.forEach(function(e){\"audio\"===e.kind?--n<0&&(e.wantReceive=!1):\"video\"===e.kind&&--a<0&&(e.wantReceive=!1)});n>0||a>0;)n>0&&(t._createTransceiver(\"audio\"),n--),a>0&&(t._createTransceiver(\"video\"),a--);var s=e.writeSessionBoilerplate(t._sdpSessionId,t._sdpSessionVersion++);t.transceivers.forEach(function(r,n){var a=r.track,i=r.kind,s=r.mid||e.generateIdentifier();r.mid=s,r.iceGatherer||(r.iceGatherer=t._createIceGatherer(n,t.usingBundle));var o=c.RTCRtpSender.getCapabilities(i);d<15019&&(o.codecs=o.codecs.filter(function(e){return\"rtx\"!==e.name})),o.codecs.forEach(function(e){\"H264\"===e.name&&void 0===e.parameters[\"level-asymmetry-allowed\"]&&(e.parameters[\"level-asymmetry-allowed\"]=\"1\"),r.remoteCapabilities&&r.remoteCapabilities.codecs&&r.remoteCapabilities.codecs.forEach(function(t){e.name.toLowerCase()===t.name.toLowerCase()&&e.clockRate===t.clockRate&&(e.preferredPayloadType=t.payloadType)})}),o.headerExtensions.forEach(function(e){(r.remoteCapabilities&&r.remoteCapabilities.headerExtensions||[]).forEach(function(t){e.uri===t.uri&&(e.id=t.id)})});var p=r.sendEncodingParameters||[{ssrc:1001*(2*n+1)}];a&&d>=15019&&\"video\"===i&&!p[0].rtx&&(p[0].rtx={ssrc:p[0].ssrc+1}),r.wantReceive&&(r.rtpReceiver=new c.RTCRtpReceiver(r.dtlsTransport,i)),r.localCapabilities=o,r.sendEncodingParameters=p}),\"max-compat\"!==t._config.bundlePolicy&&(s+=\"a=group:BUNDLE \"+t.transceivers.map(function(e){return e.mid}).join(\" \")+\"\\r\\n\"),s+=\"a=ice-options:trickle\\r\\n\",t.transceivers.forEach(function(n,a){s+=r(n,n.localCapabilities,\"offer\",n.stream,t._dtlsRole),s+=\"a=rtcp-rsize\\r\\n\",!n.iceGatherer||\"new\"===t.iceGatheringState||0!==a&&t.usingBundle||(n.iceGatherer.getLocalCandidates().forEach(function(t){t.component=1,s+=\"a=\"+e.writeCandidate(t)+\"\\r\\n\"}),\"completed\"===n.iceGatherer.state&&(s+=\"a=end-of-candidates\\r\\n\"))});var p=new c.RTCSessionDescription({type:\"offer\",sdp:s});return Promise.resolve(p)},f.prototype.createAnswer=function(){var t=this;if(t._isClosed)return Promise.reject(o(\"InvalidStateError\",\"Can not call createAnswer after close\"));if(\"have-remote-offer\"!==t.signalingState&&\"have-local-pranswer\"!==t.signalingState)return Promise.reject(o(\"InvalidStateError\",\"Can not call createAnswer in signalingState \"+t.signalingState));var n=e.writeSessionBoilerplate(t._sdpSessionId,t._sdpSessionVersion++);t.usingBundle&&(n+=\"a=group:BUNDLE \"+t.transceivers.map(function(e){return e.mid}).join(\" \")+\"\\r\\n\"),n+=\"a=ice-options:trickle\\r\\n\";var i=e.getMediaSections(t._remoteDescription.sdp).length;t.transceivers.forEach(function(e,s){if(!(s+1>i)){if(e.rejected)return\"application\"===e.kind?\"DTLS/SCTP\"===e.protocol?n+=\"m=application 0 DTLS/SCTP 5000\\r\\n\":n+=\"m=application 0 \"+e.protocol+\" webrtc-datachannel\\r\\n\":\"audio\"===e.kind?n+=\"m=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\na=rtpmap:0 PCMU/8000\\r\\n\":\"video\"===e.kind&&(n+=\"m=video 0 UDP/TLS/RTP/SAVPF 120\\r\\na=rtpmap:120 VP8/90000\\r\\n\"),void(n+=\"c=IN IP4 0.0.0.0\\r\\na=inactive\\r\\na=mid:\"+e.mid+\"\\r\\n\");var o;if(e.stream)\"audio\"===e.kind?o=e.stream.getAudioTracks()[0]:\"video\"===e.kind&&(o=e.stream.getVideoTracks()[0]),o&&d>=15019&&\"video\"===e.kind&&!e.sendEncodingParameters[0].rtx&&(e.sendEncodingParameters[0].rtx={ssrc:e.sendEncodingParameters[0].ssrc+1});var c=a(e.localCapabilities,e.remoteCapabilities);!c.codecs.filter(function(e){return\"rtx\"===e.name.toLowerCase()}).length&&e.sendEncodingParameters[0].rtx&&delete e.sendEncodingParameters[0].rtx,n+=r(e,c,\"answer\",e.stream,t._dtlsRole),e.rtcpParameters&&e.rtcpParameters.reducedSize&&(n+=\"a=rtcp-rsize\\r\\n\")}});var s=new c.RTCSessionDescription({type:\"answer\",sdp:n});return Promise.resolve(s)},f.prototype.addIceCandidate=function(t){var r,n=this;return t&&void 0===t.sdpMLineIndex&&!t.sdpMid?Promise.reject(new TypeError(\"sdpMLineIndex or sdpMid required\")):new Promise(function(a,i){if(!n._remoteDescription)return i(o(\"InvalidStateError\",\"Can not add ICE candidate without a remote description\"));if(t&&\"\"!==t.candidate){var c=t.sdpMLineIndex;if(t.sdpMid)for(var d=0;d<n.transceivers.length;d++)if(n.transceivers[d].mid===t.sdpMid){c=d;break}var p=n.transceivers[c];if(!p)return i(o(\"OperationError\",\"Can not add ICE candidate\"));if(p.rejected)return a();var l=Object.keys(t.candidate).length>0?e.parseCandidate(t.candidate):{};if(\"tcp\"===l.protocol&&(0===l.port||9===l.port))return a();if(l.component&&1!==l.component)return a();if((0===c||c>0&&p.iceTransport!==n.transceivers[0].iceTransport)&&!s(p.iceTransport,l))return i(o(\"OperationError\",\"Can not add ICE candidate\"));var f=t.candidate.trim();0===f.indexOf(\"a=\")&&(f=f.substr(2)),(r=e.getMediaSections(n._remoteDescription.sdp))[c]+=\"a=\"+(l.type?f:\"end-of-candidates\")+\"\\r\\n\",n._remoteDescription.sdp=e.getDescription(n._remoteDescription.sdp)+r.join(\"\")}else for(var u=0;u<n.transceivers.length&&(n.transceivers[u].rejected||(n.transceivers[u].iceTransport.addRemoteCandidate({}),(r=e.getMediaSections(n._remoteDescription.sdp))[u]+=\"a=end-of-candidates\\r\\n\",n._remoteDescription.sdp=e.getDescription(n._remoteDescription.sdp)+r.join(\"\"),!n.usingBundle));u++);a()})},f.prototype.getStats=function(e){if(e&&e instanceof c.MediaStreamTrack){var t=null;if(this.transceivers.forEach(function(r){r.rtpSender&&r.rtpSender.track===e?t=r.rtpSender:r.rtpReceiver&&r.rtpReceiver.track===e&&(t=r.rtpReceiver)}),!t)throw o(\"InvalidAccessError\",\"Invalid selector.\");return t.getStats()}var r=[];return this.transceivers.forEach(function(e){[\"rtpSender\",\"rtpReceiver\",\"iceGatherer\",\"iceTransport\",\"dtlsTransport\"].forEach(function(t){e[t]&&r.push(e[t].getStats())})}),Promise.all(r).then(function(e){var t=new Map;return e.forEach(function(e){e.forEach(function(e){t.set(e.id,e)})}),t})};[\"RTCRtpSender\",\"RTCRtpReceiver\",\"RTCIceGatherer\",\"RTCIceTransport\",\"RTCDtlsTransport\"].forEach(function(e){var r=c[e];if(r&&r.prototype&&r.prototype.getStats){var n=r.prototype.getStats;r.prototype.getStats=function(){return n.apply(this).then(function(e){var r=new Map;return Object.keys(e).forEach(function(n){e[n].type=t(e[n]),r.set(n,e[n])}),r})}}});var u=[\"createOffer\",\"createAnswer\"];return u.forEach(function(e){var t=f.prototype[e];f.prototype[e]=function(){var e=arguments;return\"function\"==typeof e[0]||\"function\"==typeof e[1]?t.apply(this,[arguments[2]]).then(function(t){\"function\"==typeof e[0]&&e[0].apply(null,[t])},function(t){\"function\"==typeof e[1]&&e[1].apply(null,[t])}):t.apply(this,arguments)}}),(u=[\"setLocalDescription\",\"setRemoteDescription\",\"addIceCandidate\"]).forEach(function(e){var t=f.prototype[e];f.prototype[e]=function(){var e=arguments;return\"function\"==typeof e[1]||\"function\"==typeof e[2]?t.apply(this,arguments).then(function(){\"function\"==typeof e[1]&&e[1].apply(null)},function(t){\"function\"==typeof e[2]&&e[2].apply(null,[t])}):t.apply(this,arguments)}}),[\"getStats\"].forEach(function(e){var t=f.prototype[e];f.prototype[e]=function(){var e=arguments;return\"function\"==typeof e[1]?t.apply(this,arguments).then(function(){\"function\"==typeof e[1]&&e[1].apply(null)}):t.apply(this,arguments)}}),f};\n},{\"sdp\":\"YHvh\"}],\"YdKx\":[function(require,module,exports) {\n\"use strict\";function e(e){var r=e&&e.navigator,t=r.mediaDevices.getUserMedia.bind(r.mediaDevices);r.mediaDevices.getUserMedia=function(e){return t(e).catch(function(e){return Promise.reject(function(e){return{name:{PermissionDeniedError:\"NotAllowedError\"}[e.name]||e.name,message:e.message,constraint:e.constraint,toString:function(){return this.name}}}(e))})}}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetUserMedia=e;\n},{}],\"P3bV\":[function(require,module,exports) {\n\"use strict\";function e(e){\"getDisplayMedia\"in e.navigator&&e.navigator.mediaDevices&&(e.navigator.mediaDevices&&\"getDisplayMedia\"in e.navigator.mediaDevices||(e.navigator.mediaDevices.getDisplayMedia=e.navigator.getDisplayMedia.bind(e.navigator)))}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetDisplayMedia=e;\n},{}],\"XRic\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimPeerConnection=p,exports.shimReplaceTrack=a,Object.defineProperty(exports,\"shimGetUserMedia\",{enumerable:!0,get:function(){return n.shimGetUserMedia}}),Object.defineProperty(exports,\"shimGetDisplayMedia\",{enumerable:!0,get:function(){return i.shimGetDisplayMedia}});var e=s(require(\"../utils\")),t=require(\"./filtericeservers\"),r=o(require(\"rtcpeerconnection-shim\")),n=require(\"./getusermedia\"),i=require(\"./getdisplaymedia\");function o(e){return e&&e.__esModule?e:{default:e}}function c(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return c=function(){return e},e}function s(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=c();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(r,i,o):r[i]=e[i]}return r.default=e,t&&t.set(e,r),r}function p(n,i){if(n.RTCIceGatherer&&(n.RTCIceCandidate||(n.RTCIceCandidate=function(e){return e}),n.RTCSessionDescription||(n.RTCSessionDescription=function(e){return e}),i.version<15025)){var o=Object.getOwnPropertyDescriptor(n.MediaStreamTrack.prototype,\"enabled\");Object.defineProperty(n.MediaStreamTrack.prototype,\"enabled\",{set:function(e){o.set.call(this,e);var t=new Event(\"enabled\");t.enabled=e,this.dispatchEvent(t)}})}!n.RTCRtpSender||\"dtmf\"in n.RTCRtpSender.prototype||Object.defineProperty(n.RTCRtpSender.prototype,\"dtmf\",{get:function(){return void 0===this._dtmf&&(\"audio\"===this.track.kind?this._dtmf=new n.RTCDtmfSender(this):\"video\"===this.track.kind&&(this._dtmf=null)),this._dtmf}}),n.RTCDtmfSender&&!n.RTCDTMFSender&&(n.RTCDTMFSender=n.RTCDtmfSender);var c=(0,r.default)(n,i.version);n.RTCPeerConnection=function(r){return r&&r.iceServers&&(r.iceServers=(0,t.filterIceServers)(r.iceServers,i.version),e.log(\"ICE servers after filtering:\",r.iceServers)),new c(r)},n.RTCPeerConnection.prototype=c.prototype}function a(e){!e.RTCRtpSender||\"replaceTrack\"in e.RTCRtpSender.prototype||(e.RTCRtpSender.prototype.replaceTrack=e.RTCRtpSender.prototype.setTrack)}\n},{\"../utils\":\"iSxC\",\"./filtericeservers\":\"NZ1C\",\"rtcpeerconnection-shim\":\"NJ2u\",\"./getusermedia\":\"YdKx\",\"./getdisplaymedia\":\"P3bV\"}],\"GzSv\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetUserMedia=n;var e=o(require(\"../utils\"));function t(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return t=function(){return e},e}function o(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var o=t();if(o&&o.has(e))return o.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=n?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(r,i,a):r[i]=e[i]}return r.default=e,o&&o.set(e,r),r}function r(e){return(r=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function n(t,o){var n=t&&t.navigator,i=t&&t.MediaStreamTrack;if(n.getUserMedia=function(t,o,r){e.deprecated(\"navigator.getUserMedia\",\"navigator.mediaDevices.getUserMedia\"),n.mediaDevices.getUserMedia(t).then(o,r)},!(o.version>55&&\"autoGainControl\"in n.mediaDevices.getSupportedConstraints())){var a=function(e,t,o){t in e&&!(o in e)&&(e[o]=e[t],delete e[t])},s=n.mediaDevices.getUserMedia.bind(n.mediaDevices);if(n.mediaDevices.getUserMedia=function(e){return\"object\"===r(e)&&\"object\"===r(e.audio)&&(e=JSON.parse(JSON.stringify(e)),a(e.audio,\"autoGainControl\",\"mozAutoGainControl\"),a(e.audio,\"noiseSuppression\",\"mozNoiseSuppression\")),s(e)},i&&i.prototype.getSettings){var p=i.prototype.getSettings;i.prototype.getSettings=function(){var e=p.apply(this,arguments);return a(e,\"mozAutoGainControl\",\"autoGainControl\"),a(e,\"mozNoiseSuppression\",\"noiseSuppression\"),e}}if(i&&i.prototype.applyConstraints){var u=i.prototype.applyConstraints;i.prototype.applyConstraints=function(e){return\"audio\"===this.kind&&\"object\"===r(e)&&(e=JSON.parse(JSON.stringify(e)),a(e,\"autoGainControl\",\"mozAutoGainControl\"),a(e,\"noiseSuppression\",\"mozNoiseSuppression\")),u.apply(this,[e])}}}}\n},{\"../utils\":\"iSxC\"}],\"UuGU\":[function(require,module,exports) {\n\"use strict\";function e(e,i){e.navigator.mediaDevices&&\"getDisplayMedia\"in e.navigator.mediaDevices||e.navigator.mediaDevices&&(e.navigator.mediaDevices.getDisplayMedia=function(a){if(!a||!a.video){var t=new DOMException(\"getDisplayMedia without video constraints is undefined\");return t.name=\"NotFoundError\",t.code=8,Promise.reject(t)}return!0===a.video?a.video={mediaSource:i}:a.video.mediaSource=i,e.navigator.mediaDevices.getUserMedia(a)})}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetDisplayMedia=e;\n},{}],\"Fzdr\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimOnTrack=s,exports.shimPeerConnection=c,exports.shimSenderGetStats=p,exports.shimReceiverGetStats=u,exports.shimRemoveStream=f,exports.shimRTCDataChannel=d,exports.shimAddTransceiver=C,exports.shimGetParameters=y,exports.shimCreateOffer=l,exports.shimCreateAnswer=m,Object.defineProperty(exports,\"shimGetUserMedia\",{enumerable:!0,get:function(){return t.shimGetUserMedia}}),Object.defineProperty(exports,\"shimGetDisplayMedia\",{enumerable:!0,get:function(){return n.shimGetDisplayMedia}});var e=o(require(\"../utils\")),t=require(\"./getusermedia\"),n=require(\"./getdisplaymedia\");function r(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return r=function(){return e},e}function o(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=r();if(t&&t.has(e))return t.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=o?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(n,i,a):n[i]=e[i]}return n.default=e,t&&t.set(e,n),n}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e){return(a=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function s(e){\"object\"===a(e)&&e.RTCTrackEvent&&\"receiver\"in e.RTCTrackEvent.prototype&&!(\"transceiver\"in e.RTCTrackEvent.prototype)&&Object.defineProperty(e.RTCTrackEvent.prototype,\"transceiver\",{get:function(){return{receiver:this.receiver}}})}function c(e,t){if(\"object\"===a(e)&&(e.RTCPeerConnection||e.mozRTCPeerConnection)){!e.RTCPeerConnection&&e.mozRTCPeerConnection&&(e.RTCPeerConnection=e.mozRTCPeerConnection),t.version<53&&[\"setLocalDescription\",\"setRemoteDescription\",\"addIceCandidate\"].forEach(function(t){var n=e.RTCPeerConnection.prototype[t],r=i({},t,function(){return arguments[0]=new(\"addIceCandidate\"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),n.apply(this,arguments)});e.RTCPeerConnection.prototype[t]=r[t]});var n={inboundrtp:\"inbound-rtp\",outboundrtp:\"outbound-rtp\",candidatepair:\"candidate-pair\",localcandidate:\"local-candidate\",remotecandidate:\"remote-candidate\"},r=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(){var[e,o,i]=arguments;return r.apply(this,[e||null]).then(function(e){if(t.version<53&&!o)try{e.forEach(function(e){e.type=n[e.type]||e.type})}catch(r){if(\"TypeError\"!==r.name)throw r;e.forEach(function(t,r){e.set(r,Object.assign({},t,{type:n[t.type]||t.type}))})}return e}).then(o,i)}}}function p(e){if(\"object\"===a(e)&&e.RTCPeerConnection&&e.RTCRtpSender&&!(e.RTCRtpSender&&\"getStats\"in e.RTCRtpSender.prototype)){var t=e.RTCPeerConnection.prototype.getSenders;t&&(e.RTCPeerConnection.prototype.getSenders=function(){var e=this,n=t.apply(this,[]);return n.forEach(function(t){return t._pc=e}),n});var n=e.RTCPeerConnection.prototype.addTrack;n&&(e.RTCPeerConnection.prototype.addTrack=function(){var e=n.apply(this,arguments);return e._pc=this,e}),e.RTCRtpSender.prototype.getStats=function(){return this.track?this._pc.getStats(this.track):Promise.resolve(new Map)}}}function u(t){if(\"object\"===a(t)&&t.RTCPeerConnection&&t.RTCRtpSender&&!(t.RTCRtpSender&&\"getStats\"in t.RTCRtpReceiver.prototype)){var n=t.RTCPeerConnection.prototype.getReceivers;n&&(t.RTCPeerConnection.prototype.getReceivers=function(){var e=this,t=n.apply(this,[]);return t.forEach(function(t){return t._pc=e}),t}),e.wrapPeerConnectionEvent(t,\"track\",function(e){return e.receiver._pc=e.srcElement,e}),t.RTCRtpReceiver.prototype.getStats=function(){return this._pc.getStats(this.track)}}}function f(t){!t.RTCPeerConnection||\"removeStream\"in t.RTCPeerConnection.prototype||(t.RTCPeerConnection.prototype.removeStream=function(t){var n=this;e.deprecated(\"removeStream\",\"removeTrack\"),this.getSenders().forEach(function(e){e.track&&t.getTracks().includes(e.track)&&n.removeTrack(e)})})}function d(e){e.DataChannel&&!e.RTCDataChannel&&(e.RTCDataChannel=e.DataChannel)}function C(e){if(\"object\"===a(e)&&e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype.addTransceiver;t&&(e.RTCPeerConnection.prototype.addTransceiver=function(){this.setParametersPromises=[];var e=arguments[1],n=e&&\"sendEncodings\"in e;n&&e.sendEncodings.forEach(function(e){if(\"rid\"in e){if(!/^[a-z0-9]{0,16}$/i.test(e.rid))throw new TypeError(\"Invalid RID value provided.\")}if(\"scaleResolutionDownBy\"in e&&!(parseFloat(e.scaleResolutionDownBy)>=1))throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");if(\"maxFramerate\"in e&&!(parseFloat(e.maxFramerate)>=0))throw new RangeError(\"max_framerate must be >= 0.0\")});var r=t.apply(this,arguments);if(n){var{sender:o}=r,i=o.getParameters();\"encodings\"in i&&(1!==i.encodings.length||0!==Object.keys(i.encodings[0]).length)||(i.encodings=e.sendEncodings,o.sendEncodings=e.sendEncodings,this.setParametersPromises.push(o.setParameters(i).then(function(){delete o.sendEncodings}).catch(function(){delete o.sendEncodings})))}return r})}}function y(e){if(\"object\"===a(e)&&e.RTCRtpSender){var t=e.RTCRtpSender.prototype.getParameters;t&&(e.RTCRtpSender.prototype.getParameters=function(){var e=t.apply(this,arguments);return\"encodings\"in e||(e.encodings=[].concat(this.sendEncodings||[{}])),e})}}function l(e){if(\"object\"===a(e)&&e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype.createOffer;e.RTCPeerConnection.prototype.createOffer=function(){var e=arguments,n=this;return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then(function(){return t.apply(n,e)}).finally(function(){n.setParametersPromises=[]}):t.apply(this,arguments)}}}function m(e){if(\"object\"===a(e)&&e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype.createAnswer;e.RTCPeerConnection.prototype.createAnswer=function(){var e=arguments,n=this;return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then(function(){return t.apply(n,e)}).finally(function(){n.setParametersPromises=[]}):t.apply(this,arguments)}}}\n},{\"../utils\":\"iSxC\",\"./getusermedia\":\"GzSv\",\"./getdisplaymedia\":\"UuGU\"}],\"t1lL\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimLocalStreamsAPI=n,exports.shimRemoteStreamsAPI=i,exports.shimCallbacksAPI=a,exports.shimGetUserMedia=c,exports.shimConstraints=s,exports.shimRTCIceServerUrls=d,exports.shimTrackEventTransceiver=f,exports.shimCreateOfferLegacy=p,exports.shimAudioContext=u;var e=r(require(\"../utils\"));function t(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return t=function(){return e},e}function r(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var r=t();if(r&&r.has(e))return r.get(e);var o={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=n?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(o,i,a):o[i]=e[i]}return o.default=e,r&&r.set(e,o),o}function o(e){return(o=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function n(e){if(\"object\"===o(e)&&e.RTCPeerConnection){if(\"getLocalStreams\"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getLocalStreams=function(){return this._localStreams||(this._localStreams=[]),this._localStreams}),!(\"addStream\"in e.RTCPeerConnection.prototype)){var t=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addStream=function(e){var r=this;this._localStreams||(this._localStreams=[]),this._localStreams.includes(e)||this._localStreams.push(e),e.getAudioTracks().forEach(function(o){return t.call(r,o,e)}),e.getVideoTracks().forEach(function(o){return t.call(r,o,e)})},e.RTCPeerConnection.prototype.addTrack=function(e){for(var r=this,o=arguments.length,n=new Array(o>1?o-1:0),i=1;i<o;i++)n[i-1]=arguments[i];return n&&n.forEach(function(e){r._localStreams?r._localStreams.includes(e)||r._localStreams.push(e):r._localStreams=[e]}),t.apply(this,arguments)}}\"removeStream\"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.removeStream=function(e){var t=this;this._localStreams||(this._localStreams=[]);var r=this._localStreams.indexOf(e);if(-1!==r){this._localStreams.splice(r,1);var o=e.getTracks();this.getSenders().forEach(function(e){o.includes(e.track)&&t.removeTrack(e)})}})}}function i(e){if(\"object\"===o(e)&&e.RTCPeerConnection&&(\"getRemoteStreams\"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getRemoteStreams=function(){return this._remoteStreams?this._remoteStreams:[]}),!(\"onaddstream\"in e.RTCPeerConnection.prototype))){Object.defineProperty(e.RTCPeerConnection.prototype,\"onaddstream\",{get:function(){return this._onaddstream},set:function(e){var t=this;this._onaddstream&&(this.removeEventListener(\"addstream\",this._onaddstream),this.removeEventListener(\"track\",this._onaddstreampoly)),this.addEventListener(\"addstream\",this._onaddstream=e),this.addEventListener(\"track\",this._onaddstreampoly=function(e){e.streams.forEach(function(e){if(t._remoteStreams||(t._remoteStreams=[]),!t._remoteStreams.includes(e)){t._remoteStreams.push(e);var r=new Event(\"addstream\");r.stream=e,t.dispatchEvent(r)}})})}});var t=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(){var e=this;return this._onaddstreampoly||this.addEventListener(\"track\",this._onaddstreampoly=function(t){t.streams.forEach(function(t){if(e._remoteStreams||(e._remoteStreams=[]),!(e._remoteStreams.indexOf(t)>=0)){e._remoteStreams.push(t);var r=new Event(\"addstream\");r.stream=t,e.dispatchEvent(r)}})}),t.apply(e,arguments)}}}function a(e){if(\"object\"===o(e)&&e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype,r=t.createOffer,n=t.createAnswer,i=t.setLocalDescription,a=t.setRemoteDescription,c=t.addIceCandidate;t.createOffer=function(e,t){var o=arguments.length>=2?arguments[2]:arguments[0],n=r.apply(this,[o]);return t?(n.then(e,t),Promise.resolve()):n},t.createAnswer=function(e,t){var r=arguments.length>=2?arguments[2]:arguments[0],o=n.apply(this,[r]);return t?(o.then(e,t),Promise.resolve()):o};var s=function(e,t,r){var o=i.apply(this,[e]);return r?(o.then(t,r),Promise.resolve()):o};t.setLocalDescription=s,s=function(e,t,r){var o=a.apply(this,[e]);return r?(o.then(t,r),Promise.resolve()):o},t.setRemoteDescription=s,s=function(e,t,r){var o=c.apply(this,[e]);return r?(o.then(t,r),Promise.resolve()):o},t.addIceCandidate=s}}function c(e){var t=e&&e.navigator;if(t.mediaDevices&&t.mediaDevices.getUserMedia){var r=t.mediaDevices,o=r.getUserMedia.bind(r);t.mediaDevices.getUserMedia=function(e){return o(s(e))}}!t.getUserMedia&&t.mediaDevices&&t.mediaDevices.getUserMedia&&(t.getUserMedia=function(e,r,o){t.mediaDevices.getUserMedia(e).then(r,o)}.bind(t))}function s(t){return t&&void 0!==t.video?Object.assign({},t,{video:e.compactObject(t.video)}):t}function d(t){if(t.RTCPeerConnection){var r=t.RTCPeerConnection;t.RTCPeerConnection=function(t,o){if(t&&t.iceServers){for(var n=[],i=0;i<t.iceServers.length;i++){var a=t.iceServers[i];!a.hasOwnProperty(\"urls\")&&a.hasOwnProperty(\"url\")?(e.deprecated(\"RTCIceServer.url\",\"RTCIceServer.urls\"),(a=JSON.parse(JSON.stringify(a))).urls=a.url,delete a.url,n.push(a)):n.push(t.iceServers[i])}t.iceServers=n}return new r(t,o)},t.RTCPeerConnection.prototype=r.prototype,\"generateCertificate\"in r&&Object.defineProperty(t.RTCPeerConnection,\"generateCertificate\",{get:function(){return r.generateCertificate}})}}function f(e){\"object\"===o(e)&&e.RTCTrackEvent&&\"receiver\"in e.RTCTrackEvent.prototype&&!(\"transceiver\"in e.RTCTrackEvent.prototype)&&Object.defineProperty(e.RTCTrackEvent.prototype,\"transceiver\",{get:function(){return{receiver:this.receiver}}})}function p(e){var t=e.RTCPeerConnection.prototype.createOffer;e.RTCPeerConnection.prototype.createOffer=function(e){if(e){void 0!==e.offerToReceiveAudio&&(e.offerToReceiveAudio=!!e.offerToReceiveAudio);var r=this.getTransceivers().find(function(e){return\"audio\"===e.receiver.track.kind});!1===e.offerToReceiveAudio&&r?\"sendrecv\"===r.direction?r.setDirection?r.setDirection(\"sendonly\"):r.direction=\"sendonly\":\"recvonly\"===r.direction&&(r.setDirection?r.setDirection(\"inactive\"):r.direction=\"inactive\"):!0!==e.offerToReceiveAudio||r||this.addTransceiver(\"audio\"),void 0!==e.offerToReceiveVideo&&(e.offerToReceiveVideo=!!e.offerToReceiveVideo);var o=this.getTransceivers().find(function(e){return\"video\"===e.receiver.track.kind});!1===e.offerToReceiveVideo&&o?\"sendrecv\"===o.direction?o.setDirection?o.setDirection(\"sendonly\"):o.direction=\"sendonly\":\"recvonly\"===o.direction&&(o.setDirection?o.setDirection(\"inactive\"):o.direction=\"inactive\"):!0!==e.offerToReceiveVideo||o||this.addTransceiver(\"video\")}return t.apply(this,arguments)}}function u(e){\"object\"!==o(e)||e.AudioContext||(e.AudioContext=e.webkitAudioContext)}\n},{\"../utils\":\"iSxC\"}],\"GOQK\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimRTCIceCandidate=a,exports.shimMaxMessageSize=c,exports.shimSendThrowTypeError=s,exports.shimConnectionState=p,exports.removeExtmapAllowMixed=d,exports.shimAddIceCandidateNullOrEmpty=u;var e=r(require(\"sdp\")),t=o(require(\"./utils\"));function n(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return n=function(){return e},e}function o(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=n();if(t&&t.has(e))return t.get(e);var o={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=r?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(o,i,a):o[i]=e[i]}return o.default=e,t&&t.set(e,o),o}function r(e){return e&&e.__esModule?e:{default:e}}function i(e){return(i=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function a(n){if(n.RTCIceCandidate&&!(n.RTCIceCandidate&&\"foundation\"in n.RTCIceCandidate.prototype)){var o=n.RTCIceCandidate;n.RTCIceCandidate=function(t){if(\"object\"===i(t)&&t.candidate&&0===t.candidate.indexOf(\"a=\")&&((t=JSON.parse(JSON.stringify(t))).candidate=t.candidate.substr(2)),t.candidate&&t.candidate.length){var n=new o(t),r=e.default.parseCandidate(t.candidate),a=Object.assign(n,r);return a.toJSON=function(){return{candidate:a.candidate,sdpMid:a.sdpMid,sdpMLineIndex:a.sdpMLineIndex,usernameFragment:a.usernameFragment}},a}return new o(t)},n.RTCIceCandidate.prototype=o.prototype,t.wrapPeerConnectionEvent(n,\"icecandidate\",function(e){return e.candidate&&Object.defineProperty(e,\"candidate\",{value:new n.RTCIceCandidate(e.candidate),writable:\"false\"}),e})}}function c(t,n){if(t.RTCPeerConnection){\"sctp\"in t.RTCPeerConnection.prototype||Object.defineProperty(t.RTCPeerConnection.prototype,\"sctp\",{get:function(){return void 0===this._sctp?null:this._sctp}});var o=t.RTCPeerConnection.prototype.setRemoteDescription;t.RTCPeerConnection.prototype.setRemoteDescription=function(){if(this._sctp=null,\"chrome\"===n.browser&&n.version>=76){var{sdpSemantics:t}=this.getConfiguration();\"plan-b\"===t&&Object.defineProperty(this,\"sctp\",{get:function(){return void 0===this._sctp?null:this._sctp},enumerable:!0,configurable:!0})}if(function(t){if(!t||!t.sdp)return!1;var n=e.default.splitSections(t.sdp);return n.shift(),n.some(function(t){var n=e.default.parseMLine(t);return n&&\"application\"===n.kind&&-1!==n.protocol.indexOf(\"SCTP\")})}(arguments[0])){var r,i=function(e){var t=e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);if(null===t||t.length<2)return-1;var n=parseInt(t[1],10);return n!=n?-1:n}(arguments[0]),a=(p=i,d=65536,\"firefox\"===n.browser&&(d=n.version<57?-1===p?16384:2147483637:n.version<60?57===n.version?65535:65536:2147483637),d),c=function(t,o){var r=65536;\"firefox\"===n.browser&&57===n.version&&(r=65535);var i=e.default.matchPrefix(t.sdp,\"a=max-message-size:\");return i.length>0?r=parseInt(i[0].substr(19),10):\"firefox\"===n.browser&&-1!==o&&(r=2147483637),r}(arguments[0],i);r=0===a&&0===c?Number.POSITIVE_INFINITY:0===a||0===c?Math.max(a,c):Math.min(a,c);var s={};Object.defineProperty(s,\"maxMessageSize\",{get:function(){return r}}),this._sctp=s}var p,d;return o.apply(this,arguments)}}}function s(e){if(e.RTCPeerConnection&&\"createDataChannel\"in e.RTCPeerConnection.prototype){var n=e.RTCPeerConnection.prototype.createDataChannel;e.RTCPeerConnection.prototype.createDataChannel=function(){var e=n.apply(this,arguments);return o(e,this),e},t.wrapPeerConnectionEvent(e,\"datachannel\",function(e){return o(e.channel,e.target),e})}function o(e,t){var n=e.send;e.send=function(){var o=arguments[0],r=o.length||o.size||o.byteLength;if(\"open\"===e.readyState&&t.sctp&&r>t.sctp.maxMessageSize)throw new TypeError(\"Message too large (can send a maximum of \"+t.sctp.maxMessageSize+\" bytes)\");return n.apply(e,arguments)}}}function p(e){if(e.RTCPeerConnection&&!(\"connectionState\"in e.RTCPeerConnection.prototype)){var t=e.RTCPeerConnection.prototype;Object.defineProperty(t,\"connectionState\",{get:function(){return{completed:\"connected\",checking:\"connecting\"}[this.iceConnectionState]||this.iceConnectionState},enumerable:!0,configurable:!0}),Object.defineProperty(t,\"onconnectionstatechange\",{get:function(){return this._onconnectionstatechange||null},set:function(e){this._onconnectionstatechange&&(this.removeEventListener(\"connectionstatechange\",this._onconnectionstatechange),delete this._onconnectionstatechange),e&&this.addEventListener(\"connectionstatechange\",this._onconnectionstatechange=e)},enumerable:!0,configurable:!0}),[\"setLocalDescription\",\"setRemoteDescription\"].forEach(function(e){var n=t[e];t[e]=function(){return this._connectionstatechangepoly||(this._connectionstatechangepoly=function(e){var t=e.target;if(t._lastConnectionState!==t.connectionState){t._lastConnectionState=t.connectionState;var n=new Event(\"connectionstatechange\",e);t.dispatchEvent(n)}return e},this.addEventListener(\"iceconnectionstatechange\",this._connectionstatechangepoly)),n.apply(this,arguments)}})}}function d(e,t){if(e.RTCPeerConnection&&!(\"chrome\"===t.browser&&t.version>=71||\"safari\"===t.browser&&t.version>=605)){var n=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(t){if(t&&t.sdp&&-1!==t.sdp.indexOf(\"\\na=extmap-allow-mixed\")){var o=t.sdp.split(\"\\n\").filter(function(e){return\"a=extmap-allow-mixed\"!==e.trim()}).join(\"\\n\");e.RTCSessionDescription&&t instanceof e.RTCSessionDescription?arguments[0]=new e.RTCSessionDescription({type:t.type,sdp:o}):t.sdp=o}return n.apply(this,arguments)}}}function u(e,t){if(e.RTCPeerConnection&&e.RTCPeerConnection.prototype){var n=e.RTCPeerConnection.prototype.addIceCandidate;n&&0!==n.length&&(e.RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?(\"chrome\"===t.browser&&t.version<78||\"firefox\"===t.browser&&t.version<68||\"safari\"===t.browser)&&arguments[0]&&\"\"===arguments[0].candidate?Promise.resolve():n.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())})}}\n},{\"sdp\":\"YHvh\",\"./utils\":\"iSxC\"}],\"KtlG\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.adapterFactory=o;var e=m(require(\"./utils\")),i=m(require(\"./chrome/chrome_shim\")),r=m(require(\"./edge/edge_shim\")),s=m(require(\"./firefox/firefox_shim\")),t=m(require(\"./safari/safari_shim\")),a=m(require(\"./common_shim\"));function n(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return n=function(){return e},e}function m(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var i=n();if(i&&i.has(e))return i.get(e);var r={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var t in e)if(Object.prototype.hasOwnProperty.call(e,t)){var a=s?Object.getOwnPropertyDescriptor(e,t):null;a&&(a.get||a.set)?Object.defineProperty(r,t,a):r[t]=e[t]}return r.default=e,i&&i.set(e,r),r}function o(){var{window:n}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},m=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{shimChrome:!0,shimFirefox:!0,shimEdge:!0,shimSafari:!0},o=e.log,h=e.detectBrowser(n),d={browserDetails:h,commonShim:a,extractVersion:e.extractVersion,disableLog:e.disableLog,disableWarnings:e.disableWarnings};switch(h.browser){case\"chrome\":if(!i||!i.shimPeerConnection||!m.shimChrome)return o(\"Chrome shim is not included in this adapter release.\"),d;if(null===h.version)return o(\"Chrome shim can not determine version, not shimming.\"),d;o(\"adapter.js shimming chrome.\"),d.browserShim=i,a.shimAddIceCandidateNullOrEmpty(n,h),i.shimGetUserMedia(n,h),i.shimMediaStream(n,h),i.shimPeerConnection(n,h),i.shimOnTrack(n,h),i.shimAddTrackRemoveTrack(n,h),i.shimGetSendersWithDtmf(n,h),i.shimGetStats(n,h),i.shimSenderReceiverGetStats(n,h),i.fixNegotiationNeeded(n,h),a.shimRTCIceCandidate(n,h),a.shimConnectionState(n,h),a.shimMaxMessageSize(n,h),a.shimSendThrowTypeError(n,h),a.removeExtmapAllowMixed(n,h);break;case\"firefox\":if(!s||!s.shimPeerConnection||!m.shimFirefox)return o(\"Firefox shim is not included in this adapter release.\"),d;o(\"adapter.js shimming firefox.\"),d.browserShim=s,a.shimAddIceCandidateNullOrEmpty(n,h),s.shimGetUserMedia(n,h),s.shimPeerConnection(n,h),s.shimOnTrack(n,h),s.shimRemoveStream(n,h),s.shimSenderGetStats(n,h),s.shimReceiverGetStats(n,h),s.shimRTCDataChannel(n,h),s.shimAddTransceiver(n,h),s.shimGetParameters(n,h),s.shimCreateOffer(n,h),s.shimCreateAnswer(n,h),a.shimRTCIceCandidate(n,h),a.shimConnectionState(n,h),a.shimMaxMessageSize(n,h),a.shimSendThrowTypeError(n,h);break;case\"edge\":if(!r||!r.shimPeerConnection||!m.shimEdge)return o(\"MS edge shim is not included in this adapter release.\"),d;o(\"adapter.js shimming edge.\"),d.browserShim=r,r.shimGetUserMedia(n,h),r.shimGetDisplayMedia(n,h),r.shimPeerConnection(n,h),r.shimReplaceTrack(n,h),a.shimMaxMessageSize(n,h),a.shimSendThrowTypeError(n,h);break;case\"safari\":if(!t||!m.shimSafari)return o(\"Safari shim is not included in this adapter release.\"),d;o(\"adapter.js shimming safari.\"),d.browserShim=t,a.shimAddIceCandidateNullOrEmpty(n,h),t.shimRTCIceServerUrls(n,h),t.shimCreateOfferLegacy(n,h),t.shimCallbacksAPI(n,h),t.shimLocalStreamsAPI(n,h),t.shimRemoteStreamsAPI(n,h),t.shimTrackEventTransceiver(n,h),t.shimGetUserMedia(n,h),t.shimAudioContext(n,h),a.shimRTCIceCandidate(n,h),a.shimMaxMessageSize(n,h),a.shimSendThrowTypeError(n,h),a.removeExtmapAllowMixed(n,h);break;default:o(\"Unsupported browser!\")}return d}\n},{\"./utils\":\"iSxC\",\"./chrome/chrome_shim\":\"uI5X\",\"./edge/edge_shim\":\"XRic\",\"./firefox/firefox_shim\":\"Fzdr\",\"./safari/safari_shim\":\"t1lL\",\"./common_shim\":\"GOQK\"}],\"tI1X\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var e=require(\"./adapter_factory.js\"),t=(0,e.adapterFactory)({window:\"undefined\"==typeof window?void 0:window}),d=t;exports.default=d;\n},{\"./adapter_factory.js\":\"KtlG\"}],\"sXtV\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.webRTCAdapter=void 0;var t=e(require(\"webrtc-adapter\"));exports.webRTCAdapter=t.default;\n},{\"webrtc-adapter\":\"tI1X\"}],\"I31f\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Supports=void 0;var r=require(\"./adapter\");exports.Supports=new(function(){function e(){this.isIOS=[\"iPad\",\"iPhone\",\"iPod\"].includes(navigator.platform),this.supportedBrowsers=[\"firefox\",\"chrome\",\"safari\"],this.minFirefoxVersion=59,this.minChromeVersion=72,this.minSafariVersion=605}return e.prototype.isWebRTCSupported=function(){return\"undefined\"!=typeof RTCPeerConnection},e.prototype.isBrowserSupported=function(){var r=this.getBrowser(),e=this.getVersion();return!!this.supportedBrowsers.includes(r)&&(\"chrome\"===r?e>=this.minChromeVersion:\"firefox\"===r?e>=this.minFirefoxVersion:\"safari\"===r&&(!this.isIOS&&e>=this.minSafariVersion))},e.prototype.getBrowser=function(){return r.webRTCAdapter.browserDetails.browser},e.prototype.getVersion=function(){return r.webRTCAdapter.browserDetails.version||0},e.prototype.isUnifiedPlanSupported=function(){var e,i=this.getBrowser(),t=r.webRTCAdapter.browserDetails.version||0;if(\"chrome\"===i&&t<72)return!1;if(\"firefox\"===i&&t>=59)return!0;if(!(window.RTCRtpTransceiver&&\"currentDirection\"in RTCRtpTransceiver.prototype))return!1;var o=!1;try{(e=new RTCPeerConnection).addTransceiver(\"audio\"),o=!0}catch(s){}finally{e&&e.close()}return o},e.prototype.toString=function(){return\"Supports: \\n    browser:\"+this.getBrowser()+\" \\n    version:\"+this.getVersion()+\" \\n    isIOS:\"+this.isIOS+\" \\n    isWebRTCSupported:\"+this.isWebRTCSupported()+\" \\n    isBrowserSupported:\"+this.isBrowserSupported()+\" \\n    isUnifiedPlanSupported:\"+this.isUnifiedPlanSupported()},e}());\n},{\"./adapter\":\"sXtV\"}],\"BHXf\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r),Object.defineProperty(e,o,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),t=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,\"default\",{enumerable:!0,value:t})}:function(e,t){e.default=t}),r=this&&this.__importStar||function(r){if(r&&r.__esModule)return r;var o={};if(null!=r)for(var n in r)\"default\"!==n&&Object.prototype.hasOwnProperty.call(r,n)&&e(o,r,n);return t(o,r),o};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.util=void 0;var o=r(require(\"peerjs-js-binarypack\")),n=require(\"./supports\"),i={iceServers:[{urls:\"stun:stun.l.google.com:19302\"},{urls:\"turn:0.peerjs.com:3478\",username:\"peerjs\",credential:\"peerjsp\"}],sdpSemantics:\"unified-plan\"};exports.util=new(function(){function e(){this.CLOUD_HOST=\"0.peerjs.com\",this.CLOUD_PORT=443,this.chunkedBrowsers={Chrome:1,chrome:1},this.chunkedMTU=16300,this.defaultConfig=i,this.browser=n.Supports.getBrowser(),this.browserVersion=n.Supports.getVersion(),this.supports=function(){var e,t={browser:n.Supports.isBrowserSupported(),webRTC:n.Supports.isWebRTCSupported(),audioVideo:!1,data:!1,binaryBlob:!1,reliable:!1};if(!t.webRTC)return t;try{e=new RTCPeerConnection(i),t.audioVideo=!0;var r=void 0;try{r=e.createDataChannel(\"_PEERJSTEST\",{ordered:!0}),t.data=!0,t.reliable=!!r.ordered;try{r.binaryType=\"blob\",t.binaryBlob=!n.Supports.isIOS}catch(o){}}catch(o){}finally{r&&r.close()}}catch(o){}finally{e&&e.close()}return t}(),this.pack=o.pack,this.unpack=o.unpack,this._dataCount=1}return e.prototype.noop=function(){},e.prototype.validateId=function(e){return!e||/^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(e)},e.prototype.chunk=function(e){for(var t=[],r=e.size,o=Math.ceil(r/exports.util.chunkedMTU),n=0,i=0;i<r;){var a=Math.min(r,i+exports.util.chunkedMTU),u=e.slice(i,a),s={__peerData:this._dataCount,n:n,data:u,total:o};t.push(s),i=a,n++}return this._dataCount++,t},e.prototype.blobToArrayBuffer=function(e,t){var r=new FileReader;return r.onload=function(e){e.target&&t(e.target.result)},r.readAsArrayBuffer(e),r},e.prototype.binaryStringToArrayBuffer=function(e){for(var t=new Uint8Array(e.length),r=0;r<e.length;r++)t[r]=255&e.charCodeAt(r);return t.buffer},e.prototype.randomToken=function(){return Math.random().toString(36).substr(2)},e.prototype.isSecure=function(){return\"https:\"===location.protocol},e}());\n},{\"peerjs-js-binarypack\":\"kdPp\",\"./supports\":\"I31f\"}],\"JJlS\":[function(require,module,exports) {\n\"use strict\";var e=Object.prototype.hasOwnProperty,t=\"~\";function n(){}function r(e,t,n){this.fn=e,this.context=t,this.once=n||!1}function o(e,n,o,s,i){if(\"function\"!=typeof o)throw new TypeError(\"The listener must be a function\");var c=new r(o,s||e,i),f=t?t+n:n;return e._events[f]?e._events[f].fn?e._events[f]=[e._events[f],c]:e._events[f].push(c):(e._events[f]=c,e._eventsCount++),e}function s(e,t){0==--e._eventsCount?e._events=new n:delete e._events[t]}function i(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(t=!1)),i.prototype.eventNames=function(){var n,r,o=[];if(0===this._eventsCount)return o;for(r in n=this._events)e.call(n,r)&&o.push(t?r.slice(1):r);return Object.getOwnPropertySymbols?o.concat(Object.getOwnPropertySymbols(n)):o},i.prototype.listeners=function(e){var n=t?t+e:e,r=this._events[n];if(!r)return[];if(r.fn)return[r.fn];for(var o=0,s=r.length,i=new Array(s);o<s;o++)i[o]=r[o].fn;return i},i.prototype.listenerCount=function(e){var n=t?t+e:e,r=this._events[n];return r?r.fn?1:r.length:0},i.prototype.emit=function(e,n,r,o,s,i){var c=t?t+e:e;if(!this._events[c])return!1;var f,u,a=this._events[c],l=arguments.length;if(a.fn){switch(a.once&&this.removeListener(e,a.fn,void 0,!0),l){case 1:return a.fn.call(a.context),!0;case 2:return a.fn.call(a.context,n),!0;case 3:return a.fn.call(a.context,n,r),!0;case 4:return a.fn.call(a.context,n,r,o),!0;case 5:return a.fn.call(a.context,n,r,o,s),!0;case 6:return a.fn.call(a.context,n,r,o,s,i),!0}for(u=1,f=new Array(l-1);u<l;u++)f[u-1]=arguments[u];a.fn.apply(a.context,f)}else{var v,h=a.length;for(u=0;u<h;u++)switch(a[u].once&&this.removeListener(e,a[u].fn,void 0,!0),l){case 1:a[u].fn.call(a[u].context);break;case 2:a[u].fn.call(a[u].context,n);break;case 3:a[u].fn.call(a[u].context,n,r);break;case 4:a[u].fn.call(a[u].context,n,r,o);break;default:if(!f)for(v=1,f=new Array(l-1);v<l;v++)f[v-1]=arguments[v];a[u].fn.apply(a[u].context,f)}}return!0},i.prototype.on=function(e,t,n){return o(this,e,t,n,!1)},i.prototype.once=function(e,t,n){return o(this,e,t,n,!0)},i.prototype.removeListener=function(e,n,r,o){var i=t?t+e:e;if(!this._events[i])return this;if(!n)return s(this,i),this;var c=this._events[i];if(c.fn)c.fn!==n||o&&!c.once||r&&c.context!==r||s(this,i);else{for(var f=0,u=[],a=c.length;f<a;f++)(c[f].fn!==n||o&&!c[f].once||r&&c[f].context!==r)&&u.push(c[f]);u.length?this._events[i]=1===u.length?u[0]:u:s(this,i)}return this},i.prototype.removeAllListeners=function(e){var r;return e?(r=t?t+e:e,this._events[r]&&s(this,r)):(this._events=new n,this._eventsCount=0),this},i.prototype.off=i.prototype.removeListener,i.prototype.addListener=i.prototype.on,i.prefixed=t,i.EventEmitter=i,\"undefined\"!=typeof module&&(module.exports=i);\n},{}],\"WOs9\":[function(require,module,exports) {\n\"use strict\";var r=this&&this.__read||function(r,e){var o=\"function\"==typeof Symbol&&r[Symbol.iterator];if(!o)return r;var t,n,l=o.call(r),i=[];try{for(;(void 0===e||e-- >0)&&!(t=l.next()).done;)i.push(t.value)}catch(s){n={error:s}}finally{try{t&&!t.done&&(o=l.return)&&o.call(l)}finally{if(n)throw n.error}}return i},e=this&&this.__spreadArray||function(r,e){for(var o=0,t=e.length,n=r.length;o<t;o++,n++)r[n]=e[o];return r};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.LogLevel=void 0;var o,t=\"PeerJS: \";!function(r){r[r.Disabled=0]=\"Disabled\",r[r.Errors=1]=\"Errors\",r[r.Warnings=2]=\"Warnings\",r[r.All=3]=\"All\"}(o=exports.LogLevel||(exports.LogLevel={}));var n=function(){function n(){this._logLevel=o.Disabled}return Object.defineProperty(n.prototype,\"logLevel\",{get:function(){return this._logLevel},set:function(r){this._logLevel=r},enumerable:!1,configurable:!0}),n.prototype.log=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];this._logLevel>=o.All&&this._print.apply(this,e([o.All],r(t)))},n.prototype.warn=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];this._logLevel>=o.Warnings&&this._print.apply(this,e([o.Warnings],r(t)))},n.prototype.error=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];this._logLevel>=o.Errors&&this._print.apply(this,e([o.Errors],r(t)))},n.prototype.setLogFunction=function(r){this._print=r},n.prototype._print=function(n){for(var l=[],i=1;i<arguments.length;i++)l[i-1]=arguments[i];var s=e([t],r(l));for(var a in s)s[a]instanceof Error&&(s[a]=\"(\"+s[a].name+\") \"+s[a].message);n>=o.All?console.log.apply(console,e([],r(s))):n>=o.Warnings?console.warn.apply(console,e([\"WARNING\"],r(s))):n>=o.Errors&&console.error.apply(console,e([\"ERROR\"],r(s)))},n}();exports.default=new n;\n},{}],\"ZRYf\":[function(require,module,exports) {\n\"use strict\";var e,r,o,n,t,a,i;Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.ServerMessageType=exports.SocketEventType=exports.SerializationType=exports.PeerErrorType=exports.PeerEventType=exports.ConnectionType=exports.ConnectionEventType=void 0,function(e){e.Open=\"open\",e.Stream=\"stream\",e.Data=\"data\",e.Close=\"close\",e.Error=\"error\",e.IceStateChanged=\"iceStateChanged\"}(e=exports.ConnectionEventType||(exports.ConnectionEventType={})),function(e){e.Data=\"data\",e.Media=\"media\"}(r=exports.ConnectionType||(exports.ConnectionType={})),function(e){e.Open=\"open\",e.Close=\"close\",e.Connection=\"connection\",e.Call=\"call\",e.Disconnected=\"disconnected\",e.Error=\"error\"}(o=exports.PeerEventType||(exports.PeerEventType={})),function(e){e.BrowserIncompatible=\"browser-incompatible\",e.Disconnected=\"disconnected\",e.InvalidID=\"invalid-id\",e.InvalidKey=\"invalid-key\",e.Network=\"network\",e.PeerUnavailable=\"peer-unavailable\",e.SslUnavailable=\"ssl-unavailable\",e.ServerError=\"server-error\",e.SocketError=\"socket-error\",e.SocketClosed=\"socket-closed\",e.UnavailableID=\"unavailable-id\",e.WebRTC=\"webrtc\"}(n=exports.PeerErrorType||(exports.PeerErrorType={})),function(e){e.Binary=\"binary\",e.BinaryUTF8=\"binary-utf8\",e.JSON=\"json\"}(t=exports.SerializationType||(exports.SerializationType={})),function(e){e.Message=\"message\",e.Disconnected=\"disconnected\",e.Error=\"error\",e.Close=\"close\"}(a=exports.SocketEventType||(exports.SocketEventType={})),function(e){e.Heartbeat=\"HEARTBEAT\",e.Candidate=\"CANDIDATE\",e.Offer=\"OFFER\",e.Answer=\"ANSWER\",e.Open=\"OPEN\",e.Error=\"ERROR\",e.IdTaken=\"ID-TAKEN\",e.InvalidKey=\"INVALID-KEY\",e.Leave=\"LEAVE\",e.Expire=\"EXPIRE\"}(i=exports.ServerMessageType||(exports.ServerMessageType={}));\n},{}],\"wJlv\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__extends||function(){var e=function(t,n){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(t,n)};return function(t,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function o(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}(),t=this&&this.__read||function(e,t){var n=\"function\"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var o,s,r=n.call(e),i=[];try{for(;(void 0===t||t-- >0)&&!(o=r.next()).done;)i.push(o.value)}catch(c){s={error:c}}finally{try{o&&!o.done&&(n=r.return)&&n.call(r)}finally{if(s)throw s.error}}return i},n=this&&this.__spreadArray||function(e,t){for(var n=0,o=t.length,s=e.length;n<o;n++,s++)e[s]=t[n];return e},o=this&&this.__values||function(e){var t=\"function\"==typeof Symbol&&Symbol.iterator,n=t&&e[t],o=0;if(n)return n.call(e);if(e&&\"number\"==typeof e.length)return{next:function(){return e&&o>=e.length&&(e=void 0),{value:e&&e[o++],done:!e}}};throw new TypeError(t?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")},s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Socket=void 0;var r=require(\"eventemitter3\"),i=s(require(\"./logger\")),c=require(\"./enums\"),a=function(s){function r(e,t,n,o,r,i){void 0===i&&(i=5e3);var c=s.call(this)||this;c.pingInterval=i,c._disconnected=!0,c._messagesQueue=[];var a=e?\"wss://\":\"ws://\";return c._baseUrl=a+t+\":\"+n+o+\"peerjs?key=\"+r,c}return e(r,s),r.prototype.start=function(e,t){var n=this;this._id=e;var o=this._baseUrl+\"&id=\"+e+\"&token=\"+t;!this._socket&&this._disconnected&&(this._socket=new WebSocket(o),this._disconnected=!1,this._socket.onmessage=function(e){var t;try{t=JSON.parse(e.data),i.default.log(\"Server message received:\",t)}catch(o){return void i.default.log(\"Invalid server message\",e.data)}n.emit(c.SocketEventType.Message,t)},this._socket.onclose=function(e){n._disconnected||(i.default.log(\"Socket closed.\",e),n._cleanup(),n._disconnected=!0,n.emit(c.SocketEventType.Disconnected))},this._socket.onopen=function(){n._disconnected||(n._sendQueuedMessages(),i.default.log(\"Socket open\"),n._scheduleHeartbeat())})},r.prototype._scheduleHeartbeat=function(){var e=this;this._wsPingTimer=setTimeout(function(){e._sendHeartbeat()},this.pingInterval)},r.prototype._sendHeartbeat=function(){if(this._wsOpen()){var e=JSON.stringify({type:c.ServerMessageType.Heartbeat});this._socket.send(e),this._scheduleHeartbeat()}else i.default.log(\"Cannot send heartbeat, because socket closed\")},r.prototype._wsOpen=function(){return!!this._socket&&1===this._socket.readyState},r.prototype._sendQueuedMessages=function(){var e,s,r=n([],t(this._messagesQueue));this._messagesQueue=[];try{for(var i=o(r),c=i.next();!c.done;c=i.next()){var a=c.value;this.send(a)}}catch(u){e={error:u}}finally{try{c&&!c.done&&(s=i.return)&&s.call(i)}finally{if(e)throw e.error}}},r.prototype.send=function(e){if(!this._disconnected)if(this._id)if(e.type){if(this._wsOpen()){var t=JSON.stringify(e);this._socket.send(t)}}else this.emit(c.SocketEventType.Error,\"Invalid message\");else this._messagesQueue.push(e)},r.prototype.close=function(){this._disconnected||(this._cleanup(),this._disconnected=!0)},r.prototype._cleanup=function(){this._socket&&(this._socket.onopen=this._socket.onmessage=this._socket.onclose=null,this._socket.close(),this._socket=void 0),clearTimeout(this._wsPingTimer)},r}(r.EventEmitter);exports.Socket=a;\n},{\"eventemitter3\":\"JJlS\",\"./logger\":\"WOs9\",\"./enums\":\"ZRYf\"}],\"HCdX\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__assign||function(){return(e=Object.assign||function(e){for(var n,t=1,o=arguments.length;t<o;t++)for(var i in n=arguments[t])Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i]);return e}).apply(this,arguments)},n=this&&this.__awaiter||function(e,n,t,o){return new(t||(t=Promise))(function(i,r){function c(e){try{s(o.next(e))}catch(n){r(n)}}function a(e){try{s(o.throw(e))}catch(n){r(n)}}function s(e){var n;e.done?i(e.value):(n=e.value,n instanceof t?n:new t(function(e){e(n)})).then(c,a)}s((o=o.apply(e,n||[])).next())})},t=this&&this.__generator||function(e,n){var t,o,i,r,c={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},\"function\"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function a(r){return function(a){return function(r){if(t)throw new TypeError(\"Generator is already executing.\");for(;c;)try{if(t=1,o&&(i=2&r[0]?o.return:r[0]?o.throw||((i=o.return)&&i.call(o),0):o.next)&&!(i=i.call(o,r[1])).done)return i;switch(o=0,i&&(r=[2&r[0],i.value]),r[0]){case 0:case 1:i=r;break;case 4:return c.label++,{value:r[1],done:!1};case 5:c.label++,o=r[1],r=[0];continue;case 7:r=c.ops.pop(),c.trys.pop();continue;default:if(!(i=(i=c.trys).length>0&&i[i.length-1])&&(6===r[0]||2===r[0])){c=0;continue}if(3===r[0]&&(!i||r[1]>i[0]&&r[1]<i[3])){c.label=r[1];break}if(6===r[0]&&c.label<i[1]){c.label=i[1],i=r;break}if(i&&c.label<i[2]){c.label=i[2],c.ops.push(r);break}i[2]&&c.ops.pop(),c.trys.pop();continue}r=n.call(e,c)}catch(a){r=[6,a],o=0}finally{t=i=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,a])}}},o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Negotiator=void 0;var i=require(\"./util\"),r=o(require(\"./logger\")),c=require(\"./enums\"),a=function(){function o(e){this.connection=e}return o.prototype.startConnection=function(e){var n=this._startPeerConnection();if(this.connection.peerConnection=n,this.connection.type===c.ConnectionType.Media&&e._stream&&this._addTracksToConnection(e._stream,n),e.originator){if(this.connection.type===c.ConnectionType.Data){var t=this.connection,o={ordered:!!e.reliable},i=n.createDataChannel(t.label,o);t.initialize(i)}this._makeOffer()}else this.handleSDP(\"OFFER\",e.sdp)},o.prototype._startPeerConnection=function(){r.default.log(\"Creating RTCPeerConnection.\");var e=new RTCPeerConnection(this.connection.provider.options.config);return this._setupListeners(e),e},o.prototype._setupListeners=function(e){var n=this,t=this.connection.peer,o=this.connection.connectionId,a=this.connection.type,s=this.connection.provider;r.default.log(\"Listening for ICE candidates.\"),e.onicecandidate=function(e){e.candidate&&e.candidate.candidate&&(r.default.log(\"Received ICE candidates for \"+t+\":\",e.candidate),s.socket.send({type:c.ServerMessageType.Candidate,payload:{candidate:e.candidate,type:a,connectionId:o},dst:t}))},e.oniceconnectionstatechange=function(){switch(e.iceConnectionState){case\"failed\":r.default.log(\"iceConnectionState is failed, closing connections to \"+t),n.connection.emit(c.ConnectionEventType.Error,new Error(\"Negotiation of connection to \"+t+\" failed.\")),n.connection.close();break;case\"closed\":r.default.log(\"iceConnectionState is closed, closing connections to \"+t),n.connection.emit(c.ConnectionEventType.Error,new Error(\"Connection to \"+t+\" closed.\")),n.connection.close();break;case\"disconnected\":r.default.log(\"iceConnectionState changed to disconnected on the connection with \"+t);break;case\"completed\":e.onicecandidate=i.util.noop}n.connection.emit(c.ConnectionEventType.IceStateChanged,e.iceConnectionState)},r.default.log(\"Listening for data channel\"),e.ondatachannel=function(e){r.default.log(\"Received data channel\");var n=e.channel;s.getConnection(t,o).initialize(n)},r.default.log(\"Listening for remote stream\"),e.ontrack=function(e){r.default.log(\"Received remote stream\");var i=e.streams[0],a=s.getConnection(t,o);if(a.type===c.ConnectionType.Media){var d=a;n._addStreamToMediaConnection(i,d)}}},o.prototype.cleanup=function(){r.default.log(\"Cleaning up PeerConnection to \"+this.connection.peer);var e=this.connection.peerConnection;if(e){this.connection.peerConnection=null,e.onicecandidate=e.oniceconnectionstatechange=e.ondatachannel=e.ontrack=function(){};var n=\"closed\"!==e.signalingState,t=!1;if(this.connection.type===c.ConnectionType.Data){var o=this.connection.dataChannel;o&&(t=!!o.readyState&&\"closed\"!==o.readyState)}(n||t)&&e.close()}},o.prototype._makeOffer=function(){return n(this,void 0,Promise,function(){var n,o,a,s,d,l,u;return t(this,function(t){switch(t.label){case 0:n=this.connection.peerConnection,o=this.connection.provider,t.label=1;case 1:return t.trys.push([1,7,,8]),[4,n.createOffer(this.connection.options.constraints)];case 2:a=t.sent(),r.default.log(\"Created offer.\"),this.connection.options.sdpTransform&&\"function\"==typeof this.connection.options.sdpTransform&&(a.sdp=this.connection.options.sdpTransform(a.sdp)||a.sdp),t.label=3;case 3:return t.trys.push([3,5,,6]),[4,n.setLocalDescription(a)];case 4:return t.sent(),r.default.log(\"Set localDescription:\",a,\"for:\"+this.connection.peer),s={sdp:a,type:this.connection.type,connectionId:this.connection.connectionId,metadata:this.connection.metadata,browser:i.util.browser},this.connection.type===c.ConnectionType.Data&&(d=this.connection,s=e(e({},s),{label:d.label,reliable:d.reliable,serialization:d.serialization})),o.socket.send({type:c.ServerMessageType.Offer,payload:s,dst:this.connection.peer}),[3,6];case 5:return\"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\"!=(l=t.sent())&&(o.emitError(c.PeerErrorType.WebRTC,l),r.default.log(\"Failed to setLocalDescription, \",l)),[3,6];case 6:return[3,8];case 7:return u=t.sent(),o.emitError(c.PeerErrorType.WebRTC,u),r.default.log(\"Failed to createOffer, \",u),[3,8];case 8:return[2]}})})},o.prototype._makeAnswer=function(){return n(this,void 0,Promise,function(){var e,n,o,a,s;return t(this,function(t){switch(t.label){case 0:e=this.connection.peerConnection,n=this.connection.provider,t.label=1;case 1:return t.trys.push([1,7,,8]),[4,e.createAnswer()];case 2:o=t.sent(),r.default.log(\"Created answer.\"),this.connection.options.sdpTransform&&\"function\"==typeof this.connection.options.sdpTransform&&(o.sdp=this.connection.options.sdpTransform(o.sdp)||o.sdp),t.label=3;case 3:return t.trys.push([3,5,,6]),[4,e.setLocalDescription(o)];case 4:return t.sent(),r.default.log(\"Set localDescription:\",o,\"for:\"+this.connection.peer),n.socket.send({type:c.ServerMessageType.Answer,payload:{sdp:o,type:this.connection.type,connectionId:this.connection.connectionId,browser:i.util.browser},dst:this.connection.peer}),[3,6];case 5:return a=t.sent(),n.emitError(c.PeerErrorType.WebRTC,a),r.default.log(\"Failed to setLocalDescription, \",a),[3,6];case 6:return[3,8];case 7:return s=t.sent(),n.emitError(c.PeerErrorType.WebRTC,s),r.default.log(\"Failed to create answer, \",s),[3,8];case 8:return[2]}})})},o.prototype.handleSDP=function(e,o){return n(this,void 0,Promise,function(){var n,i,a,s;return t(this,function(t){switch(t.label){case 0:o=new RTCSessionDescription(o),n=this.connection.peerConnection,i=this.connection.provider,r.default.log(\"Setting remote description\",o),a=this,t.label=1;case 1:return t.trys.push([1,5,,6]),[4,n.setRemoteDescription(o)];case 2:return t.sent(),r.default.log(\"Set remoteDescription:\"+e+\" for:\"+this.connection.peer),\"OFFER\"!==e?[3,4]:[4,a._makeAnswer()];case 3:t.sent(),t.label=4;case 4:return[3,6];case 5:return s=t.sent(),i.emitError(c.PeerErrorType.WebRTC,s),r.default.log(\"Failed to setRemoteDescription, \",s),[3,6];case 6:return[2]}})})},o.prototype.handleCandidate=function(e){return n(this,void 0,Promise,function(){var n,o,i,a,s,d;return t(this,function(t){switch(t.label){case 0:r.default.log(\"handleCandidate:\",e),n=e.candidate,o=e.sdpMLineIndex,i=e.sdpMid,a=this.connection.peerConnection,s=this.connection.provider,t.label=1;case 1:return t.trys.push([1,3,,4]),[4,a.addIceCandidate(new RTCIceCandidate({sdpMid:i,sdpMLineIndex:o,candidate:n}))];case 2:return t.sent(),r.default.log(\"Added ICE candidate for:\"+this.connection.peer),[3,4];case 3:return d=t.sent(),s.emitError(c.PeerErrorType.WebRTC,d),r.default.log(\"Failed to handleCandidate, \",d),[3,4];case 4:return[2]}})})},o.prototype._addTracksToConnection=function(e,n){if(r.default.log(\"add tracks from stream \"+e.id+\" to peer connection\"),!n.addTrack)return r.default.error(\"Your browser does't support RTCPeerConnection#addTrack. Ignored.\");e.getTracks().forEach(function(t){n.addTrack(t,e)})},o.prototype._addStreamToMediaConnection=function(e,n){r.default.log(\"add stream \"+e.id+\" to media connection \"+n.connectionId),n.addStream(e)},o}();exports.Negotiator=a;\n},{\"./util\":\"BHXf\",\"./logger\":\"WOs9\",\"./enums\":\"ZRYf\"}],\"tQFK\":[function(require,module,exports) {\n\"use strict\";var t=this&&this.__extends||function(){var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])})(e,n)};return function(e,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function o(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}();Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.BaseConnection=void 0;var e=require(\"eventemitter3\"),n=function(e){function n(t,n,o){var r=e.call(this)||this;return r.peer=t,r.provider=n,r.options=o,r._open=!1,r.metadata=o.metadata,r}return t(n,e),Object.defineProperty(n.prototype,\"open\",{get:function(){return this._open},enumerable:!1,configurable:!0}),n}(e.EventEmitter);exports.BaseConnection=n;\n},{\"eventemitter3\":\"JJlS\"}],\"dbHP\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__extends||function(){var e=function(t,o){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])})(t,o)};return function(t,o){if(\"function\"!=typeof o&&null!==o)throw new TypeError(\"Class extends value \"+String(o)+\" is not a constructor or null\");function r(){this.constructor=t}e(t,o),t.prototype=null===o?Object.create(o):(r.prototype=o.prototype,new r)}}(),t=this&&this.__assign||function(){return(t=Object.assign||function(e){for(var t,o=1,r=arguments.length;o<r;o++)for(var n in t=arguments[o])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}).apply(this,arguments)},o=this&&this.__values||function(e){var t=\"function\"==typeof Symbol&&Symbol.iterator,o=t&&e[t],r=0;if(o)return o.call(e);if(e&&\"number\"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")},r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.MediaConnection=void 0;var n=require(\"./util\"),i=r(require(\"./logger\")),a=require(\"./negotiator\"),s=require(\"./enums\"),l=require(\"./baseconnection\"),c=function(r){function l(e,t,o){var i=r.call(this,e,t,o)||this;return i._localStream=i.options._stream,i.connectionId=i.options.connectionId||l.ID_PREFIX+n.util.randomToken(),i._negotiator=new a.Negotiator(i),i._localStream&&i._negotiator.startConnection({_stream:i._localStream,originator:!0}),i}return e(l,r),Object.defineProperty(l.prototype,\"type\",{get:function(){return s.ConnectionType.Media},enumerable:!1,configurable:!0}),Object.defineProperty(l.prototype,\"localStream\",{get:function(){return this._localStream},enumerable:!1,configurable:!0}),Object.defineProperty(l.prototype,\"remoteStream\",{get:function(){return this._remoteStream},enumerable:!1,configurable:!0}),l.prototype.addStream=function(e){i.default.log(\"Receiving stream\",e),this._remoteStream=e,r.prototype.emit.call(this,s.ConnectionEventType.Stream,e)},l.prototype.handleMessage=function(e){var t=e.type,o=e.payload;switch(e.type){case s.ServerMessageType.Answer:this._negotiator.handleSDP(t,o.sdp),this._open=!0;break;case s.ServerMessageType.Candidate:this._negotiator.handleCandidate(o.candidate);break;default:i.default.warn(\"Unrecognized message type:\"+t+\" from peer:\"+this.peer)}},l.prototype.answer=function(e,r){var n,a;if(void 0===r&&(r={}),this._localStream)i.default.warn(\"Local stream already exists on this MediaConnection. Are you answering a call twice?\");else{this._localStream=e,r&&r.sdpTransform&&(this.options.sdpTransform=r.sdpTransform),this._negotiator.startConnection(t(t({},this.options._payload),{_stream:e}));var s=this.provider._getMessages(this.connectionId);try{for(var l=o(s),c=l.next();!c.done;c=l.next()){var p=c.value;this.handleMessage(p)}}catch(u){n={error:u}}finally{try{c&&!c.done&&(a=l.return)&&a.call(l)}finally{if(n)throw n.error}}this._open=!0}},l.prototype.close=function(){this._negotiator&&(this._negotiator.cleanup(),this._negotiator=null),this._localStream=null,this._remoteStream=null,this.provider&&(this.provider._removeConnection(this),this.provider=null),this.options&&this.options._stream&&(this.options._stream=null),this.open&&(this._open=!1,r.prototype.emit.call(this,s.ConnectionEventType.Close))},l.ID_PREFIX=\"mc_\",l}(l.BaseConnection);exports.MediaConnection=c;\n},{\"./util\":\"BHXf\",\"./logger\":\"WOs9\",\"./negotiator\":\"HCdX\",\"./enums\":\"ZRYf\",\"./baseconnection\":\"tQFK\"}],\"GGp6\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__extends||function(){var e=function(t,r){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])})(t,r)};return function(t,r){if(\"function\"!=typeof r&&null!==r)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");function o(){this.constructor=t}e(t,r),t.prototype=null===r?Object.create(r):(o.prototype=r.prototype,new o)}}(),t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.EncodingQueue=void 0;var r=require(\"eventemitter3\"),o=t(require(\"./logger\")),n=function(t){function r(){var e=t.call(this)||this;return e.fileReader=new FileReader,e._queue=[],e._processing=!1,e.fileReader.onload=function(t){e._processing=!1,t.target&&e.emit(\"done\",t.target.result),e.doNextTask()},e.fileReader.onerror=function(t){o.default.error(\"EncodingQueue error:\",t),e._processing=!1,e.destroy(),e.emit(\"error\",t)},e}return e(r,t),Object.defineProperty(r.prototype,\"queue\",{get:function(){return this._queue},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,\"size\",{get:function(){return this.queue.length},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,\"processing\",{get:function(){return this._processing},enumerable:!1,configurable:!0}),r.prototype.enque=function(e){this.queue.push(e),this.processing||this.doNextTask()},r.prototype.destroy=function(){this.fileReader.abort(),this._queue=[]},r.prototype.doNextTask=function(){0!==this.size&&(this.processing||(this._processing=!0,this.fileReader.readAsArrayBuffer(this.queue.shift())))},r}(r.EventEmitter);exports.EncodingQueue=n;\n},{\"eventemitter3\":\"JJlS\",\"./logger\":\"WOs9\"}],\"GBTQ\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__extends||function(){var e=function(t,n){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(t,n)};return function(t,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function i(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(i.prototype=n.prototype,new i)}}(),t=this&&this.__values||function(e){var t=\"function\"==typeof Symbol&&Symbol.iterator,n=t&&e[t],i=0;if(n)return n.call(e);if(e&&\"number\"==typeof e.length)return{next:function(){return e&&i>=e.length&&(e=void 0),{value:e&&e[i++],done:!e}}};throw new TypeError(t?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")},n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.DataConnection=void 0;var i=require(\"./util\"),o=n(require(\"./logger\")),r=require(\"./negotiator\"),a=require(\"./enums\"),s=require(\"./baseconnection\"),u=require(\"./encodingQueue\"),l=function(n){function s(e,t,l){var f=n.call(this,e,t,l)||this;return f.stringify=JSON.stringify,f.parse=JSON.parse,f._buffer=[],f._bufferSize=0,f._buffering=!1,f._chunkedData={},f._encodingQueue=new u.EncodingQueue,f.connectionId=f.options.connectionId||s.ID_PREFIX+i.util.randomToken(),f.label=f.options.label||f.connectionId,f.serialization=f.options.serialization||a.SerializationType.Binary,f.reliable=!!f.options.reliable,f._encodingQueue.on(\"done\",function(e){f._bufferedSend(e)}),f._encodingQueue.on(\"error\",function(){o.default.error(\"DC#\"+f.connectionId+\": Error occured in encoding from blob to arraybuffer, close DC\"),f.close()}),f._negotiator=new r.Negotiator(f),f._negotiator.startConnection(f.options._payload||{originator:!0}),f}return e(s,n),Object.defineProperty(s.prototype,\"type\",{get:function(){return a.ConnectionType.Data},enumerable:!1,configurable:!0}),Object.defineProperty(s.prototype,\"dataChannel\",{get:function(){return this._dc},enumerable:!1,configurable:!0}),Object.defineProperty(s.prototype,\"bufferSize\",{get:function(){return this._bufferSize},enumerable:!1,configurable:!0}),s.prototype.initialize=function(e){this._dc=e,this._configureDataChannel()},s.prototype._configureDataChannel=function(){var e=this;i.util.supports.binaryBlob&&!i.util.supports.reliable||(this.dataChannel.binaryType=\"arraybuffer\"),this.dataChannel.onopen=function(){o.default.log(\"DC#\"+e.connectionId+\" dc connection success\"),e._open=!0,e.emit(a.ConnectionEventType.Open)},this.dataChannel.onmessage=function(t){o.default.log(\"DC#\"+e.connectionId+\" dc onmessage:\",t.data),e._handleDataMessage(t)},this.dataChannel.onclose=function(){o.default.log(\"DC#\"+e.connectionId+\" dc closed for:\",e.peer),e.close()}},s.prototype._handleDataMessage=function(e){var t=this,o=e.data,r=o.constructor,s=o;if(this.serialization===a.SerializationType.Binary||this.serialization===a.SerializationType.BinaryUTF8){if(r===Blob)return void i.util.blobToArrayBuffer(o,function(e){var n=i.util.unpack(e);t.emit(a.ConnectionEventType.Data,n)});if(r===ArrayBuffer)s=i.util.unpack(o);else if(r===String){var u=i.util.binaryStringToArrayBuffer(o);s=i.util.unpack(u)}}else this.serialization===a.SerializationType.JSON&&(s=this.parse(o));s.__peerData?this._handleChunk(s):n.prototype.emit.call(this,a.ConnectionEventType.Data,s)},s.prototype._handleChunk=function(e){var t=e.__peerData,n=this._chunkedData[t]||{data:[],count:0,total:e.total};if(n.data[e.n]=e.data,n.count++,this._chunkedData[t]=n,n.total===n.count){delete this._chunkedData[t];var i=new Blob(n.data);this._handleDataMessage({data:i})}},s.prototype.close=function(){this._buffer=[],this._bufferSize=0,this._chunkedData={},this._negotiator&&(this._negotiator.cleanup(),this._negotiator=null),this.provider&&(this.provider._removeConnection(this),this.provider=null),this.dataChannel&&(this.dataChannel.onopen=null,this.dataChannel.onmessage=null,this.dataChannel.onclose=null,this._dc=null),this._encodingQueue&&(this._encodingQueue.destroy(),this._encodingQueue.removeAllListeners(),this._encodingQueue=null),this.open&&(this._open=!1,n.prototype.emit.call(this,a.ConnectionEventType.Close))},s.prototype.send=function(e,t){if(this.open)if(this.serialization===a.SerializationType.JSON)this._bufferedSend(this.stringify(e));else if(this.serialization===a.SerializationType.Binary||this.serialization===a.SerializationType.BinaryUTF8){var o=i.util.pack(e);if(!t&&o.size>i.util.chunkedMTU)return void this._sendChunks(o);i.util.supports.binaryBlob?this._bufferedSend(o):this._encodingQueue.enque(o)}else this._bufferedSend(e);else n.prototype.emit.call(this,a.ConnectionEventType.Error,new Error(\"Connection is not open. You should listen for the `open` event before sending messages.\"))},s.prototype._bufferedSend=function(e){!this._buffering&&this._trySend(e)||(this._buffer.push(e),this._bufferSize=this._buffer.length)},s.prototype._trySend=function(e){var t=this;if(!this.open)return!1;if(this.dataChannel.bufferedAmount>s.MAX_BUFFERED_AMOUNT)return this._buffering=!0,setTimeout(function(){t._buffering=!1,t._tryBuffer()},50),!1;try{this.dataChannel.send(e)}catch(n){return o.default.error(\"DC#:\"+this.connectionId+\" Error when sending:\",n),this._buffering=!0,this.close(),!1}return!0},s.prototype._tryBuffer=function(){if(this.open&&0!==this._buffer.length){var e=this._buffer[0];this._trySend(e)&&(this._buffer.shift(),this._bufferSize=this._buffer.length,this._tryBuffer())}},s.prototype._sendChunks=function(e){var n,r,a=i.util.chunk(e);o.default.log(\"DC#\"+this.connectionId+\" Try to send \"+a.length+\" chunks...\");try{for(var s=t(a),u=s.next();!u.done;u=s.next()){var l=u.value;this.send(l,!0)}}catch(f){n={error:f}}finally{try{u&&!u.done&&(r=s.return)&&r.call(s)}finally{if(n)throw n.error}}},s.prototype.handleMessage=function(e){var t=e.payload;switch(e.type){case a.ServerMessageType.Answer:this._negotiator.handleSDP(e.type,t.sdp);break;case a.ServerMessageType.Candidate:this._negotiator.handleCandidate(t.candidate);break;default:o.default.warn(\"Unrecognized message type:\",e.type,\"from peer:\",this.peer)}},s.ID_PREFIX=\"dc_\",s.MAX_BUFFERED_AMOUNT=8388608,s}(s.BaseConnection);exports.DataConnection=l;\n},{\"./util\":\"BHXf\",\"./logger\":\"WOs9\",\"./negotiator\":\"HCdX\",\"./enums\":\"ZRYf\",\"./baseconnection\":\"tQFK\",\"./encodingQueue\":\"GGp6\"}],\"in7L\":[function(require,module,exports) {\n\"use strict\";var t=this&&this.__awaiter||function(t,e,r,o){return new(r||(r=Promise))(function(n,s){function i(t){try{a(o.next(t))}catch(e){s(e)}}function u(t){try{a(o.throw(t))}catch(e){s(e)}}function a(t){var e;t.done?n(t.value):(e=t.value,e instanceof r?e:new r(function(t){t(e)})).then(i,u)}a((o=o.apply(t,e||[])).next())})},e=this&&this.__generator||function(t,e){var r,o,n,s,i={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return s={next:u(0),throw:u(1),return:u(2)},\"function\"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function u(s){return function(u){return function(s){if(r)throw new TypeError(\"Generator is already executing.\");for(;i;)try{if(r=1,o&&(n=2&s[0]?o.return:s[0]?o.throw||((n=o.return)&&n.call(o),0):o.next)&&!(n=n.call(o,s[1])).done)return n;switch(o=0,n&&(s=[2&s[0],n.value]),s[0]){case 0:case 1:n=s;break;case 4:return i.label++,{value:s[1],done:!1};case 5:i.label++,o=s[1],s=[0];continue;case 7:s=i.ops.pop(),i.trys.pop();continue;default:if(!(n=(n=i.trys).length>0&&n[n.length-1])&&(6===s[0]||2===s[0])){i=0;continue}if(3===s[0]&&(!n||s[1]>n[0]&&s[1]<n[3])){i.label=s[1];break}if(6===s[0]&&i.label<n[1]){i.label=n[1],n=s;break}if(n&&i.label<n[2]){i.label=n[2],i.ops.push(s);break}n[2]&&i.ops.pop(),i.trys.pop();continue}s=e.call(t,i)}catch(u){s=[6,u],o=0}finally{r=n=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,u])}}},r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.API=void 0;var o=require(\"./util\"),n=r(require(\"./logger\")),s=function(){function r(t){this._options=t}return r.prototype._buildUrl=function(t){var e=(this._options.secure?\"https://\":\"http://\")+this._options.host+\":\"+this._options.port+this._options.path+this._options.key+\"/\"+t;return e+=\"?ts=\"+(new Date).getTime()+Math.random()},r.prototype.retrieveId=function(){return t(this,void 0,Promise,function(){var t,r,s,i;return e(this,function(e){switch(e.label){case 0:t=this._buildUrl(\"id\"),e.label=1;case 1:return e.trys.push([1,3,,4]),[4,fetch(t)];case 2:if(200!==(r=e.sent()).status)throw new Error(\"Error. Status:\"+r.status);return[2,r.text()];case 3:throw s=e.sent(),n.default.error(\"Error retrieving ID\",s),i=\"\",\"/\"===this._options.path&&this._options.host!==o.util.CLOUD_HOST&&(i=\" If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer.\"),new Error(\"Could not get an ID from the server.\"+i);case 4:return[2]}})})},r.prototype.listAllPeers=function(){return t(this,void 0,Promise,function(){var t,r,s,i;return e(this,function(e){switch(e.label){case 0:t=this._buildUrl(\"peers\"),e.label=1;case 1:return e.trys.push([1,3,,4]),[4,fetch(t)];case 2:if(200!==(r=e.sent()).status){if(401===r.status)throw s=\"\",s=this._options.host===o.util.CLOUD_HOST?\"It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.\":\"You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.\",new Error(\"It doesn't look like you have permission to list peers IDs. \"+s);throw new Error(\"Error. Status:\"+r.status)}return[2,r.json()];case 3:throw i=e.sent(),n.default.error(\"Error retrieving list peers\",i),new Error(\"Could not get list peers from the server.\"+i);case 4:return[2]}})})},r}();exports.API=s;\n},{\"./util\":\"BHXf\",\"./logger\":\"WOs9\"}],\"Hxpd\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__extends||function(){var e=function(t,n){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(t,n)};return function(t,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function r(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),t=this&&this.__assign||function(){return(t=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var o in t=arguments[n])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e}).apply(this,arguments)},n=this&&this.__values||function(e){var t=\"function\"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&\"number\"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")},r=this&&this.__read||function(e,t){var n=\"function\"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,o,i=n.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(r=i.next()).done;)s.push(r.value)}catch(a){o={error:a}}finally{try{r&&!r.done&&(n=i.return)&&n.call(i)}finally{if(o)throw o.error}}return s},o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Peer=void 0;var i=require(\"eventemitter3\"),s=require(\"./util\"),a=o(require(\"./logger\")),c=require(\"./socket\"),l=require(\"./mediaconnection\"),u=require(\"./dataconnection\"),d=require(\"./enums\"),p=require(\"./api\"),h=function(){return function(){}}(),f=function(o){function i(e,n){var r,c=o.call(this)||this;return c._id=null,c._lastServerId=null,c._destroyed=!1,c._disconnected=!1,c._open=!1,c._connections=new Map,c._lostMessages=new Map,e&&e.constructor==Object?n=e:e&&(r=e.toString()),n=t({debug:0,host:s.util.CLOUD_HOST,port:s.util.CLOUD_PORT,path:\"/\",key:i.DEFAULT_KEY,token:s.util.randomToken(),config:s.util.defaultConfig},n),c._options=n,\"/\"===c._options.host&&(c._options.host=window.location.hostname),c._options.path&&(\"/\"!==c._options.path[0]&&(c._options.path=\"/\"+c._options.path),\"/\"!==c._options.path[c._options.path.length-1]&&(c._options.path+=\"/\")),void 0===c._options.secure&&c._options.host!==s.util.CLOUD_HOST?c._options.secure=s.util.isSecure():c._options.host==s.util.CLOUD_HOST&&(c._options.secure=!0),c._options.logFunction&&a.default.setLogFunction(c._options.logFunction),a.default.logLevel=c._options.debug||0,c._api=new p.API(n),c._socket=c._createServerConnection(),s.util.supports.audioVideo||s.util.supports.data?r&&!s.util.validateId(r)?(c._delayedAbort(d.PeerErrorType.InvalidID,'ID \"'+r+'\" is invalid'),c):(r?c._initialize(r):c._api.retrieveId().then(function(e){return c._initialize(e)}).catch(function(e){return c._abort(d.PeerErrorType.ServerError,e)}),c):(c._delayedAbort(d.PeerErrorType.BrowserIncompatible,\"The current browser does not support WebRTC\"),c)}return e(i,o),Object.defineProperty(i.prototype,\"id\",{get:function(){return this._id},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"options\",{get:function(){return this._options},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"open\",{get:function(){return this._open},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"socket\",{get:function(){return this._socket},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"connections\",{get:function(){var e,t,o=Object.create(null);try{for(var i=n(this._connections),s=i.next();!s.done;s=i.next()){var a=r(s.value,2),c=a[0],l=a[1];o[c]=l}}catch(u){e={error:u}}finally{try{s&&!s.done&&(t=i.return)&&t.call(i)}finally{if(e)throw e.error}}return o},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"destroyed\",{get:function(){return this._destroyed},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"disconnected\",{get:function(){return this._disconnected},enumerable:!1,configurable:!0}),i.prototype._createServerConnection=function(){var e=this,t=new c.Socket(this._options.secure,this._options.host,this._options.port,this._options.path,this._options.key,this._options.pingInterval);return t.on(d.SocketEventType.Message,function(t){e._handleMessage(t)}),t.on(d.SocketEventType.Error,function(t){e._abort(d.PeerErrorType.SocketError,t)}),t.on(d.SocketEventType.Disconnected,function(){e.disconnected||(e.emitError(d.PeerErrorType.Network,\"Lost connection to server.\"),e.disconnect())}),t.on(d.SocketEventType.Close,function(){e.disconnected||e._abort(d.PeerErrorType.SocketClosed,\"Underlying socket is already closed.\")}),t},i.prototype._initialize=function(e){this._id=e,this.socket.start(e,this._options.token)},i.prototype._handleMessage=function(e){var t,r,o=e.type,i=e.payload,s=e.src;switch(o){case d.ServerMessageType.Open:this._lastServerId=this.id,this._open=!0,this.emit(d.PeerEventType.Open,this.id);break;case d.ServerMessageType.Error:this._abort(d.PeerErrorType.ServerError,i.msg);break;case d.ServerMessageType.IdTaken:this._abort(d.PeerErrorType.UnavailableID,'ID \"'+this.id+'\" is taken');break;case d.ServerMessageType.InvalidKey:this._abort(d.PeerErrorType.InvalidKey,'API KEY \"'+this._options.key+'\" is invalid');break;case d.ServerMessageType.Leave:a.default.log(\"Received leave message from \"+s),this._cleanupPeer(s),this._connections.delete(s);break;case d.ServerMessageType.Expire:this.emitError(d.PeerErrorType.PeerUnavailable,\"Could not connect to peer \"+s);break;case d.ServerMessageType.Offer:var c=i.connectionId;if((_=this.getConnection(s,c))&&(_.close(),a.default.warn(\"Offer received for existing Connection ID:\"+c)),i.type===d.ConnectionType.Media)_=new l.MediaConnection(s,this,{connectionId:c,_payload:i,metadata:i.metadata}),this._addConnection(s,_),this.emit(d.PeerEventType.Call,_);else{if(i.type!==d.ConnectionType.Data)return void a.default.warn(\"Received malformed connection type:\"+i.type);_=new u.DataConnection(s,this,{connectionId:c,_payload:i,metadata:i.metadata,label:i.label,serialization:i.serialization,reliable:i.reliable}),this._addConnection(s,_),this.emit(d.PeerEventType.Connection,_)}var p=this._getMessages(c);try{for(var h=n(p),f=h.next();!f.done;f=h.next()){var y=f.value;_.handleMessage(y)}}catch(v){t={error:v}}finally{try{f&&!f.done&&(r=h.return)&&r.call(h)}finally{if(t)throw t.error}}break;default:if(!i)return void a.default.warn(\"You received a malformed message from \"+s+\" of type \"+o);var _;c=i.connectionId;(_=this.getConnection(s,c))&&_.peerConnection?_.handleMessage(e):c?this._storeMessage(c,e):a.default.warn(\"You received an unrecognized message:\",e)}},i.prototype._storeMessage=function(e,t){this._lostMessages.has(e)||this._lostMessages.set(e,[]),this._lostMessages.get(e).push(t)},i.prototype._getMessages=function(e){var t=this._lostMessages.get(e);return t?(this._lostMessages.delete(e),t):[]},i.prototype.connect=function(e,t){if(void 0===t&&(t={}),this.disconnected)return a.default.warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available.\"),void this.emitError(d.PeerErrorType.Disconnected,\"Cannot connect to new Peer after disconnecting from server.\");var n=new u.DataConnection(e,this,t);return this._addConnection(e,n),n},i.prototype.call=function(e,t,n){if(void 0===n&&(n={}),this.disconnected)return a.default.warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect.\"),void this.emitError(d.PeerErrorType.Disconnected,\"Cannot connect to new Peer after disconnecting from server.\");if(t){n._stream=t;var r=new l.MediaConnection(e,this,n);return this._addConnection(e,r),r}a.default.error(\"To call a peer, you must provide a stream from your browser's `getUserMedia`.\")},i.prototype._addConnection=function(e,t){a.default.log(\"add connection \"+t.type+\":\"+t.connectionId+\" to peerId:\"+e),this._connections.has(e)||this._connections.set(e,[]),this._connections.get(e).push(t)},i.prototype._removeConnection=function(e){var t=this._connections.get(e.peer);if(t){var n=t.indexOf(e);-1!==n&&t.splice(n,1)}this._lostMessages.delete(e.connectionId)},i.prototype.getConnection=function(e,t){var r,o,i=this._connections.get(e);if(!i)return null;try{for(var s=n(i),a=s.next();!a.done;a=s.next()){var c=a.value;if(c.connectionId===t)return c}}catch(l){r={error:l}}finally{try{a&&!a.done&&(o=s.return)&&o.call(s)}finally{if(r)throw r.error}}return null},i.prototype._delayedAbort=function(e,t){var n=this;setTimeout(function(){n._abort(e,t)},0)},i.prototype._abort=function(e,t){a.default.error(\"Aborting!\"),this.emitError(e,t),this._lastServerId?this.disconnect():this.destroy()},i.prototype.emitError=function(e,t){var n;a.default.error(\"Error:\",t),(n=\"string\"==typeof t?new Error(t):t).type=e,this.emit(d.PeerEventType.Error,n)},i.prototype.destroy=function(){this.destroyed||(a.default.log(\"Destroy peer with ID:\"+this.id),this.disconnect(),this._cleanup(),this._destroyed=!0,this.emit(d.PeerEventType.Close))},i.prototype._cleanup=function(){var e,t;try{for(var r=n(this._connections.keys()),o=r.next();!o.done;o=r.next()){var i=o.value;this._cleanupPeer(i),this._connections.delete(i)}}catch(s){e={error:s}}finally{try{o&&!o.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}this.socket.removeAllListeners()},i.prototype._cleanupPeer=function(e){var t,r,o=this._connections.get(e);if(o)try{for(var i=n(o),s=i.next();!s.done;s=i.next()){s.value.close()}}catch(a){t={error:a}}finally{try{s&&!s.done&&(r=i.return)&&r.call(i)}finally{if(t)throw t.error}}},i.prototype.disconnect=function(){if(!this.disconnected){var e=this.id;a.default.log(\"Disconnect peer with ID:\"+e),this._disconnected=!0,this._open=!1,this.socket.close(),this._lastServerId=e,this._id=null,this.emit(d.PeerEventType.Disconnected,e)}},i.prototype.reconnect=function(){if(this.disconnected&&!this.destroyed)a.default.log(\"Attempting reconnection to server with ID \"+this._lastServerId),this._disconnected=!1,this._initialize(this._lastServerId);else{if(this.destroyed)throw new Error(\"This peer cannot reconnect to the server. It has already been destroyed.\");if(this.disconnected||this.open)throw new Error(\"Peer \"+this.id+\" cannot reconnect because it is not disconnected from the server!\");a.default.error(\"In a hurry? We're still trying to make the initial connection!\")}},i.prototype.listAllPeers=function(e){var t=this;void 0===e&&(e=function(e){}),this._api.listAllPeers().then(function(t){return e(t)}).catch(function(e){return t._abort(d.PeerErrorType.ServerError,e)})},i.DEFAULT_KEY=\"peerjs\",i}(i.EventEmitter);exports.Peer=f;\n},{\"eventemitter3\":\"JJlS\",\"./util\":\"BHXf\",\"./logger\":\"WOs9\",\"./socket\":\"wJlv\",\"./mediaconnection\":\"dbHP\",\"./dataconnection\":\"GBTQ\",\"./enums\":\"ZRYf\",\"./api\":\"in7L\"}],\"iTK6\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.peerjs=void 0;var e=require(\"./util\"),r=require(\"./peer\");exports.peerjs={Peer:r.Peer,util:e.util},exports.default=r.Peer,window.peerjs=exports.peerjs,window.Peer=r.Peer;\n},{\"./util\":\"BHXf\",\"./peer\":\"Hxpd\"}]},{},[\"iTK6\"], null)\n//# sourceMappingURL=/peerjs.min.js.map\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/peerjs/dist/peerjs.min.js?");

/***/ }),

/***/ "./node_modules/peerjs/dist sync recursive":
/*!****************************************!*\
  !*** ./node_modules/peerjs/dist/ sync ***!
  \****************************************/
/***/ (function(module) {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/peerjs/dist sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/peerjs/dist/_sync?");

/***/ }),

/***/ "./node_modules/qrcode/lib/browser.js":
/*!********************************************!*\
  !*** ./node_modules/qrcode/lib/browser.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nconst canPromise = __webpack_require__(/*! ./can-promise */ \"./node_modules/qrcode/lib/can-promise.js\")\n\nconst QRCode = __webpack_require__(/*! ./core/qrcode */ \"./node_modules/qrcode/lib/core/qrcode.js\")\nconst CanvasRenderer = __webpack_require__(/*! ./renderer/canvas */ \"./node_modules/qrcode/lib/renderer/canvas.js\")\nconst SvgRenderer = __webpack_require__(/*! ./renderer/svg-tag.js */ \"./node_modules/qrcode/lib/renderer/svg-tag.js\")\n\nfunction renderCanvas (renderFunc, canvas, text, opts, cb) {\n  const args = [].slice.call(arguments, 1)\n  const argsNum = args.length\n  const isLastArgCb = typeof args[argsNum - 1] === 'function'\n\n  if (!isLastArgCb && !canPromise()) {\n    throw new Error('Callback required as last argument')\n  }\n\n  if (isLastArgCb) {\n    if (argsNum < 2) {\n      throw new Error('Too few arguments provided')\n    }\n\n    if (argsNum === 2) {\n      cb = text\n      text = canvas\n      canvas = opts = undefined\n    } else if (argsNum === 3) {\n      if (canvas.getContext && typeof cb === 'undefined') {\n        cb = opts\n        opts = undefined\n      } else {\n        cb = opts\n        opts = text\n        text = canvas\n        canvas = undefined\n      }\n    }\n  } else {\n    if (argsNum < 1) {\n      throw new Error('Too few arguments provided')\n    }\n\n    if (argsNum === 1) {\n      text = canvas\n      canvas = opts = undefined\n    } else if (argsNum === 2 && !canvas.getContext) {\n      opts = text\n      text = canvas\n      canvas = undefined\n    }\n\n    return new Promise(function (resolve, reject) {\n      try {\n        const data = QRCode.create(text, opts)\n        resolve(renderFunc(data, canvas, opts))\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n\n  try {\n    const data = QRCode.create(text, opts)\n    cb(null, renderFunc(data, canvas, opts))\n  } catch (e) {\n    cb(e)\n  }\n}\n\nexports.create = QRCode.create\nexports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render)\nexports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL)\n\n// only svg for now.\nexports.toString = renderCanvas.bind(null, function (data, _, opts) {\n  return SvgRenderer.render(data, opts)\n})\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/browser.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/can-promise.js":
/*!************************************************!*\
  !*** ./node_modules/qrcode/lib/can-promise.js ***!
  \************************************************/
/***/ (function(module) {

eval("// can-promise has a crash in some versions of react native that dont have\n// standard global objects\n// https://github.com/soldair/node-qrcode/issues/157\n\nmodule.exports = function () {\n  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/can-promise.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/alignment-pattern.js":
/*!***********************************************************!*\
  !*** ./node_modules/qrcode/lib/core/alignment-pattern.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/**\n * Alignment pattern are fixed reference pattern in defined positions\n * in a matrix symbology, which enables the decode software to re-synchronise\n * the coordinate mapping of the image modules in the event of moderate amounts\n * of distortion of the image.\n *\n * Alignment patterns are present only in QR Code symbols of version 2 or larger\n * and their number depends on the symbol version.\n */\n\nconst getSymbolSize = (__webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\").getSymbolSize)\n\n/**\n * Calculate the row/column coordinates of the center module of each alignment pattern\n * for the specified QR Code version.\n *\n * The alignment patterns are positioned symmetrically on either side of the diagonal\n * running from the top left corner of the symbol to the bottom right corner.\n *\n * Since positions are simmetrical only half of the coordinates are returned.\n * Each item of the array will represent in turn the x and y coordinate.\n * @see {@link getPositions}\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinate\n */\nexports.getRowColCoords = function getRowColCoords (version) {\n  if (version === 1) return []\n\n  const posCount = Math.floor(version / 7) + 2\n  const size = getSymbolSize(version)\n  const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2\n  const positions = [size - 7] // Last coord is always (size - 7)\n\n  for (let i = 1; i < posCount - 1; i++) {\n    positions[i] = positions[i - 1] - intervals\n  }\n\n  positions.push(6) // First coord is always 6\n\n  return positions.reverse()\n}\n\n/**\n * Returns an array containing the positions of each alignment pattern.\n * Each array's element represent the center point of the pattern as (x, y) coordinates\n *\n * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}\n * and filtering out the items that overlaps with finder pattern\n *\n * @example\n * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.\n * The alignment patterns, therefore, are to be centered on (row, column)\n * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).\n * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns\n * and are not therefore used for alignment patterns.\n *\n * let pos = getPositions(7)\n * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nexports.getPositions = function getPositions (version) {\n  const coords = []\n  const pos = exports.getRowColCoords(version)\n  const posLength = pos.length\n\n  for (let i = 0; i < posLength; i++) {\n    for (let j = 0; j < posLength; j++) {\n      // Skip if position is occupied by finder patterns\n      if ((i === 0 && j === 0) || // top-left\n          (i === 0 && j === posLength - 1) || // bottom-left\n          (i === posLength - 1 && j === 0)) { // top-right\n        continue\n      }\n\n      coords.push([pos[i], pos[j]])\n    }\n  }\n\n  return coords\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/alignment-pattern.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/alphanumeric-data.js":
/*!***********************************************************!*\
  !*** ./node_modules/qrcode/lib/core/alphanumeric-data.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\n\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\nconst ALPHA_NUM_CHARS = [\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n  ' ', '$', '%', '*', '+', '-', '.', '/', ':'\n]\n\nfunction AlphanumericData (data) {\n  this.mode = Mode.ALPHANUMERIC\n  this.data = data\n}\n\nAlphanumericData.getBitsLength = function getBitsLength (length) {\n  return 11 * Math.floor(length / 2) + 6 * (length % 2)\n}\n\nAlphanumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nAlphanumericData.prototype.getBitsLength = function getBitsLength () {\n  return AlphanumericData.getBitsLength(this.data.length)\n}\n\nAlphanumericData.prototype.write = function write (bitBuffer) {\n  let i\n\n  // Input data characters are divided into groups of two characters\n  // and encoded as 11-bit binary codes.\n  for (i = 0; i + 2 <= this.data.length; i += 2) {\n    // The character value of the first character is multiplied by 45\n    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45\n\n    // The character value of the second digit is added to the product\n    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1])\n\n    // The sum is then stored as 11-bit binary number\n    bitBuffer.put(value, 11)\n  }\n\n  // If the number of input data characters is not a multiple of two,\n  // the character value of the final character is encoded as a 6-bit binary number.\n  if (this.data.length % 2) {\n    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6)\n  }\n}\n\nmodule.exports = AlphanumericData\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/alphanumeric-data.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/bit-buffer.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/bit-buffer.js ***!
  \****************************************************/
/***/ (function(module) {

eval("function BitBuffer () {\n  this.buffer = []\n  this.length = 0\n}\n\nBitBuffer.prototype = {\n\n  get: function (index) {\n    const bufIndex = Math.floor(index / 8)\n    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1\n  },\n\n  put: function (num, length) {\n    for (let i = 0; i < length; i++) {\n      this.putBit(((num >>> (length - i - 1)) & 1) === 1)\n    }\n  },\n\n  getLengthInBits: function () {\n    return this.length\n  },\n\n  putBit: function (bit) {\n    const bufIndex = Math.floor(this.length / 8)\n    if (this.buffer.length <= bufIndex) {\n      this.buffer.push(0)\n    }\n\n    if (bit) {\n      this.buffer[bufIndex] |= (0x80 >>> (this.length % 8))\n    }\n\n    this.length++\n  }\n}\n\nmodule.exports = BitBuffer\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/bit-buffer.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/bit-matrix.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/bit-matrix.js ***!
  \****************************************************/
/***/ (function(module) {

eval("/**\n * Helper class to handle QR Code symbol modules\n *\n * @param {Number} size Symbol size\n */\nfunction BitMatrix (size) {\n  if (!size || size < 1) {\n    throw new Error('BitMatrix size must be defined and greater than 0')\n  }\n\n  this.size = size\n  this.data = new Uint8Array(size * size)\n  this.reservedBit = new Uint8Array(size * size)\n}\n\n/**\n * Set bit value at specified location\n * If reserved flag is set, this bit will be ignored during masking process\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n * @param {Boolean} reserved\n */\nBitMatrix.prototype.set = function (row, col, value, reserved) {\n  const index = row * this.size + col\n  this.data[index] = value\n  if (reserved) this.reservedBit[index] = true\n}\n\n/**\n * Returns bit value at specified location\n *\n * @param  {Number}  row\n * @param  {Number}  col\n * @return {Boolean}\n */\nBitMatrix.prototype.get = function (row, col) {\n  return this.data[row * this.size + col]\n}\n\n/**\n * Applies xor operator at specified location\n * (used during masking process)\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n */\nBitMatrix.prototype.xor = function (row, col, value) {\n  this.data[row * this.size + col] ^= value\n}\n\n/**\n * Check if bit at specified location is reserved\n *\n * @param {Number}   row\n * @param {Number}   col\n * @return {Boolean}\n */\nBitMatrix.prototype.isReserved = function (row, col) {\n  return this.reservedBit[row * this.size + col]\n}\n\nmodule.exports = BitMatrix\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/bit-matrix.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/byte-data.js":
/*!***************************************************!*\
  !*** ./node_modules/qrcode/lib/core/byte-data.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const encodeUtf8 = __webpack_require__(/*! encode-utf8 */ \"./node_modules/encode-utf8/index.js\")\nconst Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\n\nfunction ByteData (data) {\n  this.mode = Mode.BYTE\n  this.data = new Uint8Array(encodeUtf8(data))\n}\n\nByteData.getBitsLength = function getBitsLength (length) {\n  return length * 8\n}\n\nByteData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nByteData.prototype.getBitsLength = function getBitsLength () {\n  return ByteData.getBitsLength(this.data.length)\n}\n\nByteData.prototype.write = function (bitBuffer) {\n  for (let i = 0, l = this.data.length; i < l; i++) {\n    bitBuffer.put(this.data[i], 8)\n  }\n}\n\nmodule.exports = ByteData\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/byte-data.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/error-correction-code.js":
/*!***************************************************************!*\
  !*** ./node_modules/qrcode/lib/core/error-correction-code.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const ECLevel = __webpack_require__(/*! ./error-correction-level */ \"./node_modules/qrcode/lib/core/error-correction-level.js\")\r\n\r\nconst EC_BLOCKS_TABLE = [\r\n// L  M  Q  H\r\n  1, 1, 1, 1,\r\n  1, 1, 1, 1,\r\n  1, 1, 2, 2,\r\n  1, 2, 2, 4,\r\n  1, 2, 4, 4,\r\n  2, 4, 4, 4,\r\n  2, 4, 6, 5,\r\n  2, 4, 6, 6,\r\n  2, 5, 8, 8,\r\n  4, 5, 8, 8,\r\n  4, 5, 8, 11,\r\n  4, 8, 10, 11,\r\n  4, 9, 12, 16,\r\n  4, 9, 16, 16,\r\n  6, 10, 12, 18,\r\n  6, 10, 17, 16,\r\n  6, 11, 16, 19,\r\n  6, 13, 18, 21,\r\n  7, 14, 21, 25,\r\n  8, 16, 20, 25,\r\n  8, 17, 23, 25,\r\n  9, 17, 23, 34,\r\n  9, 18, 25, 30,\r\n  10, 20, 27, 32,\r\n  12, 21, 29, 35,\r\n  12, 23, 34, 37,\r\n  12, 25, 34, 40,\r\n  13, 26, 35, 42,\r\n  14, 28, 38, 45,\r\n  15, 29, 40, 48,\r\n  16, 31, 43, 51,\r\n  17, 33, 45, 54,\r\n  18, 35, 48, 57,\r\n  19, 37, 51, 60,\r\n  19, 38, 53, 63,\r\n  20, 40, 56, 66,\r\n  21, 43, 59, 70,\r\n  22, 45, 62, 74,\r\n  24, 47, 65, 77,\r\n  25, 49, 68, 81\r\n]\r\n\r\nconst EC_CODEWORDS_TABLE = [\r\n// L  M  Q  H\r\n  7, 10, 13, 17,\r\n  10, 16, 22, 28,\r\n  15, 26, 36, 44,\r\n  20, 36, 52, 64,\r\n  26, 48, 72, 88,\r\n  36, 64, 96, 112,\r\n  40, 72, 108, 130,\r\n  48, 88, 132, 156,\r\n  60, 110, 160, 192,\r\n  72, 130, 192, 224,\r\n  80, 150, 224, 264,\r\n  96, 176, 260, 308,\r\n  104, 198, 288, 352,\r\n  120, 216, 320, 384,\r\n  132, 240, 360, 432,\r\n  144, 280, 408, 480,\r\n  168, 308, 448, 532,\r\n  180, 338, 504, 588,\r\n  196, 364, 546, 650,\r\n  224, 416, 600, 700,\r\n  224, 442, 644, 750,\r\n  252, 476, 690, 816,\r\n  270, 504, 750, 900,\r\n  300, 560, 810, 960,\r\n  312, 588, 870, 1050,\r\n  336, 644, 952, 1110,\r\n  360, 700, 1020, 1200,\r\n  390, 728, 1050, 1260,\r\n  420, 784, 1140, 1350,\r\n  450, 812, 1200, 1440,\r\n  480, 868, 1290, 1530,\r\n  510, 924, 1350, 1620,\r\n  540, 980, 1440, 1710,\r\n  570, 1036, 1530, 1800,\r\n  570, 1064, 1590, 1890,\r\n  600, 1120, 1680, 1980,\r\n  630, 1204, 1770, 2100,\r\n  660, 1260, 1860, 2220,\r\n  720, 1316, 1950, 2310,\r\n  750, 1372, 2040, 2430\r\n]\r\n\r\n/**\r\n * Returns the number of error correction block that the QR Code should contain\r\n * for the specified version and error correction level.\r\n *\r\n * @param  {Number} version              QR Code version\r\n * @param  {Number} errorCorrectionLevel Error correction level\r\n * @return {Number}                      Number of error correction blocks\r\n */\r\nexports.getBlocksCount = function getBlocksCount (version, errorCorrectionLevel) {\r\n  switch (errorCorrectionLevel) {\r\n    case ECLevel.L:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]\r\n    case ECLevel.M:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]\r\n    case ECLevel.Q:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]\r\n    case ECLevel.H:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]\r\n    default:\r\n      return undefined\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the number of error correction codewords to use for the specified\r\n * version and error correction level.\r\n *\r\n * @param  {Number} version              QR Code version\r\n * @param  {Number} errorCorrectionLevel Error correction level\r\n * @return {Number}                      Number of error correction codewords\r\n */\r\nexports.getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel) {\r\n  switch (errorCorrectionLevel) {\r\n    case ECLevel.L:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]\r\n    case ECLevel.M:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]\r\n    case ECLevel.Q:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]\r\n    case ECLevel.H:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]\r\n    default:\r\n      return undefined\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/error-correction-code.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/error-correction-level.js":
/*!****************************************************************!*\
  !*** ./node_modules/qrcode/lib/core/error-correction-level.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("exports.L = { bit: 1 }\nexports.M = { bit: 0 }\nexports.Q = { bit: 3 }\nexports.H = { bit: 2 }\n\nfunction fromString (string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string')\n  }\n\n  const lcStr = string.toLowerCase()\n\n  switch (lcStr) {\n    case 'l':\n    case 'low':\n      return exports.L\n\n    case 'm':\n    case 'medium':\n      return exports.M\n\n    case 'q':\n    case 'quartile':\n      return exports.Q\n\n    case 'h':\n    case 'high':\n      return exports.H\n\n    default:\n      throw new Error('Unknown EC Level: ' + string)\n  }\n}\n\nexports.isValid = function isValid (level) {\n  return level && typeof level.bit !== 'undefined' &&\n    level.bit >= 0 && level.bit < 4\n}\n\nexports.from = function from (value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value\n  }\n\n  try {\n    return fromString(value)\n  } catch (e) {\n    return defaultValue\n  }\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/error-correction-level.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/finder-pattern.js":
/*!********************************************************!*\
  !*** ./node_modules/qrcode/lib/core/finder-pattern.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const getSymbolSize = (__webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\").getSymbolSize)\nconst FINDER_PATTERN_SIZE = 7\n\n/**\n * Returns an array containing the positions of each finder pattern.\n * Each array's element represent the top-left point of the pattern as (x, y) coordinates\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nexports.getPositions = function getPositions (version) {\n  const size = getSymbolSize(version)\n\n  return [\n    // top-left\n    [0, 0],\n    // top-right\n    [size - FINDER_PATTERN_SIZE, 0],\n    // bottom-left\n    [0, size - FINDER_PATTERN_SIZE]\n  ]\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/finder-pattern.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/format-info.js":
/*!*****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/format-info.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\")\n\nconst G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0)\nconst G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)\nconst G15_BCH = Utils.getBCHDigit(G15)\n\n/**\n * Returns format information with relative error correction bits\n *\n * The format information is a 15-bit sequence containing 5 data bits,\n * with 10 error correction bits calculated using the (15, 5) BCH code.\n *\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Number} mask                 Mask pattern\n * @return {Number}                      Encoded format information bits\n */\nexports.getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {\n  const data = ((errorCorrectionLevel.bit << 3) | mask)\n  let d = data << 10\n\n  while (Utils.getBCHDigit(d) - G15_BCH >= 0) {\n    d ^= (G15 << (Utils.getBCHDigit(d) - G15_BCH))\n  }\n\n  // xor final data with mask pattern in order to ensure that\n  // no combination of Error Correction Level and data mask pattern\n  // will result in an all-zero data string\n  return ((data << 10) | d) ^ G15_MASK\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/format-info.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/galois-field.js":
/*!******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/galois-field.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("const EXP_TABLE = new Uint8Array(512)\nconst LOG_TABLE = new Uint8Array(256)\n/**\n * Precompute the log and anti-log tables for faster computation later\n *\n * For each possible value in the galois field 2^8, we will pre-compute\n * the logarithm and anti-logarithm (exponential) of this value\n *\n * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}\n */\n;(function initTables () {\n  let x = 1\n  for (let i = 0; i < 255; i++) {\n    EXP_TABLE[i] = x\n    LOG_TABLE[x] = i\n\n    x <<= 1 // multiply by 2\n\n    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n    // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)\n      x ^= 0x11D\n    }\n  }\n\n  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n  // stay inside the bounds (because we will mainly use this table for the multiplication of\n  // two GF numbers, no more).\n  // @see {@link mul}\n  for (let i = 255; i < 512; i++) {\n    EXP_TABLE[i] = EXP_TABLE[i - 255]\n  }\n}())\n\n/**\n * Returns log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.log = function log (n) {\n  if (n < 1) throw new Error('log(' + n + ')')\n  return LOG_TABLE[n]\n}\n\n/**\n * Returns anti-log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.exp = function exp (n) {\n  return EXP_TABLE[n]\n}\n\n/**\n * Multiplies two number inside Galois Field\n *\n * @param  {Number} x\n * @param  {Number} y\n * @return {Number}\n */\nexports.mul = function mul (x, y) {\n  if (x === 0 || y === 0) return 0\n\n  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n  // @see {@link initTables}\n  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/galois-field.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/kanji-data.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/kanji-data.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\nconst Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\")\n\nfunction KanjiData (data) {\n  this.mode = Mode.KANJI\n  this.data = data\n}\n\nKanjiData.getBitsLength = function getBitsLength (length) {\n  return length * 13\n}\n\nKanjiData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nKanjiData.prototype.getBitsLength = function getBitsLength () {\n  return KanjiData.getBitsLength(this.data.length)\n}\n\nKanjiData.prototype.write = function (bitBuffer) {\n  let i\n\n  // In the Shift JIS system, Kanji characters are represented by a two byte combination.\n  // These byte values are shifted from the JIS X 0208 values.\n  // JIS X 0208 gives details of the shift coded representation.\n  for (i = 0; i < this.data.length; i++) {\n    let value = Utils.toSJIS(this.data[i])\n\n    // For characters with Shift JIS values from 0x8140 to 0x9FFC:\n    if (value >= 0x8140 && value <= 0x9FFC) {\n      // Subtract 0x8140 from Shift JIS value\n      value -= 0x8140\n\n    // For characters with Shift JIS values from 0xE040 to 0xEBBF\n    } else if (value >= 0xE040 && value <= 0xEBBF) {\n      // Subtract 0xC140 from Shift JIS value\n      value -= 0xC140\n    } else {\n      throw new Error(\n        'Invalid SJIS character: ' + this.data[i] + '\\n' +\n        'Make sure your charset is UTF-8')\n    }\n\n    // Multiply most significant byte of result by 0xC0\n    // and add least significant byte to product\n    value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff)\n\n    // Convert result to a 13-bit binary string\n    bitBuffer.put(value, 13)\n  }\n}\n\nmodule.exports = KanjiData\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/kanji-data.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/mask-pattern.js":
/*!******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/mask-pattern.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * Data mask pattern reference\n * @type {Object}\n */\nexports.Patterns = {\n  PATTERN000: 0,\n  PATTERN001: 1,\n  PATTERN010: 2,\n  PATTERN011: 3,\n  PATTERN100: 4,\n  PATTERN101: 5,\n  PATTERN110: 6,\n  PATTERN111: 7\n}\n\n/**\n * Weighted penalty scores for the undesirable features\n * @type {Object}\n */\nconst PenaltyScores = {\n  N1: 3,\n  N2: 3,\n  N3: 40,\n  N4: 10\n}\n\n/**\n * Check if mask pattern value is valid\n *\n * @param  {Number}  mask    Mask pattern\n * @return {Boolean}         true if valid, false otherwise\n */\nexports.isValid = function isValid (mask) {\n  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7\n}\n\n/**\n * Returns mask pattern from a value.\n * If value is not valid, returns undefined\n *\n * @param  {Number|String} value        Mask pattern value\n * @return {Number}                     Valid mask pattern or undefined\n */\nexports.from = function from (value) {\n  return exports.isValid(value) ? parseInt(value, 10) : undefined\n}\n\n/**\n* Find adjacent modules in row/column with the same color\n* and assign a penalty value.\n*\n* Points: N1 + i\n* i is the amount by which the number of adjacent modules of the same color exceeds 5\n*/\nexports.getPenaltyN1 = function getPenaltyN1 (data) {\n  const size = data.size\n  let points = 0\n  let sameCountCol = 0\n  let sameCountRow = 0\n  let lastCol = null\n  let lastRow = null\n\n  for (let row = 0; row < size; row++) {\n    sameCountCol = sameCountRow = 0\n    lastCol = lastRow = null\n\n    for (let col = 0; col < size; col++) {\n      let module = data.get(row, col)\n      if (module === lastCol) {\n        sameCountCol++\n      } else {\n        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n        lastCol = module\n        sameCountCol = 1\n      }\n\n      module = data.get(col, row)\n      if (module === lastRow) {\n        sameCountRow++\n      } else {\n        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n        lastRow = module\n        sameCountRow = 1\n      }\n    }\n\n    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n  }\n\n  return points\n}\n\n/**\n * Find 2x2 blocks with the same color and assign a penalty value\n *\n * Points: N2 * (m - 1) * (n - 1)\n */\nexports.getPenaltyN2 = function getPenaltyN2 (data) {\n  const size = data.size\n  let points = 0\n\n  for (let row = 0; row < size - 1; row++) {\n    for (let col = 0; col < size - 1; col++) {\n      const last = data.get(row, col) +\n        data.get(row, col + 1) +\n        data.get(row + 1, col) +\n        data.get(row + 1, col + 1)\n\n      if (last === 4 || last === 0) points++\n    }\n  }\n\n  return points * PenaltyScores.N2\n}\n\n/**\n * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n * preceded or followed by light area 4 modules wide\n *\n * Points: N3 * number of pattern found\n */\nexports.getPenaltyN3 = function getPenaltyN3 (data) {\n  const size = data.size\n  let points = 0\n  let bitsCol = 0\n  let bitsRow = 0\n\n  for (let row = 0; row < size; row++) {\n    bitsCol = bitsRow = 0\n    for (let col = 0; col < size; col++) {\n      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col)\n      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++\n\n      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row)\n      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++\n    }\n  }\n\n  return points * PenaltyScores.N3\n}\n\n/**\n * Calculate proportion of dark modules in entire symbol\n *\n * Points: N4 * k\n *\n * k is the rating of the deviation of the proportion of dark modules\n * in the symbol from 50% in steps of 5%\n */\nexports.getPenaltyN4 = function getPenaltyN4 (data) {\n  let darkCount = 0\n  const modulesCount = data.data.length\n\n  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i]\n\n  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10)\n\n  return k * PenaltyScores.N4\n}\n\n/**\n * Return mask value at given position\n *\n * @param  {Number} maskPattern Pattern reference value\n * @param  {Number} i           Row\n * @param  {Number} j           Column\n * @return {Boolean}            Mask value\n */\nfunction getMaskAt (maskPattern, i, j) {\n  switch (maskPattern) {\n    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0\n    case exports.Patterns.PATTERN001: return i % 2 === 0\n    case exports.Patterns.PATTERN010: return j % 3 === 0\n    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0\n    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0\n    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0\n    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0\n    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0\n\n    default: throw new Error('bad maskPattern:' + maskPattern)\n  }\n}\n\n/**\n * Apply a mask pattern to a BitMatrix\n *\n * @param  {Number}    pattern Pattern reference number\n * @param  {BitMatrix} data    BitMatrix data\n */\nexports.applyMask = function applyMask (pattern, data) {\n  const size = data.size\n\n  for (let col = 0; col < size; col++) {\n    for (let row = 0; row < size; row++) {\n      if (data.isReserved(row, col)) continue\n      data.xor(row, col, getMaskAt(pattern, row, col))\n    }\n  }\n}\n\n/**\n * Returns the best mask pattern for data\n *\n * @param  {BitMatrix} data\n * @return {Number} Mask pattern reference number\n */\nexports.getBestMask = function getBestMask (data, setupFormatFunc) {\n  const numPatterns = Object.keys(exports.Patterns).length\n  let bestPattern = 0\n  let lowerPenalty = Infinity\n\n  for (let p = 0; p < numPatterns; p++) {\n    setupFormatFunc(p)\n    exports.applyMask(p, data)\n\n    // Calculate penalty\n    const penalty =\n      exports.getPenaltyN1(data) +\n      exports.getPenaltyN2(data) +\n      exports.getPenaltyN3(data) +\n      exports.getPenaltyN4(data)\n\n    // Undo previously applied mask\n    exports.applyMask(p, data)\n\n    if (penalty < lowerPenalty) {\n      lowerPenalty = penalty\n      bestPattern = p\n    }\n  }\n\n  return bestPattern\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/mask-pattern.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/mode.js":
/*!**********************************************!*\
  !*** ./node_modules/qrcode/lib/core/mode.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const VersionCheck = __webpack_require__(/*! ./version-check */ \"./node_modules/qrcode/lib/core/version-check.js\")\nconst Regex = __webpack_require__(/*! ./regex */ \"./node_modules/qrcode/lib/core/regex.js\")\n\n/**\n * Numeric mode encodes data from the decimal digit set (0 - 9)\n * (byte values 30HEX to 39HEX).\n * Normally, 3 data characters are represented by 10 bits.\n *\n * @type {Object}\n */\nexports.NUMERIC = {\n  id: 'Numeric',\n  bit: 1 << 0,\n  ccBits: [10, 12, 14]\n}\n\n/**\n * Alphanumeric mode encodes data from a set of 45 characters,\n * i.e. 10 numeric digits (0 - 9),\n *      26 alphabetic characters (A - Z),\n *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n * Normally, two input characters are represented by 11 bits.\n *\n * @type {Object}\n */\nexports.ALPHANUMERIC = {\n  id: 'Alphanumeric',\n  bit: 1 << 1,\n  ccBits: [9, 11, 13]\n}\n\n/**\n * In byte mode, data is encoded at 8 bits per character.\n *\n * @type {Object}\n */\nexports.BYTE = {\n  id: 'Byte',\n  bit: 1 << 2,\n  ccBits: [8, 16, 16]\n}\n\n/**\n * The Kanji mode efficiently encodes Kanji characters in accordance with\n * the Shift JIS system based on JIS X 0208.\n * The Shift JIS values are shifted from the JIS X 0208 values.\n * JIS X 0208 gives details of the shift coded representation.\n * Each two-byte character value is compacted to a 13-bit binary codeword.\n *\n * @type {Object}\n */\nexports.KANJI = {\n  id: 'Kanji',\n  bit: 1 << 3,\n  ccBits: [8, 10, 12]\n}\n\n/**\n * Mixed mode will contain a sequences of data in a combination of any of\n * the modes described above\n *\n * @type {Object}\n */\nexports.MIXED = {\n  bit: -1\n}\n\n/**\n * Returns the number of bits needed to store the data length\n * according to QR Code specifications.\n *\n * @param  {Mode}   mode    Data mode\n * @param  {Number} version QR Code version\n * @return {Number}         Number of bits\n */\nexports.getCharCountIndicator = function getCharCountIndicator (mode, version) {\n  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)\n\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid version: ' + version)\n  }\n\n  if (version >= 1 && version < 10) return mode.ccBits[0]\n  else if (version < 27) return mode.ccBits[1]\n  return mode.ccBits[2]\n}\n\n/**\n * Returns the most efficient mode to store the specified data\n *\n * @param  {String} dataStr Input data string\n * @return {Mode}           Best mode\n */\nexports.getBestModeForData = function getBestModeForData (dataStr) {\n  if (Regex.testNumeric(dataStr)) return exports.NUMERIC\n  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC\n  else if (Regex.testKanji(dataStr)) return exports.KANJI\n  else return exports.BYTE\n}\n\n/**\n * Return mode name as string\n *\n * @param {Mode} mode Mode object\n * @returns {String}  Mode name\n */\nexports.toString = function toString (mode) {\n  if (mode && mode.id) return mode.id\n  throw new Error('Invalid mode')\n}\n\n/**\n * Check if input param is a valid mode object\n *\n * @param   {Mode}    mode Mode object\n * @returns {Boolean} True if valid mode, false otherwise\n */\nexports.isValid = function isValid (mode) {\n  return mode && mode.bit && mode.ccBits\n}\n\n/**\n * Get mode object from its name\n *\n * @param   {String} string Mode name\n * @returns {Mode}          Mode object\n */\nfunction fromString (string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string')\n  }\n\n  const lcStr = string.toLowerCase()\n\n  switch (lcStr) {\n    case 'numeric':\n      return exports.NUMERIC\n    case 'alphanumeric':\n      return exports.ALPHANUMERIC\n    case 'kanji':\n      return exports.KANJI\n    case 'byte':\n      return exports.BYTE\n    default:\n      throw new Error('Unknown mode: ' + string)\n  }\n}\n\n/**\n * Returns mode from a value.\n * If value is not a valid mode, returns defaultValue\n *\n * @param  {Mode|String} value        Encoding mode\n * @param  {Mode}        defaultValue Fallback value\n * @return {Mode}                     Encoding mode\n */\nexports.from = function from (value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value\n  }\n\n  try {\n    return fromString(value)\n  } catch (e) {\n    return defaultValue\n  }\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/mode.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/numeric-data.js":
/*!******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/numeric-data.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\n\nfunction NumericData (data) {\n  this.mode = Mode.NUMERIC\n  this.data = data.toString()\n}\n\nNumericData.getBitsLength = function getBitsLength (length) {\n  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)\n}\n\nNumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nNumericData.prototype.getBitsLength = function getBitsLength () {\n  return NumericData.getBitsLength(this.data.length)\n}\n\nNumericData.prototype.write = function write (bitBuffer) {\n  let i, group, value\n\n  // The input data string is divided into groups of three digits,\n  // and each group is converted to its 10-bit binary equivalent.\n  for (i = 0; i + 3 <= this.data.length; i += 3) {\n    group = this.data.substr(i, 3)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, 10)\n  }\n\n  // If the number of input digits is not an exact multiple of three,\n  // the final one or two digits are converted to 4 or 7 bits respectively.\n  const remainingNum = this.data.length - i\n  if (remainingNum > 0) {\n    group = this.data.substr(i)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, remainingNum * 3 + 1)\n  }\n}\n\nmodule.exports = NumericData\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/numeric-data.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/polynomial.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/polynomial.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const GF = __webpack_require__(/*! ./galois-field */ \"./node_modules/qrcode/lib/core/galois-field.js\")\n\n/**\n * Multiplies two polynomials inside Galois Field\n *\n * @param  {Uint8Array} p1 Polynomial\n * @param  {Uint8Array} p2 Polynomial\n * @return {Uint8Array}    Product of p1 and p2\n */\nexports.mul = function mul (p1, p2) {\n  const coeff = new Uint8Array(p1.length + p2.length - 1)\n\n  for (let i = 0; i < p1.length; i++) {\n    for (let j = 0; j < p2.length; j++) {\n      coeff[i + j] ^= GF.mul(p1[i], p2[j])\n    }\n  }\n\n  return coeff\n}\n\n/**\n * Calculate the remainder of polynomials division\n *\n * @param  {Uint8Array} divident Polynomial\n * @param  {Uint8Array} divisor  Polynomial\n * @return {Uint8Array}          Remainder\n */\nexports.mod = function mod (divident, divisor) {\n  let result = new Uint8Array(divident)\n\n  while ((result.length - divisor.length) >= 0) {\n    const coeff = result[0]\n\n    for (let i = 0; i < divisor.length; i++) {\n      result[i] ^= GF.mul(divisor[i], coeff)\n    }\n\n    // remove all zeros from buffer head\n    let offset = 0\n    while (offset < result.length && result[offset] === 0) offset++\n    result = result.slice(offset)\n  }\n\n  return result\n}\n\n/**\n * Generate an irreducible generator polynomial of specified degree\n * (used by Reed-Solomon encoder)\n *\n * @param  {Number} degree Degree of the generator polynomial\n * @return {Uint8Array}    Buffer containing polynomial coefficients\n */\nexports.generateECPolynomial = function generateECPolynomial (degree) {\n  let poly = new Uint8Array([1])\n  for (let i = 0; i < degree; i++) {\n    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]))\n  }\n\n  return poly\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/polynomial.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/qrcode.js":
/*!************************************************!*\
  !*** ./node_modules/qrcode/lib/core/qrcode.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\")\nconst ECLevel = __webpack_require__(/*! ./error-correction-level */ \"./node_modules/qrcode/lib/core/error-correction-level.js\")\nconst BitBuffer = __webpack_require__(/*! ./bit-buffer */ \"./node_modules/qrcode/lib/core/bit-buffer.js\")\nconst BitMatrix = __webpack_require__(/*! ./bit-matrix */ \"./node_modules/qrcode/lib/core/bit-matrix.js\")\nconst AlignmentPattern = __webpack_require__(/*! ./alignment-pattern */ \"./node_modules/qrcode/lib/core/alignment-pattern.js\")\nconst FinderPattern = __webpack_require__(/*! ./finder-pattern */ \"./node_modules/qrcode/lib/core/finder-pattern.js\")\nconst MaskPattern = __webpack_require__(/*! ./mask-pattern */ \"./node_modules/qrcode/lib/core/mask-pattern.js\")\nconst ECCode = __webpack_require__(/*! ./error-correction-code */ \"./node_modules/qrcode/lib/core/error-correction-code.js\")\nconst ReedSolomonEncoder = __webpack_require__(/*! ./reed-solomon-encoder */ \"./node_modules/qrcode/lib/core/reed-solomon-encoder.js\")\nconst Version = __webpack_require__(/*! ./version */ \"./node_modules/qrcode/lib/core/version.js\")\nconst FormatInfo = __webpack_require__(/*! ./format-info */ \"./node_modules/qrcode/lib/core/format-info.js\")\nconst Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\nconst Segments = __webpack_require__(/*! ./segments */ \"./node_modules/qrcode/lib/core/segments.js\")\n\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern (matrix, version) {\n  const size = matrix.size\n  const pos = FinderPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue\n\n      for (let c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue\n\n        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern (matrix) {\n  const size = matrix.size\n\n  for (let r = 8; r < size - 8; r++) {\n    const value = r % 2 === 0\n    matrix.set(r, 6, value, true)\n    matrix.set(6, r, value, true)\n  }\n}\n\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern (matrix, version) {\n  const pos = AlignmentPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -2; r <= 2; r++) {\n      for (let c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 ||\n          (r === 0 && c === 0)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo (matrix, version) {\n  const size = matrix.size\n  const bits = Version.getEncodedBits(version)\n  let row, col, mod\n\n  for (let i = 0; i < 18; i++) {\n    row = Math.floor(i / 3)\n    col = i % 3 + size - 8 - 3\n    mod = ((bits >> i) & 1) === 1\n\n    matrix.set(row, col, mod, true)\n    matrix.set(col, row, mod, true)\n  }\n}\n\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {\n  const size = matrix.size\n  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)\n  let i, mod\n\n  for (i = 0; i < 15; i++) {\n    mod = ((bits >> i) & 1) === 1\n\n    // vertical\n    if (i < 6) {\n      matrix.set(i, 8, mod, true)\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true)\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true)\n    }\n\n    // horizontal\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true)\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true)\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true)\n    }\n  }\n\n  // fixed module\n  matrix.set(size - 8, 8, 1, true)\n}\n\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix}  matrix Modules matrix\n * @param  {Uint8Array} data   Data codewords\n */\nfunction setupData (matrix, data) {\n  const size = matrix.size\n  let inc = -1\n  let row = size - 1\n  let bitIndex = 7\n  let byteIndex = 0\n\n  for (let col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--\n\n    while (true) {\n      for (let c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          let dark = false\n\n          if (byteIndex < data.length) {\n            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)\n          }\n\n          matrix.set(row, col - c, dark)\n          bitIndex--\n\n          if (bitIndex === -1) {\n            byteIndex++\n            bitIndex = 7\n          }\n        }\n      }\n\n      row += inc\n\n      if (row < 0 || size <= row) {\n        row -= inc\n        inc = -inc\n        break\n      }\n    }\n  }\n}\n\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Uint8Array}                    Buffer containing encoded codewords\n */\nfunction createData (version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  const buffer = new BitBuffer()\n\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4)\n\n    // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))\n\n    // add binary data sequence to buffer\n    data.write(buffer)\n  })\n\n  // Calculate required number of bits\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4)\n  }\n\n  // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0)\n  }\n\n  // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8\n  for (let i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8)\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel)\n}\n\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Uint8Array}                     Buffer containing encoded codewords\n */\nfunction createCodewords (bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewords = totalCodewords - ecTotalCodewords\n\n  // Total number of blocks\n  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)\n\n  // Calculate how many blocks each group should contain\n  const blocksInGroup2 = totalCodewords % ecTotalBlocks\n  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2\n\n  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)\n\n  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)\n  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1\n\n  // Number of EC codewords is the same for both groups\n  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1\n\n  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n  const rs = new ReedSolomonEncoder(ecCount)\n\n  let offset = 0\n  const dcData = new Array(ecTotalBlocks)\n  const ecData = new Array(ecTotalBlocks)\n  let maxDataSize = 0\n  const buffer = new Uint8Array(bitBuffer.buffer)\n\n  // Divide the buffer into the required number of blocks\n  for (let b = 0; b < ecTotalBlocks; b++) {\n    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2\n\n    // extract a block of data from buffer\n    dcData[b] = buffer.slice(offset, offset + dataSize)\n\n    // Calculate EC codewords for this data block\n    ecData[b] = rs.encode(dcData[b])\n\n    offset += dataSize\n    maxDataSize = Math.max(maxDataSize, dataSize)\n  }\n\n  // Create final data\n  // Interleave the data and error correction codewords from each block\n  const data = new Uint8Array(totalCodewords)\n  let index = 0\n  let i, r\n\n  // Add data codewords\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i]\n      }\n    }\n  }\n\n  // Apped EC codewords\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i]\n    }\n  }\n\n  return data\n}\n\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol (data, version, errorCorrectionLevel, maskPattern) {\n  let segments\n\n  if (Array.isArray(data)) {\n    segments = Segments.fromArray(data)\n  } else if (typeof data === 'string') {\n    let estimatedVersion = version\n\n    if (!estimatedVersion) {\n      const rawSegments = Segments.rawSplit(data)\n\n      // Estimate best version that can contain raw splitted segments\n      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel)\n    }\n\n    // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n    segments = Segments.fromString(data, estimatedVersion || 40)\n  } else {\n    throw new Error('Invalid data')\n  }\n\n  // Get the min version that can contain data\n  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel)\n\n  // If no version is found, data cannot be stored\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code')\n  }\n\n  // If not specified, use min version as default\n  if (!version) {\n    version = bestVersion\n\n  // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' +\n      'The chosen QR Code version cannot contain this amount of data.\\n' +\n      'Minimum version required to store current data is: ' + bestVersion + '.\\n'\n    )\n  }\n\n  const dataBits = createData(version, errorCorrectionLevel, segments)\n\n  // Allocate matrix buffer\n  const moduleCount = Utils.getSymbolSize(version)\n  const modules = new BitMatrix(moduleCount)\n\n  // Add function modules\n  setupFinderPattern(modules, version)\n  setupTimingPattern(modules)\n  setupAlignmentPattern(modules, version)\n\n  // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n  setupFormatInfo(modules, errorCorrectionLevel, 0)\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version)\n  }\n\n  // Add data codewords\n  setupData(modules, dataBits)\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules,\n      setupFormatInfo.bind(null, modules, errorCorrectionLevel))\n  }\n\n  // Apply mask pattern\n  MaskPattern.applyMask(maskPattern, modules)\n\n  // Replace format info bits with correct values\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)\n\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  }\n}\n\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nexports.create = function create (data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text')\n  }\n\n  let errorCorrectionLevel = ECLevel.M\n  let version\n  let mask\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)\n    version = Version.from(options.version)\n    mask = MaskPattern.from(options.maskPattern)\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc)\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask)\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/qrcode.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/reed-solomon-encoder.js":
/*!**************************************************************!*\
  !*** ./node_modules/qrcode/lib/core/reed-solomon-encoder.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const Polynomial = __webpack_require__(/*! ./polynomial */ \"./node_modules/qrcode/lib/core/polynomial.js\")\n\nfunction ReedSolomonEncoder (degree) {\n  this.genPoly = undefined\n  this.degree = degree\n\n  if (this.degree) this.initialize(this.degree)\n}\n\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize (degree) {\n  // create an irreducible generator polynomial\n  this.degree = degree\n  this.genPoly = Polynomial.generateECPolynomial(this.degree)\n}\n\n/**\n * Encodes a chunk of data\n *\n * @param  {Uint8Array} data Buffer containing input data\n * @return {Uint8Array}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode (data) {\n  if (!this.genPoly) {\n    throw new Error('Encoder not initialized')\n  }\n\n  // Calculate EC for this data block\n  // extends data size to data+genPoly size\n  const paddedData = new Uint8Array(data.length + this.degree)\n  paddedData.set(data)\n\n  // The error correction codewords are the remainder after dividing the data codewords\n  // by a generator polynomial\n  const remainder = Polynomial.mod(paddedData, this.genPoly)\n\n  // return EC data blocks (last n byte, where n is the degree of genPoly)\n  // If coefficients number in remainder are less than genPoly degree,\n  // pad with 0s to the left to reach the needed number of coefficients\n  const start = this.degree - remainder.length\n  if (start > 0) {\n    const buff = new Uint8Array(this.degree)\n    buff.set(remainder, start)\n\n    return buff\n  }\n\n  return remainder\n}\n\nmodule.exports = ReedSolomonEncoder\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/reed-solomon-encoder.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/regex.js":
/*!***********************************************!*\
  !*** ./node_modules/qrcode/lib/core/regex.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("const numeric = '[0-9]+'\nconst alphanumeric = '[A-Z $%*+\\\\-./:]+'\nlet kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +\n  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +\n  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +\n  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+'\nkanji = kanji.replace(/u/g, '\\\\u')\n\nconst byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+'\n\nexports.KANJI = new RegExp(kanji, 'g')\nexports.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g')\nexports.BYTE = new RegExp(byte, 'g')\nexports.NUMERIC = new RegExp(numeric, 'g')\nexports.ALPHANUMERIC = new RegExp(alphanumeric, 'g')\n\nconst TEST_KANJI = new RegExp('^' + kanji + '$')\nconst TEST_NUMERIC = new RegExp('^' + numeric + '$')\nconst TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$')\n\nexports.testKanji = function testKanji (str) {\n  return TEST_KANJI.test(str)\n}\n\nexports.testNumeric = function testNumeric (str) {\n  return TEST_NUMERIC.test(str)\n}\n\nexports.testAlphanumeric = function testAlphanumeric (str) {\n  return TEST_ALPHANUMERIC.test(str)\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/regex.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/segments.js":
/*!**************************************************!*\
  !*** ./node_modules/qrcode/lib/core/segments.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\nconst NumericData = __webpack_require__(/*! ./numeric-data */ \"./node_modules/qrcode/lib/core/numeric-data.js\")\nconst AlphanumericData = __webpack_require__(/*! ./alphanumeric-data */ \"./node_modules/qrcode/lib/core/alphanumeric-data.js\")\nconst ByteData = __webpack_require__(/*! ./byte-data */ \"./node_modules/qrcode/lib/core/byte-data.js\")\nconst KanjiData = __webpack_require__(/*! ./kanji-data */ \"./node_modules/qrcode/lib/core/kanji-data.js\")\nconst Regex = __webpack_require__(/*! ./regex */ \"./node_modules/qrcode/lib/core/regex.js\")\nconst Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\")\nconst dijkstra = __webpack_require__(/*! dijkstrajs */ \"./node_modules/dijkstrajs/dijkstra.js\")\n\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\nfunction getStringByteLength (str) {\n  return unescape(encodeURIComponent(str)).length\n}\n\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\nfunction getSegments (regex, mode, str) {\n  const segments = []\n  let result\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    })\n  }\n\n  return segments\n}\n\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\nfunction getSegmentsFromString (dataStr) {\n  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n  let byteSegs\n  let kanjiSegs\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n    kanjiSegs = []\n  }\n\n  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n  return segs\n    .sort(function (s1, s2) {\n      return s1.index - s2.index\n    })\n    .map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      }\n    })\n}\n\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\nfunction getSegmentBitsLength (length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length)\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length)\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length)\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length)\n  }\n}\n\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction mergeSegments (segs) {\n  return segs.reduce(function (acc, curr) {\n    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data\n      return acc\n    }\n\n    acc.push(curr)\n    return acc\n  }, [])\n}\n\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction buildNodes (segs) {\n  const nodes = []\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i]\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.KANJI:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n        break\n      case Mode.BYTE:\n        nodes.push([\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n    }\n  }\n\n  return nodes\n}\n\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\nfunction buildGraph (nodes, version) {\n  const table = {}\n  const graph = { start: {} }\n  let prevNodeIds = ['start']\n\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeGroup = nodes[i]\n    const currentNodeIds = []\n\n    for (let j = 0; j < nodeGroup.length; j++) {\n      const node = nodeGroup[j]\n      const key = '' + i + j\n\n      currentNodeIds.push(key)\n      table[key] = { node: node, lastCount: 0 }\n      graph[key] = {}\n\n      for (let n = 0; n < prevNodeIds.length; n++) {\n        const prevNodeId = prevNodeIds[n]\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] =\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n          table[prevNodeId].lastCount += node.length\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds\n  }\n\n  for (let n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]].end = 0\n  }\n\n  return { map: graph, table: table }\n}\n\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\nfunction buildSingleSegment (data, modesHint) {\n  let mode\n  const bestMode = Mode.getBestModeForData(data)\n\n  mode = Mode.from(modesHint, bestMode)\n\n  // Make sure data can be encoded\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' +\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n  }\n\n  // Use Mode.BYTE if Kanji support is disabled\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data)\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data)\n\n    case Mode.KANJI:\n      return new KanjiData(data)\n\n    case Mode.BYTE:\n      return new ByteData(data)\n  }\n}\n\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\nexports.fromArray = function fromArray (array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null))\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode))\n    }\n\n    return acc\n  }, [])\n}\n\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\nexports.fromString = function fromString (data, version) {\n  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n  const nodes = buildNodes(segs)\n  const graph = buildGraph(nodes, version)\n  const path = dijkstra.find_path(graph.map, 'start', 'end')\n\n  const optimizedSegs = []\n  for (let i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node)\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs))\n}\n\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\nexports.rawSplit = function rawSplit (data) {\n  return exports.fromArray(\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n  )\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/segments.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/qrcode/lib/core/utils.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("let toSJISFunction\nconst CODEWORDS_COUNT = [\n  0, // Not used\n  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,\n  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,\n  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706\n]\n\n/**\n * Returns the QR Code size for the specified version\n *\n * @param  {Number} version QR Code version\n * @return {Number}         size of QR code\n */\nexports.getSymbolSize = function getSymbolSize (version) {\n  if (!version) throw new Error('\"version\" cannot be null or undefined')\n  if (version < 1 || version > 40) throw new Error('\"version\" should be in range from 1 to 40')\n  return version * 4 + 17\n}\n\n/**\n * Returns the total number of codewords used to store data and EC information.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Data length in bits\n */\nexports.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {\n  return CODEWORDS_COUNT[version]\n}\n\n/**\n * Encode data with Bose-Chaudhuri-Hocquenghem\n *\n * @param  {Number} data Value to encode\n * @return {Number}      Encoded value\n */\nexports.getBCHDigit = function (data) {\n  let digit = 0\n\n  while (data !== 0) {\n    digit++\n    data >>>= 1\n  }\n\n  return digit\n}\n\nexports.setToSJISFunction = function setToSJISFunction (f) {\n  if (typeof f !== 'function') {\n    throw new Error('\"toSJISFunc\" is not a valid function.')\n  }\n\n  toSJISFunction = f\n}\n\nexports.isKanjiModeEnabled = function () {\n  return typeof toSJISFunction !== 'undefined'\n}\n\nexports.toSJIS = function toSJIS (kanji) {\n  return toSJISFunction(kanji)\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/utils.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/version-check.js":
/*!*******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/version-check.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * Check if QR Code version is valid\n *\n * @param  {Number}  version QR Code version\n * @return {Boolean}         true if valid version, false otherwise\n */\nexports.isValid = function isValid (version) {\n  return !isNaN(version) && version >= 1 && version <= 40\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/version-check.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/version.js":
/*!*************************************************!*\
  !*** ./node_modules/qrcode/lib/core/version.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\")\nconst ECCode = __webpack_require__(/*! ./error-correction-code */ \"./node_modules/qrcode/lib/core/error-correction-code.js\")\nconst ECLevel = __webpack_require__(/*! ./error-correction-level */ \"./node_modules/qrcode/lib/core/error-correction-level.js\")\nconst Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\nconst VersionCheck = __webpack_require__(/*! ./version-check */ \"./node_modules/qrcode/lib/core/version-check.js\")\n\n// Generator polynomial used to encode version information\nconst G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)\nconst G18_BCH = Utils.getBCHDigit(G18)\n\nfunction getBestVersionForDataLength (mode, length, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\nfunction getReservedBitsCount (mode, version) {\n  // Character count indicator + mode indicator bits\n  return Mode.getCharCountIndicator(mode, version) + 4\n}\n\nfunction getTotalBitsFromDataArray (segments, version) {\n  let totalBits = 0\n\n  segments.forEach(function (data) {\n    const reservedBits = getReservedBitsCount(data.mode, version)\n    totalBits += reservedBits + data.getBitsLength()\n  })\n\n  return totalBits\n}\n\nfunction getBestVersionForMixedData (segments, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    const length = getTotalBitsFromDataArray(segments, currentVersion)\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns version number from a value.\n * If value is not a valid version, returns defaultValue\n *\n * @param  {Number|String} value        QR Code version\n * @param  {Number}        defaultValue Fallback value\n * @return {Number}                     QR Code version number\n */\nexports.from = function from (value, defaultValue) {\n  if (VersionCheck.isValid(value)) {\n    return parseInt(value, 10)\n  }\n\n  return defaultValue\n}\n\n/**\n * Returns how much data can be stored with the specified QR code version\n * and error correction level\n *\n * @param  {Number} version              QR Code version (1-40)\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Mode}   mode                 Data mode\n * @return {Number}                      Quantity of storable data\n */\nexports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  // Use Byte mode as default\n  if (typeof mode === 'undefined') mode = Mode.BYTE\n\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  if (mode === Mode.MIXED) return dataTotalCodewordsBits\n\n  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)\n\n  // Return max number of storable codewords\n  switch (mode) {\n    case Mode.NUMERIC:\n      return Math.floor((usableBits / 10) * 3)\n\n    case Mode.ALPHANUMERIC:\n      return Math.floor((usableBits / 11) * 2)\n\n    case Mode.KANJI:\n      return Math.floor(usableBits / 13)\n\n    case Mode.BYTE:\n    default:\n      return Math.floor(usableBits / 8)\n  }\n}\n\n/**\n * Returns the minimum version needed to contain the amount of data\n *\n * @param  {Segment} data                    Segment of data\n * @param  {Number} [errorCorrectionLevel=H] Error correction level\n * @param  {Mode} mode                       Data mode\n * @return {Number}                          QR Code version\n */\nexports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {\n  let seg\n\n  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)\n\n  if (Array.isArray(data)) {\n    if (data.length > 1) {\n      return getBestVersionForMixedData(data, ecl)\n    }\n\n    if (data.length === 0) {\n      return 1\n    }\n\n    seg = data[0]\n  } else {\n    seg = data\n  }\n\n  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)\n}\n\n/**\n * Returns version information with relative error correction bits\n *\n * The version information is included in QR Code symbols of version 7 or larger.\n * It consists of an 18-bit sequence containing 6 data bits,\n * with 12 error correction bits calculated using the (18, 6) Golay code.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Encoded version info bits\n */\nexports.getEncodedBits = function getEncodedBits (version) {\n  if (!VersionCheck.isValid(version) || version < 7) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  let d = version << 12\n\n  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))\n  }\n\n  return (version << 12) | d\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/version.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/renderer/canvas.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/renderer/canvas.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/renderer/utils.js\")\n\nfunction clearCanvas (ctx, canvas, size) {\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n  if (!canvas.style) canvas.style = {}\n  canvas.height = size\n  canvas.width = size\n  canvas.style.height = size + 'px'\n  canvas.style.width = size + 'px'\n}\n\nfunction getCanvasElement () {\n  try {\n    return document.createElement('canvas')\n  } catch (e) {\n    throw new Error('You need to specify a canvas element')\n  }\n}\n\nexports.render = function render (qrData, canvas, options) {\n  let opts = options\n  let canvasEl = canvas\n\n  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n    opts = canvas\n    canvas = undefined\n  }\n\n  if (!canvas) {\n    canvasEl = getCanvasElement()\n  }\n\n  opts = Utils.getOptions(opts)\n  const size = Utils.getImageWidth(qrData.modules.size, opts)\n\n  const ctx = canvasEl.getContext('2d')\n  const image = ctx.createImageData(size, size)\n  Utils.qrToImageData(image.data, qrData, opts)\n\n  clearCanvas(ctx, canvasEl, size)\n  ctx.putImageData(image, 0, 0)\n\n  return canvasEl\n}\n\nexports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {\n  let opts = options\n\n  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n    opts = canvas\n    canvas = undefined\n  }\n\n  if (!opts) opts = {}\n\n  const canvasEl = exports.render(qrData, canvas, opts)\n\n  const type = opts.type || 'image/png'\n  const rendererOpts = opts.rendererOpts || {}\n\n  return canvasEl.toDataURL(type, rendererOpts.quality)\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/renderer/canvas.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/renderer/svg-tag.js":
/*!*****************************************************!*\
  !*** ./node_modules/qrcode/lib/renderer/svg-tag.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/renderer/utils.js\")\n\nfunction getColorAttrib (color, attrib) {\n  const alpha = color.a / 255\n  const str = attrib + '=\"' + color.hex + '\"'\n\n  return alpha < 1\n    ? str + ' ' + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"'\n    : str\n}\n\nfunction svgCmd (cmd, x, y) {\n  let str = cmd + x\n  if (typeof y !== 'undefined') str += ' ' + y\n\n  return str\n}\n\nfunction qrToPath (data, size, margin) {\n  let path = ''\n  let moveBy = 0\n  let newRow = false\n  let lineLength = 0\n\n  for (let i = 0; i < data.length; i++) {\n    const col = Math.floor(i % size)\n    const row = Math.floor(i / size)\n\n    if (!col && !newRow) newRow = true\n\n    if (data[i]) {\n      lineLength++\n\n      if (!(i > 0 && col > 0 && data[i - 1])) {\n        path += newRow\n          ? svgCmd('M', col + margin, 0.5 + row + margin)\n          : svgCmd('m', moveBy, 0)\n\n        moveBy = 0\n        newRow = false\n      }\n\n      if (!(col + 1 < size && data[i + 1])) {\n        path += svgCmd('h', lineLength)\n        lineLength = 0\n      }\n    } else {\n      moveBy++\n    }\n  }\n\n  return path\n}\n\nexports.render = function render (qrData, options, cb) {\n  const opts = Utils.getOptions(options)\n  const size = qrData.modules.size\n  const data = qrData.modules.data\n  const qrcodesize = size + opts.margin * 2\n\n  const bg = !opts.color.light.a\n    ? ''\n    : '<path ' + getColorAttrib(opts.color.light, 'fill') +\n      ' d=\"M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z\"/>'\n\n  const path =\n    '<path ' + getColorAttrib(opts.color.dark, 'stroke') +\n    ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>'\n\n  const viewBox = 'viewBox=\"' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '\"'\n\n  const width = !opts.width ? '' : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" '\n\n  const svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + '</svg>\\n'\n\n  if (typeof cb === 'function') {\n    cb(null, svgTag)\n  }\n\n  return svgTag\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/renderer/svg-tag.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/renderer/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/qrcode/lib/renderer/utils.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("function hex2rgba (hex) {\n  if (typeof hex === 'number') {\n    hex = hex.toString()\n  }\n\n  if (typeof hex !== 'string') {\n    throw new Error('Color should be defined as hex string')\n  }\n\n  let hexCode = hex.slice().replace('#', '').split('')\n  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n    throw new Error('Invalid hex color: ' + hex)\n  }\n\n  // Convert from short to long form (fff -> ffffff)\n  if (hexCode.length === 3 || hexCode.length === 4) {\n    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n      return [c, c]\n    }))\n  }\n\n  // Add default alpha value\n  if (hexCode.length === 6) hexCode.push('F', 'F')\n\n  const hexValue = parseInt(hexCode.join(''), 16)\n\n  return {\n    r: (hexValue >> 24) & 255,\n    g: (hexValue >> 16) & 255,\n    b: (hexValue >> 8) & 255,\n    a: hexValue & 255,\n    hex: '#' + hexCode.slice(0, 6).join('')\n  }\n}\n\nexports.getOptions = function getOptions (options) {\n  if (!options) options = {}\n  if (!options.color) options.color = {}\n\n  const margin = typeof options.margin === 'undefined' ||\n    options.margin === null ||\n    options.margin < 0\n    ? 4\n    : options.margin\n\n  const width = options.width && options.width >= 21 ? options.width : undefined\n  const scale = options.scale || 4\n\n  return {\n    width: width,\n    scale: width ? 4 : scale,\n    margin: margin,\n    color: {\n      dark: hex2rgba(options.color.dark || '#000000ff'),\n      light: hex2rgba(options.color.light || '#ffffffff')\n    },\n    type: options.type,\n    rendererOpts: options.rendererOpts || {}\n  }\n}\n\nexports.getScale = function getScale (qrSize, opts) {\n  return opts.width && opts.width >= qrSize + opts.margin * 2\n    ? opts.width / (qrSize + opts.margin * 2)\n    : opts.scale\n}\n\nexports.getImageWidth = function getImageWidth (qrSize, opts) {\n  const scale = exports.getScale(qrSize, opts)\n  return Math.floor((qrSize + opts.margin * 2) * scale)\n}\n\nexports.qrToImageData = function qrToImageData (imgData, qr, opts) {\n  const size = qr.modules.size\n  const data = qr.modules.data\n  const scale = exports.getScale(size, opts)\n  const symbolSize = Math.floor((size + opts.margin * 2) * scale)\n  const scaledMargin = opts.margin * scale\n  const palette = [opts.color.light, opts.color.dark]\n\n  for (let i = 0; i < symbolSize; i++) {\n    for (let j = 0; j < symbolSize; j++) {\n      let posDst = (i * symbolSize + j) * 4\n      let pxColor = opts.color.light\n\n      if (i >= scaledMargin && j >= scaledMargin &&\n        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n        const iSrc = Math.floor((i - scaledMargin) / scale)\n        const jSrc = Math.floor((j - scaledMargin) / scale)\n        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0]\n      }\n\n      imgData[posDst++] = pxColor.r\n      imgData[posDst++] = pxColor.g\n      imgData[posDst++] = pxColor.b\n      imgData[posDst] = pxColor.a\n    }\n  }\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/renderer/utils.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Listener\": function() { return /* reexport safe */ _peer_connection_listener__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   \"Speaker\": function() { return /* reexport safe */ _peer_connection_speaker__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   \"VolumeCalibration\": function() { return /* reexport safe */ _tasks_volume_volume__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   \"ImpulseResponseCalibration\": function() { return /* reexport safe */ _tasks_impulse_response_impulseResponse__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; },\n/* harmony export */   \"UnsupportedDeviceError\": function() { return /* reexport safe */ _peer_connection_peerErrors__WEBPACK_IMPORTED_MODULE_4__.UnsupportedDeviceError; },\n/* harmony export */   \"MissingSpeakerIdError\": function() { return /* reexport safe */ _peer_connection_peerErrors__WEBPACK_IMPORTED_MODULE_4__.MissingSpeakerIdError; },\n/* harmony export */   \"CalibrationTimedOutError\": function() { return /* reexport safe */ _peer_connection_peerErrors__WEBPACK_IMPORTED_MODULE_4__.CalibrationTimedOutError; }\n/* harmony export */ });\n/* harmony import */ var _peer_connection_listener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./peer-connection/listener */ \"./src/peer-connection/listener.js\");\n/* harmony import */ var _peer_connection_speaker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./peer-connection/speaker */ \"./src/peer-connection/speaker.js\");\n/* harmony import */ var _tasks_volume_volume__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tasks/volume/volume */ \"./src/tasks/volume/volume.js\");\n/* harmony import */ var _tasks_impulse_response_impulseResponse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tasks/impulse-response/impulseResponse */ \"./src/tasks/impulse-response/impulseResponse.js\");\n/* harmony import */ var _peer_connection_peerErrors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./peer-connection/peerErrors */ \"./src/peer-connection/peerErrors.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/main.js?");

/***/ }),

/***/ "./src/myEventEmitter.js":
/*!*******************************!*\
  !*** ./src/myEventEmitter.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * A simple event emitter class. Objects that inheret this class or implement it can then bubble events up to the UI\r\n * similar to existings event emitter such as 'onChange' or 'onClick'.\r\n */\r\nclass MyEventEmitter {\r\n  #events;\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Default constructor, intializes an empty object to store events\r\n   *\r\n   * @example\r\n   */\r\n  constructor() {\r\n    this.#events = {};\r\n  }\r\n\r\n  /**\r\n   * The external API for this class. Gets called with an event name and a callback function that is fired when the event is emitted.\r\n   *\r\n   * @param name\r\n   * @param listener\r\n   * @example\r\n   */\r\n  on(name, listener) {\r\n    if (!this.#events[name]) {\r\n      this.#events[name] = [];\r\n    }\r\n\r\n    this.#events[name].push(listener);\r\n  }\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Function to remove a listener that was previously set\r\n   *\r\n   * @param {*} name\r\n   * @param {*} listenerToRemove\r\n   * @example\r\n   */\r\n  removeListener(name, listenerToRemove) {\r\n    if (!this.#events[name]) {\r\n      throw new Error(`Can't remove a listener. Event \"${name}\" doesn't exits.`);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param listener\r\n     * @example\r\n     */\r\n    const filterListeners = listener => listener !== listenerToRemove;\r\n\r\n    this.#events[name] = this.#events[name].filter(filterListeners);\r\n  }\r\n\r\n  /**\r\n   * The internal API for this class. Gets called with an event name and a data object.\r\n   * Any callbacks that have been set to listen to the matching event are dispatched.\r\n   *\r\n   * @param name\r\n   * @param data\r\n   * @example\r\n   */\r\n  emit(name, data) {\r\n    if (!this.#events[name]) {\r\n      throw new Error(`Can't emit an event. Event \"${name}\" doesn't exits.`);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {*} callback\r\n     */\r\n    const fireCallbacks = callback => {\r\n      callback(data);\r\n    };\r\n\r\n    this.#events[name].forEach(fireCallbacks);\r\n  }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyEventEmitter);\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/myEventEmitter.js?");

/***/ }),

/***/ "./src/peer-connection/audioPeer.js":
/*!******************************************!*\
  !*** ./src/peer-connection/audioPeer.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! peerjs */ \"./node_modules/peerjs/dist/peerjs.min.js\");\n/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(peerjs__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n// TODO: this was already here before, but appears to be unused\r\nconst pressFeedbackURI =\r\n  'data:audio/mpeg;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAALAAATlgAXFxcXFxcXFxcuLi4uLi4uLi5FRUVFRUVFRUVdXV1dXV1dXV10dHR0dHR0dHSLi4uLi4uLi4uioqKioqKioqK6urq6urq6urrR0dHR0dHR0dHo6Ojo6Ojo6Oj///////////8AAAA5TEFNRTMuMTAwAaoAAAAALgYAABSAJAZbTgAAgAAAE5YfafL/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//uQZAAAA0YVyhVvQAAAAA0goAABGfWdITn6gAgAADSDAAAAAEWjAwMwMDMFBzCQsw8PMPCwUDgkNMpNzXEoSUTP3s6nJPd4z28k62JNdIwIUHj3nvynRempMmLAo/tff9/3IchyHIch/IxY3SUmG86enD4Pg+fgmfEAIQQcsP+oH//E7/+Ud/1HP/B9AAABMCFFFAAAwDgCyMCVAgQcBQmARAHw0AOGAUgFJgUoL8YKsEvqzGA1APJQAIGBNgDpoBRvQYb6EIGhIkmJg1QA0aH0H4GDBgJ4G55UBpM1AGgUG0wAgOBIUAYJGoGFQ4AkHitxzRSocGMwDYYCwJAWAICgBD8jhwlEqBNsMiAkCBpQY2FxpG61opmucDLrjKi6Fmk5oK9PWVh1DNFM2IaRH/q8mTQgTF4sk0bnv//zEuqRMjYycuuj///5wxZzIvLSMTUxYyZL////86ZBqh4D+QUIABcwBQBLMCmAeTA4wJowO8E2DAeYwQ8CWMDLBHDB1QpIxscoSMwBQJj/WZBA3O4mFMHIAGzAKAVgwmcG8OIV//uSZCIN9VQ4wgd/gAAAAA0g4AABD+S/Di5+qgAAADSAAAAEEzcNTC4yM0m41SLDHAJLSggBKwtKRwb6+IBi4ctbepDskh2KmAgA16NTNrON66ptO40mNa9ayZHVx7zmGPHktZb7vP9xLn4fr+9jeO//8P+z39///9T/////t+d6vf1+c6fP9Hv5cxg4aA4TgkGIYmLbYHGAxaCjHwlM0lwBC4zGwzVG+MFnGoTY8sn0w1MSHA09vAM8ssDCSYAykIABmeCI4AKDMDIRfGbFAjWE8h+BfIEfBoFCTQJUcA5ZIrQDjzQ+gWzxsjDLtE4s46kxjHZZom2SXfyj6uadvNvb0ee/3dX//01YAVKw/FoW3hDrwUDTAwDMVigy8rTYaRNKug2tzzBwxnAx/DOuMhFECAOxWsDO6kAwkdQFH0BiwIgYlAwCgdAwiZBBI1kCC5JcWwCQWMQ/JQnkVFkOVN8oku8yDkjbMiry+2rrLvW/MvT53q/yv+n2///dywQL8DRgOgsrBBi0LGcngZrCZgYxGEAoZ+IplUdGJ1ifHVRh5v/7kmRMDPOhJ0MTn6qAAAANIAAAARDEiQhOf0pAAAA0gAAABAdCcEnCwmbqA1JhbIFwYKEAUGAXgOJo45oXAyjT0MinMgXM2UNoNGyYeLN0ENORMgQC5EYAJlr4Z3L3lgaHG5VO0lWX1q92J3t9sWM+bu9/fe8/VT/L+zq9v+zr9/+//8r71SAAAA9tq0AA1hzXXdxmzgPWzJyU20wh4EDDUSzWI4x4rgMGBd+IImDoAiEBAMCJn2HpqAlRpDIZhbxxp2ASQcGVRJG6RC4xmaZHiYlYPKGGdEGJjIoa4YtICXGHRhGJg2QMkYJADRGfCMTZE5+4ze1gMF1k163DfQrNgh83G3zIYoMdC4wEOwcrzMxMMam0AlYxkKzOgqMDhUuUBgYIQOWiEgwYHAogAwXBAYHAKAVVm0ZW2J1Wno9taaAzuOSF34AjMUjdBOy+pjbpKCil9TG/hOWRkUkxad2pAAAGFlrIADgyUqh1syPqzGQRoUAEDDoFgKMDw7MVA2NJ1sKHaMVghBwfGAgOgJR0migMTBUODDQezBI5jGNQzXD/+5JkjYD20jDN67/kngAADSAAAAEXjN0dTv9SAAAANIAAAASwgEb7HKvHZpiFAM0Bgs8wPYBNNi8MMfMIKRGRlOETOErM6wMGpBTQHTjJEQaKEBoKmlLXGizd5Ax5W2Byh0X6R9YRJ2rQFSKzgZDB0DQDKJHDr/MoZRDsaleN+vVhpoVqzczvZYx+Hdbx1/MuWOZb///Vr1YX93I/6P9KAWAQE8pFZWkOCuFAO0EEAThJ4OYwBQMHIJgUUVrHHRwaURUkZ4YX6MYvO6EDvpgTJY6aVeR7mGcgzBgfQE2YCuA5H9adJQKBCAhAqA53/aS/bk0T1zjIhpmcjVumpqS/ZZ1v6TuOXxF1+49x5d5Knl/Luvw7ua/8P/DdWT+dOkhD5zhvqb0db/93/5AQAQsF3glyO4MAysKti2BGAAdE0L31C4EMAhEAgAu28hgMOFHwEgaYACAFHpko0GM0ia2Yx0/wmKECIhpq5poYK2CTmAQAMhgAQBKYAoARFUAhUQbKhIMAxAFG3eFpLns4drJbaY9+pDVDPZ/QKtLHKNCpsTA6//uSZIEE9GAuRhNfzIAAAA0gAAABEnjLFK588sAAADSAAAAEdTXMSKxfop3DPM5RNbal/EvU7p6/Ie/t93Z1v6OqEAzmEmBoIQcGTCwGMCghPwvOQgUwEbKMZBgNAwOPZioUiMIl/ACXRGoREDB0clmTLApMiq4x2azRlmMM7NijivBEQxUIGvMGdAsjAxgHcDSxgRZANSYAOAgYs0FXAnwaIl43xAcuEVEogHIiFKRHEuREzUfFfSOoEgRyTk8Isema00Fl0gzqujqL/ZT3Krfoq7r1H/AvWzp/yXv/3f/oA0GjFwIZS19BgKAsiCDxuUBAMZ8D6zIZAIFMChweF7GFbQAITYoiSSSvMRBoUJ5l4RGVzOa2hhmAr6mbNSaYcYlxgqAvmAaCEYDAE6yBgAFIpAsGADyaXw+/MSnONGVBjhuNW+/dbYnEQqJJNwIgainmo0TB3Ofkus/yHs5P3dnW/+ryf+QqTEFNRTMuMTAwqqqqqqqqqqqqAABjBgrdYuwIwHSioNCCFkYbBZpMaoVDIRMDhB326ByJkJgYuGdC4P/7kmSwDPT4N0MLn6SAAAANIAAAARDIpRJOePLAAAA0gAAABDAGIA0YOGJhoVGKx+YbQxu2mmHbCT5rII6wYW2ASgYFJDgHYBAIpMARM6WcpEFALUjnWoXbkbwf8AGkx+2FugJGw/l2gIK+vverzfFet8Re/kur09f/f/u6f/1GySAhOMFigxOOnJAAdLIIqmTCCa9ahACTDANMqFMLAIQjQw0EVbjH4aOuN8OAgFCBn0sS0GpU0IAjUJ3MCoPaDTTB4AwnIE7MGrBCjAcgE836g5kUx6AtCKkjKElvKarxnFzLOlKRocalMtnabKM6hpYW5TSrdLe1Kop3e+ZWtymHt445fv9Vfyy/Hn5Xv///v1bXt4M9Z7+o729b+K/4b6pMQU1FMy4xMDCqqqqqqqqqqqoAArJ2QY8DbERAFjDyZMdBUwYDwIEDHduP9KsmPhhMKGHR0ZzTg0NTB4kGhkYqgZ2MZGQRUYNHoGXBgA4HWYEoBbGCNgvJhVgV8ZJaR2GsQJb5g5gRMYD+BQmAhADQNAVRoA4EQAOXUBwAkYBsAVr/+5Jk0w/0GynDE59coAAADSAAAAEULMkADn9SAAAANIAAAATsdabY4ta/VUMV5DuqzWuVs3pSSLmoKyJqFQGpUi+IAy2PdQm57ZU/m8oR6dDu/KvzehHpx5O/KkuvNN/o39SX9fblC3lusxd7wMr2zmhS+YLExsQBmRRQGKE6HITacxM2hgy8ATH50NVDsxSlQMPDL4bNJAg7HUAIBQcOjCRbMBtAdDAAACkwB4EWMCzCGTGll+U7EVMUMoPCSjDHgWcwaECqP+mza0I1QpATkY0Sm3lwsB0q0C3xd6GWuF4jEAeiqacWb5bdVxJbap8YzlnZWta3hLq34RaGf5hj3/pZ3HveY/3ku7/5a/7Wf//9/92aGoPcO9Z3nep/9H+mTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqgBOZ2IMSwdMDATGQhDC4ZXKRj8wGMxub0k5717G//uSZPaO9axfvJOfPEAAAA0gAAABFsja3g5/cEAAADSAAAAELQSBSmZKFYVCYsIjBA1MCgYxWdDkBzMRAEwgQDIIBMgFIzWQTUjgPK3c02lpDWsiqM0Ih0w6QzjB4BzMDcD4wFgEzAfAeQQs8TcsNydp+n5wlq8UapFM2auMpwfZrv475ll25Y5ll3mtzMuwCWO8Ocqe/lndv+j/b1f6/9QATU2x0wCPIAYTCoUHAxhIYX2MXBDC24mvTCAedLotPVa09tEZwuBrSZmkoXXBgkY2SmmPBjQkpGrwfaYZQGhQDcPACJNPw90xLlijCVZWUifsophFk7ww7v7fGk6gE/vB+l0VNkSFwo0bYXJC6gyQQEiwvlDzbHAhHpZLIQbJ1UxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUASWNHVvyNdkdcuCnNLhmA8HuRIHbo/1AhfJ9JZVctla8gMQwpDT96eCGcDAGg8qCCIBce3D8P35RGMZXL8gcmxBByacE9hDD09hNohydtFshlp7EeIe9aMiMe/P/7kmTNjPTPJLaLvPDwAAANIAAAAQ/obuBt+FJAAAA0gAAABEchD3bEIchgekEBmZYRmyPAM3j4DJ8fhgfmeIjtD4HTwPAiPgNGB+BAAjtCABG8AwMvgwAEo5cSIfzt69YYDMdo9RxSsKtgIcom1PMylIK9rWkMkKzctAIIkqXCTqLYAoUrBCJrAlHzJipaMuaPvWraLnsMj6ExUtGUZ0ZRnJ7Q6PrnS7VrsC55kSlRyTYjonPkkybMT2AyVMrbMrYly661bq13Fz0K2JlbEdH1zk9ocnsB09CcutLYmj71p7Q6PWDI+hMXWjJ06Mozk9odH0BkfQmLrRlGdE6M5JrhKJzZKPoSSephKVHJlGcmLhkZXJJ9CYnrRkqSmMZybKpMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5Jk7QT0dTc4kxw0ogAADSAAAAEZOaLm5+WQSAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqglFJEIRoPjA2MDYyViqViCJxDHghjyPQ4ioUiYKw4EMzYZXAooDEE1y2zRpTu00acWUWWcacaUWYeWcacJAhYgWJFCRQGIFiBZZRZRZlw7s7PG////s7M7Ozs7M5xpRZR5RRpxZRZh5RRZRbRC1NP///9PKqqq4NNNNRKqJXTTTTVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZIIP9BFGHYksMlIAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==';\r\n\r\n/**\r\n * @typedef initParameters - Parameters for initializing the AudioPeer\r\n * @type {object}\r\n * @property {string} targetElementId - Target element where new elements will be appended.\r\n * @property {string} siteUrl: The url of the current site.\r\n */\r\nconst initParameters = {\r\n  targetElementId: null,\r\n  siteUrl: null,\r\n};\r\n\r\n/**\r\n * @class The first layer of abstraction on the PeerJS library.\r\n * It meant to be extended by the two seperate client classes, Speaker and Listener.\r\n * It implements the shared methods and properties of both classes.\r\n */\r\nclass AudioPeer {\r\n  /**\r\n   * Creates an instance of AudioPeer\r\n   * Takes the url of the current site and a target element where html elements will be appended.\r\n   *\r\n   * @param params - See type definition for initParameters.\r\n   * @param param\r\n   * @example\r\n   */\r\n  constructor(param = initParameters) {\r\n    // PeerJS\r\n    /* Create the Peer object for our end of the connection. */\r\n    this.peer = new (peerjs__WEBPACK_IMPORTED_MODULE_0___default())({\r\n      secure: true,\r\n      host: 'easyeyes-peer-server.herokuapp.com',\r\n      port: 443,\r\n    });\r\n    this.conn = null;\r\n    this.lastPeerId = null;\r\n\r\n    // Display information to HTML elem with given id\r\n    this.targetElement = param.targetElementId;\r\n\r\n    this.siteUrl = param.siteUrl;\r\n    this.debug = false;\r\n    // Store for all incoming data\r\n    this.dataStore = [];\r\n\r\n    // Create and play sounds using this audio context\r\n    this.sourceAudioContext = new (window.AudioContext ||\r\n      window.webkitAudioContext ||\r\n      window.audioContext)();\r\n  }\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Helper method to display information to DOM element\r\n   *\r\n   * @param {string} message\r\n   * @param {boolean} append\r\n   * @example\r\n   */\r\n  displayUpdate = (message, append = true) => {\r\n    // If the specified elem exists, update that elem\r\n    if (document.getElementById(this.targetElement)) {\r\n      const displayElement = document.getElementById(this.targetElement);\r\n      if (append) {\r\n        displayElement.innerText += `\\n${message}`;\r\n      } else {\r\n        displayElement.innerText = message;\r\n      }\r\n    } else {\r\n      console.log('MESSAGE: ', message);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Callback method for when a peer connection is lost\r\n   * saves the last peer id, last server id, and attempts to reconnect.\r\n   *\r\n   * @example\r\n   */\r\n  onPeerDisconnected = () => {\r\n    this.displayUpdate('Connection lost. Please reconnect');\r\n\r\n    // Workaround for peer.reconnect deleting previous id\r\n    this.peer.id = this.lastPeerId;\r\n    // eslint-disable-next-line no-underscore-dangle\r\n    this.peer._lastServerId = this.lastPeerId;\r\n    this.peer.reconnect();\r\n  };\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Callback method that cleans up after peer connection is closed\r\n   *\r\n   * @example\r\n   */\r\n  onPeerClose = () => {\r\n    this.displayUpdate('Connection closed');\r\n    this.conn = null;\r\n  };\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Helper method for when an error occurs\r\n   *\r\n   * @param {*} err\r\n   * @example\r\n   */\r\n  onPeerError = err => {\r\n    this.displayUpdate(err);\r\n    console.log(`${err}`);\r\n  };\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Helper method that converts url paramters to an object\r\n   *\r\n   * @returns {object}\r\n   * @example\r\n   */\r\n  parseURLSearchParams = () =>\r\n    // SOURCE: chickens, https://stackoverflow.com/questions/8648892/how-to-convert-url-parameters-to-a-javascript-object\r\n    // eslint-disable-next-line no-restricted-globals\r\n    Object.fromEntries(new URLSearchParams(location.search));\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Helper method that converts an object to a query string\r\n   *\r\n   * @param {object} params\r\n   * @returns {string}\r\n   * @example\r\n   */\r\n  queryStringFromObject = params =>\r\n    Object.keys(params)\r\n      .map(key => `${key}=${params[key]}`)\r\n      .join('&');\r\n\r\n  static keypressFeedbackSound = pressFeedbackURI;\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (AudioPeer);\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/peer-connection/audioPeer.js?");

/***/ }),

/***/ "./src/peer-connection/listener.js":
/*!*****************************************!*\
  !*** ./src/peer-connection/listener.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _audioPeer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audioPeer */ \"./src/peer-connection/audioPeer.js\");\n/* harmony import */ var _peerErrors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./peerErrors */ \"./src/peer-connection/peerErrors.js\");\n\r\n\r\n\r\n/**\r\n * @class Handles the listener's side of the connection. Responsible for getting access to user's microphone,\r\n * and initiating a call to the Speaker.\r\n * @augments AudioPeer\r\n */\r\nclass Listener extends _audioPeer__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  /**\r\n   * Takes a target element where html elements will be appended.\r\n   *\r\n   * @param params - See type definition for initParameters.\r\n   * @example\r\n   */\r\n  constructor(params) {\r\n    super(params);\r\n\r\n    this.startTime = Date.now();\r\n    this.receiverPeerId = null;\r\n\r\n    const urlParameters = this.parseURLSearchParams();\r\n    this.speakerPeerId = urlParameters.speakerPeerId;\r\n\r\n    this.peer.on('open', this.onPeerOpen);\r\n    this.peer.on('connection', this.onPeerConnection);\r\n    this.peer.on('disconnected', this.onPeerDisconnected);\r\n    this.peer.on('close', this.onPeerClose);\r\n    this.peer.on('error', this.onPeerError);\r\n  }\r\n\r\n  onPeerOpen = id => {\r\n    this.displayUpdate('Listener - onPeerOpen');\r\n    // Workaround for peer.reconnect deleting previous id\r\n\r\n    if (id === null) {\r\n      this.displayUpdate('Received null id from peer open');\r\n      this.peer.id = this.lastPeerId;\r\n    } else {\r\n      this.lastPeerId = this.peer.id;\r\n    }\r\n\r\n    this.join();\r\n  };\r\n\r\n  onPeerConnection = connection => {\r\n    this.displayUpdate('Listener - onPeerConnection');\r\n    // Disallow incoming connections\r\n    connection.on('open', () => {\r\n      connection.send('Sender does not accept incoming connections');\r\n      setTimeout(() => {\r\n        connection.close();\r\n      }, 500);\r\n    });\r\n  };\r\n\r\n  onConnData = data => {\r\n    this.displayUpdate('Listener - onConnData');\r\n    const hasSpeakerID = Object.prototype.hasOwnProperty.call(data, 'speakerPeerId');\r\n    if (!hasSpeakerID) {\r\n      this.displayUpdate('Error in parsing data received! Must set \"speakerPeerId\" property');\r\n      throw new _peerErrors__WEBPACK_IMPORTED_MODULE_1__.MissingSpeakerIdError('Must set \"speakerPeerId\" property');\r\n    } else {\r\n      // this.conn.close();\r\n      this.displayUpdate(this.speakerPeerId);\r\n      this.speakerPeerId = data.speakerPeerId;\r\n      const newParams = {\r\n        speakerPeerId: this.speakerPeerId,\r\n      };\r\n      /*\r\n      FUTURE does this limit usable environments?\r\n      ie does this work if internet is lost after initial page load?\r\n      */\r\n      window.location.search = this.queryStringFromObject(newParams); // Redirect to correctly constructed keypad page\r\n    }\r\n  };\r\n\r\n  join = () => {\r\n    this.displayUpdate('Listener - join');\r\n    /**\r\n     * Create the connection between the two Peers.\r\n     *\r\n     * Sets up callbacks that handle any events related to the\r\n     * connection and data received on it.\r\n     */\r\n    // Close old connection\r\n    if (this.conn) {\r\n      this.displayUpdate('Closing old connection');\r\n      this.conn.close();\r\n    }\r\n\r\n    // Create connection to destination peer specified by the query param\r\n    this.displayUpdate(`Creating connection to: ${this.speakerPeerId}`);\r\n    this.conn = this.peer.connect(this.speakerPeerId, {\r\n      reliable: true,\r\n    });\r\n\r\n    this.displayUpdate('Created connection');\r\n\r\n    this.conn.on('open', async () => {\r\n      this.displayUpdate('Listener - conn open');\r\n      // this.sendSamplingRate();\r\n      await this.openAudioStream();\r\n    });\r\n\r\n    // Handle incoming data (messages only since this is the signal sender)\r\n    this.conn.on('data', this.onConnData);\r\n    this.conn.on('close', () => {\r\n      console.log('Connection closed');\r\n    });\r\n  };\r\n\r\n  getMobileOS = () => {\r\n    const ua = navigator.userAgent;\r\n    if (/android/i.test(ua)) {\r\n      return 'Android';\r\n    }\r\n    if (\r\n      /iPad|iPhone|iPod/.test(ua) ||\r\n      ((navigator?.userAgentData?.platform || navigator?.platform) === 'MacIntel' &&\r\n        navigator.maxTouchPoints > 1)\r\n    ) {\r\n      return 'iOS';\r\n    }\r\n    return 'Other';\r\n  };\r\n\r\n  sendSamplingRate = sampleRate => {\r\n    this.displayUpdate('Listener - sendSamplingRate');\r\n    this.conn.send({\r\n      name: 'samplingRate',\r\n      payload: sampleRate,\r\n    });\r\n  };\r\n\r\n  applyHQTrackConstraints = async stream => {\r\n    // Contraint the incoming audio to the sampling rate we want\r\n    const track = stream.getAudioTracks()[0];\r\n    const capabilities = track.getCapabilities();\r\n\r\n    this.displayUpdate(\r\n      `Listener Track Capabilities - ${JSON.stringify(capabilities, undefined, 2)}`\r\n    );\r\n\r\n    const constraints = track.getConstraints();\r\n\r\n    if (capabilities.echoCancellation) {\r\n      constraints.echoCancellation = false;\r\n    }\r\n\r\n    if (capabilities.sampleRate) {\r\n      constraints.sampleRate = 96000;\r\n    }\r\n\r\n    if (capabilities.sampleSize) {\r\n      constraints.sampleSize = 24;\r\n    }\r\n\r\n    if (capabilities.channelCount) {\r\n      constraints.channelCount = 1;\r\n    }\r\n\r\n    this.displayUpdate(`Listener Track Constraints - ${JSON.stringify(constraints, undefined, 2)}`);\r\n\r\n    // await the promise\r\n    try {\r\n      await track.applyConstraints(constraints);\r\n    } catch (err) {\r\n      console.error(err);\r\n      this.displayUpdate(`Error applying constraints to track: ${err}`);\r\n    }\r\n\r\n    const settings = track.getSettings();\r\n    this.displayUpdate(`Listener Track Settings - ${JSON.stringify(settings, undefined, 2)}`);\r\n    return settings.sampleRate;\r\n  };\r\n\r\n  getMediaDevicesAudioContraints = () => {\r\n    const availableConstraints = navigator.mediaDevices.getSupportedConstraints();\r\n\r\n    this.displayUpdate(\r\n      `Listener MediaDevices Available Contraints  - ${JSON.stringify(\r\n        availableConstraints,\r\n        undefined,\r\n        2\r\n      )}`\r\n    );\r\n\r\n    const contraints = {\r\n      // ...(availableConstraints.echoCancellation && availableConstraints.echoCancellation == true\r\n      //   ? {echoCancellation: {exact: false}}\r\n      //   : {}),\r\n      ...(availableConstraints.sampleRate && availableConstraints.sampleRate == true\r\n        ? {sampleRate: {ideal: 96000}}\r\n        : {}),\r\n      ...(availableConstraints.sampleSize && availableConstraints.sampleSize == true\r\n        ? {sampleSize: {ideal: 24}}\r\n        : {}),\r\n      ...(availableConstraints.channelCount && availableConstraints.channelCount == true\r\n        ? {channelCount: {exact: 1}}\r\n        : {}),\r\n    };\r\n\r\n    this.displayUpdate(\r\n      `Listener MediaDevices Contraints - ${JSON.stringify(contraints, undefined, 2)}`\r\n    );\r\n\r\n    return contraints;\r\n  };\r\n\r\n  openAudioStream = async () => {\r\n    this.displayUpdate('Listener - openAudioStream');\r\n    const mobileOS = this.getMobileOS();\r\n    if (false) {}\r\n\r\n    navigator.mediaDevices\r\n      .getUserMedia({\r\n        audio: this.getMediaDevicesAudioContraints(),\r\n        video: false,\r\n      })\r\n      .then(stream => {\r\n        this.applyHQTrackConstraints(stream)\r\n          .then(sampleRate => {\r\n            this.sendSamplingRate(sampleRate);\r\n            this.peer.call(this.speakerPeerId, stream); // one-way call\r\n            this.displayUpdate('Listener - openAudioStream');\r\n          })\r\n          .catch(err => {\r\n            console.log(err);\r\n            this.displayUpdate(\r\n              `Listener - Error in applyHQTrackConstraints - ${JSON.stringify(err, undefined, 2)}`\r\n            );\r\n          });\r\n      })\r\n      .catch(err => {\r\n        console.error(err);\r\n        this.displayUpdate(\r\n          `Listener - Error in getUserMedia - ${JSON.stringify(err, undefined, 2)}`\r\n        );\r\n      });\r\n  };\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Listener);\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/peer-connection/listener.js?");

/***/ }),

/***/ "./src/peer-connection/peerErrors.js":
/*!*******************************************!*\
  !*** ./src/peer-connection/peerErrors.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UnsupportedDeviceError\": function() { return /* binding */ UnsupportedDeviceError; },\n/* harmony export */   \"MissingSpeakerIdError\": function() { return /* binding */ MissingSpeakerIdError; },\n/* harmony export */   \"CalibrationTimedOutError\": function() { return /* binding */ CalibrationTimedOutError; }\n/* harmony export */ });\nclass UnsupportedDeviceError extends Error {\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'UnsupportedDeviceError';\r\n    this.message = message;\r\n  }\r\n}\r\n\r\nclass MissingSpeakerIdError extends Error {\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'missingSpeakerIdError';\r\n    this.message = message;\r\n  }\r\n}\r\n\r\nclass CalibrationTimedOutError extends Error {\r\n  constructor(message) {\r\n    super(message);\r\n    this.name = 'calibrationTimedOutError';\r\n    this.message = message;\r\n  }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/peer-connection/peerErrors.js?");

/***/ }),

/***/ "./src/peer-connection/speaker.js":
/*!****************************************!*\
  !*** ./src/peer-connection/speaker.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var qrcode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! qrcode */ \"./node_modules/qrcode/lib/browser.js\");\n/* harmony import */ var _audioPeer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audioPeer */ \"./src/peer-connection/audioPeer.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n/* harmony import */ var _peerErrors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./peerErrors */ \"./src/peer-connection/peerErrors.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @class Handles the speaker's side of the connection. Responsible for initiating the connection,\r\n * rendering the QRCode, and answering the call.\r\n * @augments AudioPeer\r\n */\r\nclass Speaker extends _audioPeer__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n  /**\r\n   * Takes the url of the current site and a target element where html elements will be appended.\r\n   *\r\n   * @param params - See type definition for initParameters.\r\n   * @param Calibrator - An instance of the AudioCalibrator class, should not use AudioCalibrator directly, instead use an extended class available in /tasks/.\r\n   * @param CalibratorInstance\r\n   * @example\r\n   */\r\n  constructor(params, CalibratorInstance) {\r\n    super(params);\r\n    this.siteUrl += '/listener?';\r\n    this.ac = CalibratorInstance;\r\n    this.result = null;\r\n    this.debug = params?.debug ?? false;\r\n\r\n    /* Set up callbacks that handle any events related to our peer object. */\r\n    this.peer.on('open', this.#onPeerOpen);\r\n    this.peer.on('connection', this.#onPeerConnection);\r\n    this.peer.on('close', this.#onPeerClose);\r\n    this.peer.on('disconnected', this.#onPeerDisconnected);\r\n    this.peer.on('error', this.#onPeerError);\r\n  }\r\n\r\n  /**\r\n   * Async factory method that creates the Speaker object, and returns a promise that resolves to the result of the calibration.\r\n   *\r\n   * @param params - The parameters to be passed to the peer object.\r\n   * @param Calibrator - The class that defines the calibration process.\r\n   * @param CalibratorInstance\r\n   * @param timeOut - The amount of time to wait before timing out the connection (in milliseconds).\r\n   * @public\r\n   * @example\r\n   */\r\n  static startCalibration = async (params, CalibratorInstance, timeOut = 180000) => {\r\n    window.speaker = new Speaker(params, CalibratorInstance);\r\n    const {speaker} = window;\r\n\r\n    // wrap the calibration process in a promise so we can await it\r\n    return new Promise((resolve, reject) => {\r\n      // when a call is received\r\n      speaker.peer.on('call', async call => {\r\n        // Answer the call (one way)\r\n        call.answer();\r\n        speaker.#removeUIElems();\r\n        speaker.#showSpinner();\r\n        speaker.ac.createLocalAudio(document.getElementById(speaker.targetElement));\r\n        // when we start receiving audio\r\n        call.on('stream', async stream => {\r\n          window.localStream = stream;\r\n          window.localAudio.srcObject = stream;\r\n          window.localAudio.autoplay = false;\r\n\r\n          // if the sinkSamplingRate is not set sleep\r\n          while (!speaker.ac.sampleRatesSet()) {\r\n            console.log('SinkSamplingRate is undefined, sleeping');\r\n            await (0,_utils__WEBPACK_IMPORTED_MODULE_2__.sleep)(1);\r\n          }\r\n          // resolve when we have a result\r\n          speaker.result = await speaker.ac.startCalibration(\r\n            stream,\r\n            params.gainValues,\r\n            params.ICalib\r\n          );\r\n          speaker.#removeUIElems();\r\n          resolve(speaker.result);\r\n        });\r\n        // if we do not receive a result within the timeout, reject\r\n        setTimeout(() => {\r\n          reject(\r\n            new _peerErrors__WEBPACK_IMPORTED_MODULE_3__.CalibrationTimedOutError(\r\n              `Calibration failed to produce a result after ${\r\n                timeOut / 1000\r\n              } seconds. Please try again.`\r\n            )\r\n          );\r\n        }, timeOut);\r\n      });\r\n    });\r\n  };\r\n\r\n  static testIIR = async (params, CalibratorInstance, IIR, timeOut = 180000) => {\r\n    window.speaker = new Speaker(params, CalibratorInstance);\r\n    const {speaker} = window;\r\n\r\n    // wrap the calibration process in a promise so we can await it\r\n    return new Promise((resolve, reject) => {\r\n      // when a call is received\r\n      speaker.peer.on('call', async call => {\r\n        // Answer the call (one way)\r\n        call.answer();\r\n        speaker.#removeUIElems();\r\n        speaker.#showSpinner();\r\n        speaker.ac.createLocalAudio(document.getElementById(speaker.targetElement));\r\n        // when we start receiving audio\r\n        call.on('stream', async stream => {\r\n          window.localStream = stream;\r\n          window.localAudio.srcObject = stream;\r\n          window.localAudio.autoplay = false;\r\n\r\n          // if the sinkSamplingRate is not set sleep\r\n          while (!speaker.ac.sampleRatesSet()) {\r\n            console.log('SinkSamplingRate is undefined, sleeping');\r\n            await (0,_utils__WEBPACK_IMPORTED_MODULE_2__.sleep)(1);\r\n          }\r\n          // resolve when we have a result\r\n          speaker.result = await speaker.ac.playMLSwithIIR(stream, IIR);\r\n          speaker.#removeUIElems();\r\n          resolve(speaker.result);\r\n        });\r\n        // if we do not receive a result within the timeout, reject\r\n        setTimeout(() => {\r\n          reject(\r\n            new _peerErrors__WEBPACK_IMPORTED_MODULE_3__.CalibrationTimedOutError(\r\n              `Calibration failed to produce a result after ${\r\n                timeOut / 1000\r\n              } seconds. Please try again.`\r\n            )\r\n          );\r\n        }, timeOut);\r\n      });\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Called after the peer conncection has been opened.\r\n   * Generates a QR code for the connection and displays it.\r\n   *\r\n   * @private\r\n   * @example\r\n   */\r\n  #showQRCode = () => {\r\n    // Get query string, the URL parameters to specify a Listener\r\n    const queryStringParameters = {\r\n      speakerPeerId: this.peer.id,\r\n    };\r\n    const queryString = this.queryStringFromObject(queryStringParameters);\r\n    const uri = this.siteUrl + queryString;\r\n\r\n    // Display QR code for the participant to scan\r\n    const qrCanvas = document.createElement('canvas');\r\n    qrCanvas.setAttribute('id', 'qrCanvas');\r\n    console.log(uri);\r\n    qrcode__WEBPACK_IMPORTED_MODULE_0__.toCanvas(qrCanvas, uri, error => {\r\n      if (error) console.error(error);\r\n    });\r\n\r\n    // If specified HTML Id is available, show QR code there\r\n    if (document.getElementById(this.targetElement)) {\r\n      if (document.getElementById(this.targetElement)) {\r\n        if (this.debug) {\r\n          const linkTag = document.createElement('a');\r\n          linkTag.setAttribute('href', uri);\r\n          linkTag.innerHTML = \"Use computer's microphone to calibrate?\";\r\n          linkTag.target = '_blank';\r\n          document.getElementById(this.targetElement).appendChild(linkTag);\r\n        }\r\n      }\r\n      document.getElementById(this.targetElement).appendChild(qrCanvas);\r\n    } else {\r\n      // or just print it to console\r\n      console.log('TEST: Peer reachable at: ', uri);\r\n    }\r\n  };\r\n\r\n  #showSpinner = () => {\r\n    const spinner = document.createElement('div');\r\n    spinner.className = 'spinner-border ml-auto';\r\n    spinner.role = 'status';\r\n    spinner.ariaHidden = 'true';\r\n    document.getElementById(this.targetElement).appendChild(spinner);\r\n  };\r\n\r\n  #removeUIElems = () => {\r\n    const parent = document.getElementById(this.targetElement);\r\n    while (parent.firstChild) {\r\n      parent.firstChild.remove();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called when the peer connection is opened.\r\n   * Saves the peer id and calls the QR code generator.\r\n   *\r\n   * @param peerId - The peer id of the peer connection.\r\n   * @param id\r\n   * @private\r\n   * @example\r\n   */\r\n  #onPeerOpen = id => {\r\n    // Workaround for peer.reconnect deleting previous id\r\n    if (id === null) {\r\n      console.error('Received null id from peer open');\r\n      this.peer.id = this.lastPeerId;\r\n    } else {\r\n      this.lastPeerId = this.peer.id;\r\n    }\r\n\r\n    if (id !== this.peer.id) {\r\n      console.warn('DEBUG Check you assumption that id === this.peer.id');\r\n    }\r\n\r\n    this.#showQRCode();\r\n  };\r\n\r\n  /**\r\n   * Called when the peer connection is established.\r\n   * Enforces a single connection.\r\n   *\r\n   * @param connection - The connection object.\r\n   * @private\r\n   * @example\r\n   */\r\n  #onPeerConnection = connection => {\r\n    // Allow only a single connection\r\n    if (this.conn && this.conn.open) {\r\n      connection.on('open', () => {\r\n        connection.send('Already connected to another client');\r\n        setTimeout(() => {\r\n          connection.close();\r\n        }, 500);\r\n      });\r\n      return;\r\n    }\r\n\r\n    this.conn = connection;\r\n    console.log('Connected to: ', this.conn.peer);\r\n    this.#ready();\r\n  };\r\n\r\n  /**\r\n   * Called when the peer connection is closed.\r\n   *\r\n   * @private\r\n   * @example\r\n   */\r\n  #onPeerClose = () => {\r\n    this.conn = null;\r\n    console.log('Connection destroyed');\r\n  };\r\n\r\n  /**\r\n   * Called when the peer connection is disconnected.\r\n   * Attempts to reconnect.\r\n   *\r\n   * @private\r\n   * @example\r\n   */\r\n  #onPeerDisconnected = () => {\r\n    console.log('Connection lost. Please reconnect');\r\n\r\n    // Workaround for peer.reconnect deleting previous id\r\n    this.peer.id = this.lastPeerId;\r\n    // eslint-disable-next-line no-underscore-dangle\r\n    this.peer._lastServerId = this.lastPeerId;\r\n    this.peer.reconnect();\r\n  };\r\n\r\n  /**\r\n   * Called when the peer connection encounters an error.\r\n   *\r\n   * @param error\r\n   * @private\r\n   * @example\r\n   */\r\n  #onPeerError = error => {\r\n    // TODO: check if this function is needed or not\r\n    console.error(error);\r\n  };\r\n\r\n  /**\r\n   * Called when data is received from the peer connection.\r\n   *\r\n   * @param data\r\n   * @private\r\n   * @example\r\n   */\r\n  #onIncomingData = data => {\r\n    // enforce object type\r\n    if (\r\n      !Object.prototype.hasOwnProperty.call(data, 'name') ||\r\n      !Object.prototype.hasOwnProperty.call(data, 'payload')\r\n    ) {\r\n      console.error('Received malformed data: ', data);\r\n      return;\r\n    }\r\n\r\n    switch (data.name) {\r\n      case 'samplingRate':\r\n        this.ac.setSamplingRates(data.payload);\r\n        break;\r\n      case _peerErrors__WEBPACK_IMPORTED_MODULE_3__.UnsupportedDeviceError.name:\r\n      case _peerErrors__WEBPACK_IMPORTED_MODULE_3__.MissingSpeakerIdError.name:\r\n        throw data.payload;\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called when the peer connection is #ready.\r\n   *\r\n   * @private\r\n   * @example\r\n   */\r\n  #ready = () => {\r\n    // Perform callback with data\r\n    this.conn.on('data', this.#onIncomingData);\r\n    this.conn.on('close', () => {\r\n      console.log('Connection reset<br>Awaiting connection...');\r\n      this.conn = null;\r\n    });\r\n  };\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Debug method for downloading the recorded audio\r\n   *\r\n   * @public\r\n   * @example\r\n   */\r\n  downloadData = () => {\r\n    this.ac.downloadData();\r\n  };\r\n}\r\n\r\n/* \r\nReferenced links:\r\nhttps://stackoverflow.com/questions/28016664/when-you-pass-this-as-an-argument/28016676#28016676\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\r\nhttps://stackoverflow.com/questions/879152/how-do-i-make-javascript-beep [3]\r\n*/\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Speaker);\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/peer-connection/speaker.js?");

/***/ }),

/***/ "./src/server/PythonServerAPI.js":
/*!***************************************!*\
  !*** ./src/server/PythonServerAPI.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n\r\n/**\r\n *\r\n */\r\nclass PythonServerAPI {\r\n  static PYTHON_SERVER_URL = 'https://easyeyes-python-flask-server.herokuapp.com';\r\n\r\n  static TEST_SERVER_URL = 'http://127.0.0.1:5000';\r\n\r\n  /**\r\n   * @param data- -\r\n   * g = inverted impulse response, when convolved with the impulse\r\n   * reponse, they cancel out.\r\n   * @param data.payload\r\n   * @param data.sampleRate\r\n   * @param data.P\r\n   * @param data-.payload\r\n   * @param data-.sampleRate\r\n   * @param data-.P\r\n   * @returns\r\n   * @example\r\n   */\r\n  getImpulseResponse = async ({payload, sampleRate, P}) => {\r\n    const task = 'impulse-response';\r\n    let res = null;\r\n\r\n    console.log({payload});\r\n\r\n    const data = JSON.stringify({\r\n      task,\r\n      payload,\r\n      'sample-rate': sampleRate,\r\n      P,\r\n    });\r\n\r\n    await axios__WEBPACK_IMPORTED_MODULE_0___default()({\r\n      method: 'post',\r\n      baseURL: PythonServerAPI.PYTHON_SERVER_URL,\r\n      url: `/task/${task}`,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      data,\r\n    })\r\n      .then(response => {\r\n        res = response;\r\n      })\r\n      .catch(error => {\r\n        throw error;\r\n      });\r\n\r\n    return res.data[task];\r\n  };\r\n\r\n  getInverseImpulseResponse = async ({payload}) => {\r\n    const task = 'inverse-impulse-response';\r\n    let res = null;\r\n\r\n    console.log({payload});\r\n\r\n    const data = JSON.stringify({\r\n      task,\r\n      payload,\r\n    });\r\n\r\n    await axios__WEBPACK_IMPORTED_MODULE_0___default()({\r\n      method: 'post',\r\n      baseURL: PythonServerAPI.PYTHON_SERVER_URL,\r\n      url: `/task/${task}`,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      data,\r\n    })\r\n      .then(response => {\r\n        res = response;\r\n      })\r\n      .catch(error => {\r\n        throw error;\r\n      });\r\n\r\n    return res.data[task];\r\n  };\r\n\r\n  getVolumeCalibration = async ({payload, sampleRate, lCalib}) => {\r\n    const task = 'volume';\r\n    let res = null;\r\n\r\n    console.log({payload});\r\n\r\n    const data = JSON.stringify({\r\n      task,\r\n      payload,\r\n      'sample-rate': sampleRate,\r\n      lCalib,\r\n    });\r\n\r\n    await axios__WEBPACK_IMPORTED_MODULE_0___default()({\r\n      method: 'post',\r\n      baseURL: PythonServerAPI.PYTHON_SERVER_URL,\r\n      url: `/task/${task}`,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      data,\r\n    })\r\n      .then(response => {\r\n        res = response;\r\n      })\r\n      .catch(error => {\r\n        throw error;\r\n      });\r\n\r\n    return res.data[task];\r\n  };\r\n\r\n  getVolumeCalibrationParameters = async ({inDBValues, outDBSPLValues, lCalib}) => {\r\n    const task = 'volume-parameters';\r\n    let res = null;\r\n\r\n    const data = JSON.stringify({\r\n      task,\r\n      inDBValues,\r\n      outDBSPLValues,\r\n      lCalib,\r\n    });\r\n\r\n    await axios__WEBPACK_IMPORTED_MODULE_0___default()({\r\n      method: 'post',\r\n      baseURL: PythonServerAPI.PYTHON_SERVER_URL, //server\r\n      url: `/task/${task}`,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      data,\r\n    })\r\n      .then(response => {\r\n        res = response;\r\n      })\r\n      .catch(error => {\r\n        throw error;\r\n      });\r\n\r\n    // console.log(res.data[task]);\r\n    //below is an example of res.data[task]\r\n    //{\r\n    //  R: 16.56981076554259,\r\n    //  RMSError: 1.9289162528535229\r\n    //  T: -47.79799120884434,\r\n    //  W: 61.0485247483732,\r\n    //  backgroundDBSPL: 43.88233142069752,\r\n    //  gainDBSPL: -128.24742161208985\r\n    //}\r\n    return res.data[task];\r\n  };\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (PythonServerAPI);\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/server/PythonServerAPI.js?");

/***/ }),

/***/ "./src/tasks/audioCalibrator.js":
/*!**************************************!*\
  !*** ./src/tasks/audioCalibrator.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _audioRecorder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audioRecorder */ \"./src/tasks/audioRecorder.js\");\n/* harmony import */ var _server_PythonServerAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server/PythonServerAPI */ \"./src/server/PythonServerAPI.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"./src/utils.js\");\n/* eslint-disable no-await-in-loop */\r\n\r\n\r\n\r\n\r\n/**\r\n * .\r\n * .\r\n * .\r\n * Provides methods for calibrating the user's speakers\r\n *\r\n * @extends AudioRecorder\r\n */\r\nclass AudioCalibrator extends _audioRecorder__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  /**\r\n   *\r\n   * @param numCaptures\r\n   * @param numMLSPerCapture\r\n   * @example\r\n   */\r\n  constructor(numCaptures = 1, numMLSPerCapture = 1) {\r\n    super();\r\n    this.numCaptures = numCaptures;\r\n    this.numMLSPerCapture = numMLSPerCapture;\r\n    this.pyServerAPI = new _server_PythonServerAPI__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\r\n  }\r\n\r\n  /** @private */\r\n  #isCalibrating = false;\r\n\r\n  /** @private */\r\n  sourceAudioContext;\r\n\r\n  /** @protected */\r\n  numCalibratingRounds = 1;\r\n\r\n  /** @protected */\r\n  numSuccessfulCaptured = 0;\r\n\r\n  /** @private */\r\n  sourceSamplingRate;\r\n\r\n  /** @protected */\r\n  calibrationNodes = [];\r\n\r\n  /** @protected */\r\n  localAudio;\r\n\r\n  /**\r\n   * Called when a call is received.\r\n   * Creates a local audio DOM element and attaches it to the page.\r\n   *\r\n   * @param targetElement\r\n   * @example\r\n   */\r\n  createLocalAudio = targetElement => {\r\n    this.localAudio = document.createElement('audio');\r\n    this.localAudio.setAttribute('id', 'localAudio');\r\n    targetElement.appendChild(this.localAudio);\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @param {MediaStream} stream\r\n   * @param {Function} playCalibrationAudio - (async) function that plays the calibration audio\r\n   * @param {*} beforePlay - (async) function that is called before playing the audio\r\n   * @param {*} beforeRecord - (async) function that is called before recording\r\n   * @param {*} duringRecord - (async) function that is called while recording\r\n   * @param {*} afterRecord  - (async) function that is called after recording\r\n   * @example\r\n   */\r\n  calibrationSteps = async (\r\n    stream,\r\n    playCalibrationAudio,\r\n    beforePlay = async () => {},\r\n    beforeRecord = async () => {},\r\n    loopCondition = () => false,\r\n    duringRecord = async () => {},\r\n    afterRecord = async () => {}\r\n  ) => {\r\n    this.numSuccessfulCaptured = 0;\r\n\r\n    // do something before playing such as using the MLS to fill the buffers\r\n    console.warn('beforePlay');\r\n    await beforePlay();\r\n\r\n    // play calibration audio\r\n    console.warn('playCalibrationAudio');\r\n    playCalibrationAudio();\r\n\r\n    // do something before recording such as awaiting a certain amount of time\r\n    console.warn('beforeRecord');\r\n    await beforeRecord();\r\n\r\n    // calibration loop\r\n    while (loopCondition()) {\r\n      // start recording\r\n      console.warn('startRecording');\r\n      await this.startRecording(stream);\r\n\r\n      // do something during the recording such as sleep n amount of time\r\n      console.warn('duringRecord');\r\n      await duringRecord();\r\n\r\n      // when done, stop recording\r\n      console.warn('stopRecording');\r\n      await this.stopRecording();\r\n\r\n      // do something after recording such as start processing values\r\n      console.warn('afterRecord');\r\n      await afterRecord();\r\n\r\n      // eslint-disable-next-line no-await-in-loop\r\n      await (0,_utils__WEBPACK_IMPORTED_MODULE_2__.sleep)(1);\r\n    }\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @param {MediaStream} stream\r\n   * @param {Function} playCalibrationAudio - (async) function that plays the calibration audio\r\n   * @param {*} beforeRecord - (async) function that is called before recording\r\n   * @param {*} afterRecord  - (async) function that is called after recording\r\n   * @param {Number} gainValue - the gain value to set the gain node to\r\n   */\r\n  volumeCalibrationSteps = async (\r\n    stream,\r\n    playCalibrationAudio,\r\n    beforeRecord = () => {},\r\n    afterRecord = () => {},\r\n    gainValue,\r\n    lCalib = 104.92978421490648\r\n  ) => {\r\n    this.numCalibratingRoundsCompleted = 0;\r\n\r\n    // calibration loop\r\n    while (!this.#isCalibrating && this.numCalibratingRoundsCompleted < this.numCalibratingRounds) {\r\n      // before recording\r\n      await beforeRecord(gainValue);\r\n\r\n      // start recording\r\n      await this.startRecording(stream);\r\n\r\n      // play calibration audio\r\n      console.log(`Calibration Round ${this.numCalibratingRoundsCompleted}`);\r\n      await playCalibrationAudio();\r\n\r\n      // when done, stop recording\r\n      console.log('Calibration Round Complete');\r\n      await this.stopRecording();\r\n\r\n      // after recording\r\n      await afterRecord(lCalib);\r\n\r\n      this.calibrationNodes = [];\r\n\r\n      // eslint-disable-next-line no-await-in-loop\r\n      await (0,_utils__WEBPACK_IMPORTED_MODULE_2__.sleep)(2);\r\n      this.numCalibratingRoundsCompleted += 1;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Getter for the isCalibrating property.\r\n   *\r\n   * @public\r\n   * @returns - True if the audio is being calibrated, false otherwise.\r\n   * @example\r\n   */\r\n  getCalibrationStatus = () => this.#isCalibrating;\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Set the sampling rate to the value received from the listener\r\n   *\r\n   * @param {*} sinkSamplingRate\r\n   * @param samplingRate\r\n   * @example\r\n   */\r\n  setSamplingRates = samplingRate => {\r\n    this.sinkSamplingRate = samplingRate;\r\n    this.sourceSamplingRate = samplingRate;\r\n    // this.emit('update', {message: `sampling at ${samplingRate}Hz...`});\r\n  };\r\n\r\n  sampleRatesSet = () => this.sourceSamplingRate && this.sinkSamplingRate;\r\n\r\n  addCalibrationNode = node => {\r\n    this.calibrationNodes.push(node);\r\n  };\r\n\r\n  makeNewSourceAudioContext = () => {\r\n    const options = {\r\n      sampleRate: this.sourceSamplingRate,\r\n    };\r\n\r\n    this.sourceAudioContext = new (window.AudioContext ||\r\n      window.webkitAudioContext ||\r\n      window.audioContext)(options);\r\n\r\n    return this.sourceAudioContext;\r\n  };\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Download the result of the calibration roudns\r\n   *\r\n   * @example\r\n   */\r\n  downloadData = () => {\r\n    const recordings = this.getAllRecordedSignals();\r\n    const i = recordings.length - 1;\r\n    (0,_utils__WEBPACK_IMPORTED_MODULE_2__.saveToCSV)(recordings[i], `recordedMLSignal_${i}.csv`);\r\n  };\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (AudioCalibrator);\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/tasks/audioCalibrator.js?");

/***/ }),

/***/ "./src/tasks/audioRecorder.js":
/*!************************************!*\
  !*** ./src/tasks/audioRecorder.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _myEventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../myEventEmitter */ \"./src/myEventEmitter.js\");\n\r\n\r\n/**\r\n * @class provides a simple interface for recording audio from a microphone\r\n * using the Media Recorder API.\r\n */\r\nclass AudioRecorder extends _myEventEmitter__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  /** @private */\r\n  #mediaRecorder;\r\n\r\n  /** @private */\r\n  #recordedChunks = [];\r\n\r\n  /** @private */\r\n  #audioBlob;\r\n\r\n  /** @private */\r\n  #audioContext;\r\n\r\n  /** @private */\r\n  #recordedSignals = [];\r\n\r\n  /** @private */\r\n  sinkSamplingRate;\r\n\r\n  /**\r\n   * Decode the audio data from the recorded audio blob.\r\n   *\r\n   * @private\r\n   * @example\r\n   */\r\n  #saveRecording = async () => {\r\n    const arrayBuffer = await this.#audioBlob.arrayBuffer();\r\n    const audioBuffer = await this.#audioContext.decodeAudioData(arrayBuffer);\r\n    const data = audioBuffer.getChannelData(0);\r\n\r\n    console.log(`Decoded audio buffer with ${data.length} samples`);\r\n    this.#recordedSignals.push(Array.from(data));\r\n  };\r\n\r\n  /**\r\n   * Event listener triggered when data is available in the media recorder.\r\n   *\r\n   * @private\r\n   * @param e - The event object.\r\n   * @example\r\n   */\r\n  #onRecorderDataAvailable = e => {\r\n    if (e.data && e.data.size > 0) this.#recordedChunks.push(e.data);\r\n  };\r\n\r\n  /**\r\n   * Method to create a media recorder object and set up event listeners.\r\n   *\r\n   * @private\r\n   * @param stream - The stream of audio from the Listener.\r\n   * @example\r\n   */\r\n  #setMediaRecorder = stream => {\r\n    // Create a new MediaRecorder object\r\n    this.#mediaRecorder = new MediaRecorder(stream);\r\n\r\n    // Add event listeners\r\n    this.#mediaRecorder.ondataavailable = e => this.#onRecorderDataAvailable(e);\r\n  };\r\n\r\n  #setAudioContext = () => {\r\n    this.#audioContext = new (window.AudioContext ||\r\n      window.webkitAudioContext ||\r\n      window.audioContext)({\r\n      sampleRate: this.sinkSamplingRate,\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Public method to start the recording process.\r\n   *\r\n   * @param stream - The stream of audio from the Listener.\r\n   * @example\r\n   */\r\n  startRecording = async stream => {\r\n    // Create a fresh audio context\r\n    this.#setAudioContext();\r\n    // Set up media recorder if needed\r\n    if (!this.#mediaRecorder) this.#setMediaRecorder(stream);\r\n    // clear recorded chunks\r\n    this.#recordedChunks = [];\r\n    // start recording\r\n    this.#mediaRecorder.start();\r\n  };\r\n\r\n  /**\r\n   * Method to stop the recording process.\r\n   *\r\n   * @public\r\n   * @example\r\n   */\r\n  stopRecording = async () => {\r\n    // Stop the media recorder, and wait for the data to be available\r\n    await new Promise(resolve => {\r\n      this.#mediaRecorder.onstop = () => {\r\n        // when the stop event is triggered, resolve the promise\r\n        this.#audioBlob = new Blob(this.#recordedChunks, {\r\n          type: 'audio/wav; codecs=opus',\r\n        });\r\n        resolve(this.#audioBlob);\r\n      };\r\n      // call stop\r\n      this.#mediaRecorder.stop();\r\n    });\r\n    // Now that we have data, save it\r\n    await this.#saveRecording();\r\n  };\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Public method to get the last recorded audio signal\r\n   *\r\n   * @returns\r\n   * @example\r\n   */\r\n  getLastRecordedSignal = () => this.#recordedSignals[this.#recordedSignals.length - 1];\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Public method to get all the recorded audio signals\r\n   *\r\n   * @returns\r\n   * @example\r\n   */\r\n  getAllRecordedSignals = () => this.#recordedSignals;\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Public method to set the sampling rate used by the capture device\r\n   *\r\n   * @param {Number} sinkSamplingRate - The sampling rate of the capture device\r\n   * @example\r\n   */\r\n  setSinkSamplingRate = sinkSamplingRate => {\r\n    this.sinkSamplingRate = sinkSamplingRate;\r\n  };\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (AudioRecorder);\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/tasks/audioRecorder.js?");

/***/ }),

/***/ "./src/tasks/impulse-response/impulseResponse.js":
/*!*******************************************************!*\
  !*** ./src/tasks/impulse-response/impulseResponse.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _audioCalibrator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../audioCalibrator */ \"./src/tasks/audioCalibrator.js\");\n/* harmony import */ var _mlsGen_mlsGenInterface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mlsGen/mlsGenInterface */ \"./src/tasks/impulse-response/mlsGen/mlsGenInterface.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ \"./src/utils.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n *\r\n */\r\nclass ImpulseResponse extends _audioCalibrator__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  /**\r\n   * Default constructor. Creates an instance with any number of paramters passed or the default parameters defined here.\r\n   *\r\n   * @param {Object<boolean, number, number, number>} calibratorParams  - paramter object\r\n   * @param {boolean} [calibratorParams.download = false]  - boolean flag to download captures\r\n   * @param {number} [calibratorParams.mlsOrder = 18] - order of the MLS to be generated\r\n   * @param {number} [calibratorParams.numCaptures = 5] - number of captures to perform\r\n   * @param {number} [calibratorParams.numMLSPerCapture = 4] - number of bursts of MLS per capture\r\n   */\r\n  constructor({download = false, mlsOrder = 18, numCaptures = 3, numMLSPerCapture = 3}) {\r\n    super(numCaptures, numMLSPerCapture);\r\n    this.#mlsOrder = parseInt(mlsOrder, 10);\r\n    this.#P = 2 ** mlsOrder - 1;\r\n    this.#download = download;\r\n  }\r\n\r\n  /** @private */\r\n  #download;\r\n\r\n  /** @private */\r\n  #mlsGenInterface;\r\n\r\n  /** @private */\r\n  #mlsBufferView;\r\n\r\n  /** @private */\r\n  invertedImpulseResponse = null;\r\n\r\n  /** @private */\r\n  impulseResponses = [];\r\n\r\n  /** @private */\r\n  #mlsOrder;\r\n\r\n  /** @private */\r\n  #P;\r\n\r\n  /** @private */\r\n  TAPER_SECS = 5;\r\n\r\n  /** @private */\r\n  offsetGainNode;\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Sends all the computed impulse responses to the backend server for processing\r\n   *\r\n   * @returns sets the resulting inverted impulse response to the class property\r\n   * @example\r\n   */\r\n  sendImpulseResponsesToServerForProcessing = async () => {\r\n    const computedIRs = await Promise.all(this.impulseResponses);\r\n    this.emit('update', {message: `computing the IIR...`});\r\n    return this.pyServerAPI\r\n      .getInverseImpulseResponse({\r\n        payload: computedIRs.slice(0, this.numCaptures),\r\n      })\r\n      .then(res => {\r\n        this.emit('update', {message: `done computing the IIR...`});\r\n        this.invertedImpulseResponse = res;\r\n      })\r\n      .catch(err => {\r\n        // this.emit('InvertedImpulseResponse', {res: false});\r\n        console.error(err);\r\n      });\r\n  };\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Sends the recorded signal, or a given csv string of a signal, to the back end server for processing\r\n   *\r\n   * @param {<array>String} signalCsv - Optional csv string of a previously recorded signal, if given, this signal will be processed\r\n   * @example\r\n   */\r\n  sendRecordingToServerForProcessing = signalCsv => {\r\n    const allSignals = this.getAllRecordedSignals();\r\n    const numSignals = allSignals.length;\r\n    const payload =\r\n      signalCsv && signalCsv.length > 0 ? (0,_utils__WEBPACK_IMPORTED_MODULE_2__.csvToArray)(signalCsv) : allSignals[numSignals - 1];\r\n\r\n    this.emit('update', {message: `computing the IR of the last recording...`});\r\n    this.impulseResponses.push(\r\n      this.pyServerAPI\r\n        .getImpulseResponse({\r\n          sampleRate: this.sourceSamplingRate || 96000,\r\n          payload,\r\n          P: this.#P,\r\n        })\r\n        .then(res => {\r\n          if (this.numSuccessfulCaptured < this.numCaptures) {\r\n            this.numSuccessfulCaptured += 1;\r\n            this.emit('update', {\r\n              message: `${this.numSuccessfulCaptured}/${this.numCaptures} IRs computed...`,\r\n            });\r\n          }\r\n          return res;\r\n        })\r\n        .catch(err => {\r\n          console.error(err);\r\n        })\r\n    );\r\n  };\r\n\r\n  /**\r\n   * Passed to the calibration steps function, awaits the desired amount of seconds to capture the desired number\r\n   * of MLS periods defined in the constructor.\r\n   *\r\n   * @example\r\n   */\r\n  #awaitDesiredMLSLength = async () => {\r\n    // seconds per MLS = P / SR\r\n    // await N * P / SR\r\n    this.emit('update', {\r\n      message: `sampling the calibration signal...`,\r\n    });\r\n    await (0,_utils__WEBPACK_IMPORTED_MODULE_2__.sleep)((this.#P / this.sourceSamplingRate) * this.numMLSPerCapture);\r\n  };\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Passed to the calibration steps function, awaits the onset of the signal to ensure a steady state\r\n   *\r\n   * @example\r\n   */\r\n  #awaitSignalOnset = async () => {\r\n    this.emit('update', {\r\n      message: `waiting for the signal to stabalize...`,\r\n    });\r\n    await (0,_utils__WEBPACK_IMPORTED_MODULE_2__.sleep)(this.TAPER_SECS);\r\n  };\r\n\r\n  /**\r\n   * Called immediately after a recording is captured. Used to process the resulting signal\r\n   * whether by sending the result to a server or by computing a result locally.\r\n   *\r\n   * @example\r\n   */\r\n  #afterMLSRecord = () => {\r\n    if (this.#download) {\r\n      this.downloadData();\r\n    }\r\n    this.sendRecordingToServerForProcessing();\r\n  };\r\n\r\n  #afterMLSwIIRRecord = () => {\r\n    if (this.#download) {\r\n      this.downloadData();\r\n    }\r\n    this.#stopCalibrationAudio();\r\n  };\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Created an S Curver Buffer to taper the signal onset\r\n   *\r\n   * @param {*} length\r\n   * @param {*} phase\r\n   * @returns\r\n   * @example\r\n   */\r\n  static createSCurveBuffer = (length, phase) => {\r\n    const curve = new Float32Array(length);\r\n    let i;\r\n    for (i = 0; i < length; i += 1) {\r\n      // scale the curve to be between 0-1\r\n      curve[i] = Math.sin((Math.PI * i) / length - phase) / 2 + 0.5;\r\n    }\r\n    return curve;\r\n  };\r\n\r\n  static createInverseSCurveBuffer = (length, phase) => {\r\n    const curve = new Float32Array(length);\r\n    let i;\r\n    let j = length - 1;\r\n    for (i = 0; i < length; i += 1) {\r\n      // scale the curve to be between 0-1\r\n      curve[i] = Math.sin((Math.PI * j) / length - phase) / 2 + 0.5;\r\n      j -= 1;\r\n    }\r\n    return curve;\r\n  };\r\n\r\n  /**\r\n   * Construct a Calibration Node with the calibration parameters.\r\n   *\r\n   * @param CALIBRATION_TONE_FREQUENCY\r\n   * @private\r\n   * @example\r\n   */\r\n  #createPureTonenNode = CALIBRATION_TONE_FREQUENCY => {\r\n    const audioContext = this.makeNewSourceAudioContext();\r\n    const oscilator = audioContext.createOscillator();\r\n    const gainNode = audioContext.createGain();\r\n\r\n    oscilator.frequency.value = CALIBRATION_TONE_FREQUENCY;\r\n    oscilator.type = 'sine';\r\n    gainNode.gain.value = 0.04;\r\n\r\n    oscilator.connect(gainNode);\r\n    gainNode.connect(audioContext.destination);\r\n\r\n    this.addCalibrationNode(oscilator);\r\n  };\r\n\r\n  /**\r\n   * Construct a Calibration Node with the calibration parameters.\r\n   *\r\n   * @param dataBuffer\r\n   * @private\r\n   * @example\r\n   */\r\n  #createCalibrationNodeFromBuffer = dataBuffer => {\r\n    const audioContext = this.makeNewSourceAudioContext();\r\n    const buffer = audioContext.createBuffer(\r\n      1, // number of channels\r\n      dataBuffer.length,\r\n      audioContext.sampleRate // sample rate\r\n    );\r\n\r\n    const data = buffer.getChannelData(0); // get data\r\n    // fill the buffer with our data\r\n    try {\r\n      for (let i = 0; i < dataBuffer.length; i += 1) {\r\n        data[i] = dataBuffer[i];\r\n      }\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n\r\n    const onsetGainNode = audioContext.createGain();\r\n    this.offsetGainNode = audioContext.createGain();\r\n    const source = audioContext.createBufferSource();\r\n\r\n    source.buffer = buffer;\r\n    source.loop = true;\r\n    source.connect(onsetGainNode);\r\n    onsetGainNode.connect(this.offsetGainNode);\r\n    this.offsetGainNode.connect(audioContext.destination);\r\n\r\n    const onsetCurve = ImpulseResponse.createSCurveBuffer(this.sourceSamplingRate, Math.PI / 2);\r\n    onsetGainNode.gain.setValueCurveAtTime(onsetCurve, 0, this.TAPER_SECS);\r\n\r\n    this.addCalibrationNode(source);\r\n  };\r\n\r\n  /**\r\n   * Given a data buffer, creates the required calibration node\r\n   *\r\n   * @param {*} dataBufferArray\r\n   * @example\r\n   */\r\n  #setCalibrationNodesFromBuffer = (dataBufferArray = [this.#mlsBufferView]) => {\r\n    if (dataBufferArray.length === 1) {\r\n      this.#createCalibrationNodeFromBuffer(dataBufferArray[0]);\r\n    } else {\r\n      throw new Error('The length of the data buffer array must be 1');\r\n    }\r\n  };\r\n\r\n  #createImpulseResponseFilterGraph = (calibrationSignal, iir) => {\r\n    const audioCtx = this.makeNewSourceAudioContext();\r\n\r\n    // -------------------------------------------------------- IIR\r\n    const iirBuffer = audioCtx.createBuffer(\r\n      1,\r\n      // TODO: quality check this\r\n      iir.length - 1,\r\n      audioCtx.sampleRate\r\n    );\r\n\r\n    // Fill the buffer with the inverted impulse response\r\n    const iirChannelZeroBuffer = iirBuffer.getChannelData(0);\r\n    for (let i = 0; i < iirBuffer.length; i += 1) {\r\n      // audio needs to be in [-1.0; 1.0]\r\n      iirChannelZeroBuffer[i] = iir[i];\r\n    }\r\n\r\n    const convolverNode = audioCtx.createConvolver();\r\n\r\n    convolverNode.normalize = false;\r\n    convolverNode.channelCount = 1;\r\n    convolverNode.buffer = iirBuffer;\r\n\r\n    // ------------------------------------------------------ MLS\r\n    const calibrationSignalBuffer = audioCtx.createBuffer(\r\n      1, // number of channels\r\n      calibrationSignal.length,\r\n      audioCtx.sampleRate // sample rate\r\n    );\r\n\r\n    const mlsChannelZeroBuffer = calibrationSignalBuffer.getChannelData(0); // get data\r\n    // fill the buffer with our data\r\n    try {\r\n      for (let i = 0; i < calibrationSignal.length; i += 1) {\r\n        mlsChannelZeroBuffer[i] = calibrationSignal[i];\r\n      }\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n\r\n    const sourceNode = audioCtx.createBufferSource();\r\n\r\n    sourceNode.buffer = calibrationSignalBuffer;\r\n    sourceNode.loop = true;\r\n    sourceNode.connect(convolverNode);\r\n\r\n    convolverNode.connect(audioCtx.destination);\r\n\r\n    console.log({convolverNode, sourceNode});\r\n\r\n    this.addCalibrationNode(sourceNode);\r\n  };\r\n\r\n  #createIIRwMLSGraph = () => {\r\n    this.#createImpulseResponseFilterGraph(this.impulseResponses, [this.#mlsBufferView][0]);\r\n  };\r\n\r\n  /**\r\n   * Creates an audio context and plays it for a few seconds.\r\n   *\r\n   * @private\r\n   * @returns - Resolves when the audio is done playing.\r\n   * @example\r\n   */\r\n  #playCalibrationAudio = () => {\r\n    this.calibrationNodes[0].start(0);\r\n    this.emit('update', {message: 'playing the calibration tone...'});\r\n  };\r\n\r\n  /** .\r\n   * .\r\n   * .\r\n   * Stops the audio with tapered offset\r\n   *\r\n   * @example\r\n   */\r\n  #stopCalibrationAudio = () => {\r\n    this.offsetGainNode.gain.setValueAtTime(\r\n      this.offsetGainNode.gain.value,\r\n      this.sourceAudioContext.currentTime\r\n    );\r\n\r\n    this.offsetGainNode.gain.setTargetAtTime(0, this.sourceAudioContext.currentTime, 0.5);\r\n    this.emit('update', {message: 'stopping the calibration tone...'});\r\n  };\r\n\r\n  playMLSwithIIR = async (stream, iir) => {\r\n    this.invertedImpulseResponse = iir;\r\n    // initialize the MLSGenInterface object with it's factory method\r\n    await _mlsGen_mlsGenInterface__WEBPACK_IMPORTED_MODULE_1__[\"default\"].factory(\r\n      this.#mlsOrder,\r\n      this.sinkSamplingRate,\r\n      this.sourceSamplingRate\r\n    ).then(mlsGenInterface => {\r\n      this.#mlsGenInterface = mlsGenInterface;\r\n      this.#mlsBufferView = this.#mlsGenInterface.getMLS();\r\n    });\r\n\r\n    // after intializating, start the calibration steps with garbage collection\r\n    await this.#mlsGenInterface.withGarbageCollection([\r\n      [\r\n        this.calibrationSteps,\r\n        [\r\n          stream,\r\n          this.#playCalibrationAudio, // play audio func (required)\r\n          this.#createImpulseResponseFilterGraph, // before play func\r\n          null, // before record\r\n          this.#awaitDesiredMLSLength, // during record\r\n          this.#afterMLSwIIRRecord, // after record\r\n        ],\r\n      ],\r\n    ]);\r\n  };\r\n\r\n  /**\r\n   * Public method to start the calibration process. Objects intialized from webassembly allocate new memory\r\n   * and must be manually freed. This function is responsible for intializing the MlsGenInterface,\r\n   * and wrapping the calibration steps with a garbage collection safe gaurd.\r\n   *\r\n   * @public\r\n   * @param stream - The stream of audio from the Listener.\r\n   * @example\r\n   */\r\n  startCalibration = async stream => {\r\n    // initialize the MLSGenInterface object with it's factory method\r\n    await _mlsGen_mlsGenInterface__WEBPACK_IMPORTED_MODULE_1__[\"default\"].factory(\r\n      this.#mlsOrder,\r\n      this.sinkSamplingRate,\r\n      this.sourceSamplingRate\r\n    ).then(mlsGenInterface => {\r\n      this.#mlsGenInterface = mlsGenInterface;\r\n      this.#mlsBufferView = this.#mlsGenInterface.getMLS();\r\n    });\r\n\r\n    // after intializating, start the calibration steps with garbage collection\r\n    await this.#mlsGenInterface.withGarbageCollection([\r\n      () =>\r\n        this.calibrationSteps(\r\n          stream,\r\n          this.#playCalibrationAudio, // play audio func (required)\r\n          this.#setCalibrationNodesFromBuffer, // before play func\r\n          this.#awaitSignalOnset, // before record\r\n          () => this.numSuccessfulCaptured < this.numCaptures, // loop while true\r\n          this.#awaitDesiredMLSLength, // during record\r\n          this.#afterMLSRecord // after record\r\n        ),\r\n    ]);\r\n\r\n    this.#stopCalibrationAudio();\r\n\r\n    // at this stage we've captured all the required signals,\r\n    // and have received IRs for each one\r\n    // so let's send all the IRs to the server to be converted to a single IIR\r\n    await this.sendImpulseResponsesToServerForProcessing();\r\n\r\n    // debugging function, use to test the result of the IIR\r\n    // await this.playMLSwithIIR(stream, this.invertedImpulseResponse);\r\n\r\n    return this.invertedImpulseResponse;\r\n  };\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ImpulseResponse);\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/tasks/impulse-response/impulseResponse.js?");

/***/ }),

/***/ "./src/tasks/impulse-response/mlsGen/mlsGenInterface.js":
/*!**************************************************************!*\
  !*** ./src/tasks/impulse-response/mlsGen/mlsGenInterface.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* eslint-disable prefer-destructuring */\r\n/* eslint-disable dot-notation */\r\n// eslint-disable-next-line import/extensions\r\nconst createMLSGenModule = __webpack_require__(/*! ../../../../dist/mlsGen.js */ \"./dist/mlsGen.js\");\r\n\r\n/**\r\n * MLSGenInterface provides a class for interfacing with the MLSGen WASM module.\r\n */\r\nclass MlsGenInterface {\r\n  /** @private */\r\n  #mlsOrder;\r\n\r\n  /** @private */\r\n  #WASMInstance; // the WASM module instance\r\n\r\n  /** @private */\r\n  #MLSGenInstance; // the MLSGen object instance\r\n\r\n  /**\r\n   * Creates an instance of MlsGenInterface.\r\n   * Makes a call to the WASM glue code to load the WASM module.\r\n   *\r\n   * @param WASMInstance\r\n   * @param mlsOrder\r\n   * @param sourceSamplingRate\r\n   * @param sinkSamplingRate\r\n   * @example\r\n   */\r\n  constructor(WASMInstance, mlsOrder, sourceSamplingRate, sinkSamplingRate) {\r\n    this.#mlsOrder = mlsOrder;\r\n    this.#WASMInstance = WASMInstance;\r\n\r\n    console.warn('initializing MLSGen, need to manually garbage collect');\r\n    this.#MLSGenInstance = new this.#WASMInstance['MLSGen'](\r\n      mlsOrder,\r\n      sourceSamplingRate,\r\n      sinkSamplingRate\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Factory function that provide an asynchronous function that fetches the WASM module\r\n   * and returns a promise that resolves when the module is loaded.\r\n   *\r\n   * @param mlsOrder\r\n   * @param sourceSamplingRate - The sampling rate of the source audio.\r\n   * @param sinkSamplingRate - The sampling rate of the sink audio.\r\n   * @returns MlsGenInterface.\r\n   * @example\r\n   */\r\n  static factory = async (mlsOrder, sourceSamplingRate, sinkSamplingRate) => {\r\n    if (sourceSamplingRate === undefined || sinkSamplingRate === undefined) {\r\n      throw new Error('sourceSamplingRate and sinkSamplingRate must be defined');\r\n    }\r\n    return new MlsGenInterface(\r\n      await createMLSGenModule().then(instance => instance),\r\n      mlsOrder,\r\n      sourceSamplingRate,\r\n      sinkSamplingRate\r\n    );\r\n  };\r\n\r\n  /**\r\n   * A Higher-Order function that takes an async callback function that access the MLSGen object,\r\n   * providing safe garbage collection.\r\n   *\r\n   * @param func\r\n   * @param args\r\n   * @param funcsWithParams\r\n   * @example\r\n   */\r\n  withGarbageCollection = async funcsWithParams => {\r\n    try {\r\n      for (let i = 0; i < funcsWithParams.length; i += 1) {\r\n        const funcWithParams = funcsWithParams[i];\r\n        // eslint-disable-next-line no-await-in-loop\r\n        await funcWithParams();\r\n      }\r\n    } catch (error) {\r\n      console.error(error);\r\n    } finally {\r\n      // garbage collect\r\n      if (\r\n        this !== undefined &&\r\n        this !== null &&\r\n        this.#MLSGenInstance !== undefined &&\r\n        this.#MLSGenInstance !== null\r\n      ) {\r\n        this.#MLSGenInstance['Destruct'](); // Call the destructor\r\n        this.#MLSGenInstance['delete'](); // Delete the object\r\n        console.warn(`GARBAGE COLLECTION: deleted MLSGen`);\r\n        this.#WASMInstance['doLeakCheck'](); // Check for memory leaks\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Calculate and return the Impulse Response of the recorded signal.\r\n   *\r\n   * @returns\r\n   * @example\r\n   */\r\n  getImpulseResponse = () => this.#MLSGenInstance['getImpulseResponse']();\r\n\r\n  /**\r\n   * Given a recorded MLS signal, this function sets the recordedSignal property of the MLSGen object.\r\n   *\r\n   * @param signals\r\n   * @example\r\n   */\r\n  setRecordedSignals = signals => {\r\n    // get memory view\r\n    const averagedSignals = this.average(signals);\r\n    const recordedSignalsMemoryView = this.#MLSGenInstance['setRecordedSignalsMemoryView'](\r\n      averagedSignals.byteLength\r\n    );\r\n    for (let i = 0; i < averagedSignals.length; i += 1) {\r\n      recordedSignalsMemoryView[i] = averagedSignals[i];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Calculate the Maximum Length Sequence (MLS) with period P = 2^N - 1\r\n   * using the MLSGen WASM module.\r\n   *\r\n   * @example\r\n   */\r\n  getMLS = () => this.#MLSGenInstance['getMLS']();\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (MlsGenInterface);\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/tasks/impulse-response/mlsGen/mlsGenInterface.js?");

/***/ }),

/***/ "./src/tasks/volume/volume.js":
/*!************************************!*\
  !*** ./src/tasks/volume/volume.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _audioCalibrator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../audioCalibrator */ \"./src/tasks/audioCalibrator.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ \"./src/utils.js\");\n\r\n\r\n\r\n\r\n/**\r\n *\r\n */\r\nclass Volume extends _audioCalibrator__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  /**\r\n   *\r\n   * @param root0\r\n   * @param root0.download\r\n   * @param root0.numCalibrationRounds\r\n   * @param root0.numCalibrationNodes\r\n   * @example\r\n   */\r\n\r\n  /** @private */\r\n  #CALIBRATION_TONE_FREQUENCY = 1000; // Hz\r\n\r\n  /** @private */\r\n  #CALIBRATION_TONE_TYPE = 'sine';\r\n\r\n  /** @private */\r\n  #CALIBRATION_TONE_DURATION = 5; // seconds\r\n\r\n  /** @private */\r\n  outDBSPL = null;\r\n  THD = null;\r\n  outDBSPL1000 = null;\r\n\r\n  handleIncomingData = data => {\r\n    console.log('Received data: ', data);\r\n    if (data.type === 'soundGainDBSPL') {\r\n      this.soundGainDBSPL = data.value;\r\n    } else {\r\n      throw new Error(`Unknown data type: ${data.type}`);\r\n    }\r\n  };\r\n\r\n  #getTruncatedSignal = (left = 3.5, right = 4.5) => {\r\n    const start = Math.floor(left * this.sourceSamplingRate);\r\n    const end = Math.floor(right * this.sourceSamplingRate);\r\n    const result = Array.from(this.getLastRecordedSignal().slice(start, end));\r\n\r\n    /**\r\n     * function to check that capture was properly made\r\n     * @param {*} list\r\n     */\r\n    const checkResult = list => {\r\n      const setItem = new Set(list);\r\n      if (setItem.size === 1 && setItem.has(0)) {\r\n        console.warn(\r\n          'The last capture failed, all recorded signal is zero',\r\n          this.getAllRecordedSignals()\r\n        );\r\n      }\r\n      if (setItem.size === 0) {\r\n        console.warn('The last capture failed, no recorded signal');\r\n      }\r\n    };\r\n    checkResult(result);\r\n    return result;\r\n  };\r\n\r\n  /** \r\n   * \r\n   * \r\n    Construct a calibration Node with the calibration parameters and given gain value\r\n   * @param {*} gainValue\r\n   * */\r\n  #createCalibrationToneWithGainValue = gainValue => {\r\n    const audioContext = this.makeNewSourceAudioContext();\r\n    const oscilator = audioContext.createOscillator();\r\n    const gainNode = audioContext.createGain();\r\n\r\n    oscilator.frequency.value = this.#CALIBRATION_TONE_FREQUENCY;\r\n    oscilator.type = this.#CALIBRATION_TONE_TYPE;\r\n    gainNode.gain.value = gainValue;\r\n\r\n    oscilator.connect(gainNode);\r\n    gainNode.connect(audioContext.destination);\r\n\r\n    this.addCalibrationNode(oscilator);\r\n  };\r\n\r\n  /**\r\n   * Construct a Calibration Node with the calibration parameters.\r\n   *\r\n   * @private\r\n   * @example\r\n   */\r\n  #createCalibrationNode = () => {\r\n    const audioContext = this.makeNewSourceAudioContext();\r\n    const oscilator = audioContext.createOscillator();\r\n    const gainNode = audioContext.createGain();\r\n\r\n    oscilator.frequency.value = this.#CALIBRATION_TONE_FREQUENCY;\r\n    oscilator.type = this.#CALIBRATION_TONE_TYPE;\r\n    gainNode.gain.value = 0.04;\r\n\r\n    oscilator.connect(gainNode);\r\n    gainNode.connect(audioContext.destination);\r\n\r\n    this.addCalibrationNode(oscilator);\r\n  };\r\n\r\n  #playCalibrationAudio = async () => {\r\n    const totalDuration = this.#CALIBRATION_TONE_DURATION * 1.2;\r\n\r\n    this.calibrationNodes[0].start(0);\r\n    this.calibrationNodes[0].stop(totalDuration);\r\n    console.log(`Playing a buffer of ${this.#CALIBRATION_TONE_DURATION} seconds of audio`);\r\n    console.log(`Waiting a total of ${totalDuration} seconds`);\r\n    await (0,_utils__WEBPACK_IMPORTED_MODULE_2__.sleep)(totalDuration);\r\n  };\r\n\r\n  #sendToServerForProcessing = (lCalib = 104.92978421490648) => {\r\n    console.log('Sending data to server');\r\n    this.pyServerAPI\r\n      .getVolumeCalibration({\r\n        sampleRate: this.sourceSamplingRate,\r\n        payload: this.#getTruncatedSignal(),\r\n        lCalib: lCalib,\r\n      })\r\n      .then(res => {\r\n        if (this.outDBSPL === null) {\r\n          this.outDBSPL = res['outDbSPL'];\r\n          this.outDBSPL1000 = res['outDbSPL1000'];\r\n          this.THD = res['thd'];\r\n        }\r\n      })\r\n      .catch(err => {\r\n        console.warn(err);\r\n      });\r\n  };\r\n\r\n  startCalibration = async (stream, gainValues, lCalib = 104.92978421490648) => {\r\n    const trialIterations = gainValues.length;\r\n    const thdValues = [];\r\n    const inDBValues = [];\r\n    let inDB = 0;\r\n    const outDBSPLValues = [];\r\n    const outDBSPL1000Values = [];\r\n\r\n    // do one calibration that will be discarded\r\n    const soundLevelToDiscard = -80;\r\n    const gainToDiscard = Math.pow(10, soundLevelToDiscard / 20);\r\n    this.emit('update', {message: `Sound Level: ${soundLevelToDiscard} dB`});\r\n    do {\r\n      // eslint-disable-next-line no-await-in-loop\r\n      await this.volumeCalibrationSteps(\r\n        stream,\r\n        this.#playCalibrationAudio,\r\n        this.#createCalibrationNode,\r\n        this.#sendToServerForProcessing,\r\n        gainToDiscard,\r\n        lCalib //todo make this a class parameter\r\n      );\r\n    } while (this.outDBSPL === null);\r\n    //reset the values\r\n    this.outDBSPL = null;\r\n    this.outDBSPL = null;\r\n    this.outDBSPL1000 = null;\r\n    this.THD = null;\r\n\r\n    // run the calibration at different gain values provided by the user\r\n    for (let i = 0; i < trialIterations; i++) {\r\n      //convert gain to DB and add to inDB\r\n      inDB = Math.log10(gainValues[i]) * 20;\r\n      // precision to 1 decimal place\r\n      inDB = Math.round(inDB * 10) / 10;\r\n      inDBValues.push(inDB);\r\n      this.emit('update', {message: `Sound Level: ${inDB} dB`});\r\n      do {\r\n        // eslint-disable-next-line no-await-in-loop\r\n        await this.volumeCalibrationSteps(\r\n          stream,\r\n          this.#playCalibrationAudio,\r\n          this.#createCalibrationToneWithGainValue,\r\n          this.#sendToServerForProcessing,\r\n          gainValues[i],\r\n          lCalib //todo make this a class parameter\r\n        );\r\n      } while (this.outDBSPL === null);\r\n      outDBSPL1000Values.push(this.outDBSPL1000);\r\n      thdValues.push(this.THD);\r\n      outDBSPLValues.push(this.outDBSPL);\r\n\r\n      this.outDBSPL = null;\r\n      this.outDBSPL1000 = null;\r\n      this.THD = null;\r\n    }\r\n\r\n    // get the volume calibration parameters from the server\r\n    const parameters = await this.pyServerAPI\r\n      .getVolumeCalibrationParameters({\r\n        inDBValues: inDBValues,\r\n        outDBSPLValues: outDBSPL1000Values,\r\n        lCalib: lCalib,\r\n      })\r\n      .then(res => {\r\n        return res;\r\n      });\r\n    const result = {\r\n      parameters: parameters,\r\n      inDBValues: inDBValues,\r\n      outDBSPLValues: outDBSPLValues,\r\n      outDBSPL1000Values: outDBSPL1000Values,\r\n      thdValues: thdValues,\r\n    };\r\n\r\n    return result;\r\n  };\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Volume);\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/tasks/volume/volume.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"sleep\": function() { return /* binding */ sleep; },\n/* harmony export */   \"saveToCSV\": function() { return /* binding */ saveToCSV; },\n/* harmony export */   \"csvToArray\": function() { return /* binding */ csvToArray; }\n/* harmony export */ });\n/** .\r\n * .\r\n * .\r\n * Utlity function to pause execution for a given time\r\n *\r\n * @param {number} seconds\r\n * @returns {Promise}\r\n * @example\r\n */\r\nconst sleep = seconds =>\r\n  new Promise(resolve => {\r\n    setTimeout(resolve, seconds * 1000);\r\n  });\r\n\r\n/** .\r\n * .\r\n * .\r\n * Uiltity function to create and save a CSV file from a buffer\r\n *\r\n * @param {*} data\r\n * @param {*} filename\r\n * @example\r\n */\r\nconst saveToCSV = (data, filename = 'recordedMLSignal.csv') => {\r\n  // console.log(data)\r\n  let csvContent = 'data:text/csv;charset=utf-8,';\r\n\r\n  data.forEach((val, idx) => {\r\n    csvContent += `${idx},${val}\\r\\n`;\r\n  });\r\n  const encodedUri = encodeURI(csvContent);\r\n  const link = document.createElement('a');\r\n  link.setAttribute('href', encodedUri);\r\n  link.setAttribute('download', filename);\r\n  document.body.appendChild(link);\r\n  link.click();\r\n};\r\n\r\n/** .\r\n * .\r\n * .\r\n * Utility function to create a buffer from a CSV file\r\n *\r\n * @param {*} csvString\r\n * @param {*} delimiter\r\n * @returns\r\n * @example\r\n */\r\nconst csvToArray = (csvString, delimiter = ',') =>\r\n  csvString\r\n    .trim()\r\n    .split('\\n')\r\n    .map(row => parseFloat(row.trim().split(delimiter)[1]));\r\n\r\n\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});