/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["speakerCalibrator"] = factory();
	else
		root["speakerCalibrator"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/mlsGen.js":
/*!************************!*\
  !*** ./dist/mlsGen.js ***!
  \************************/
/***/ ((module) => {

eval("\nvar createMLSGenModule = (() => {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  \n  return (\nfunction(createMLSGenModule) {\n  createMLSGenModule = createMLSGenModule || {};\n\nvar Module = typeof createMLSGenModule !== \"undefined\" ? createMLSGenModule : {};\n\nvar readyPromiseResolve, readyPromiseReject;\n\nModule[\"ready\"] = new Promise(function(resolve, reject) {\n readyPromiseResolve = resolve;\n readyPromiseReject = reject;\n});\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"_main\")) {\n Object.defineProperty(Module[\"ready\"], \"_main\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting _main on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"_main\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting _main on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"___getTypeName\")) {\n Object.defineProperty(Module[\"ready\"], \"___getTypeName\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting ___getTypeName on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"___getTypeName\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting ___getTypeName on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"___embind_register_native_and_builtin_types\")) {\n Object.defineProperty(Module[\"ready\"], \"___embind_register_native_and_builtin_types\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting ___embind_register_native_and_builtin_types on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"___embind_register_native_and_builtin_types\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting ___embind_register_native_and_builtin_types on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"___stdio_exit\")) {\n Object.defineProperty(Module[\"ready\"], \"___stdio_exit\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting ___stdio_exit on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"___stdio_exit\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting ___stdio_exit on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"__ZN6__asan9FakeStack17AddrIsInFakeStackEm\")) {\n Object.defineProperty(Module[\"ready\"], \"__ZN6__asan9FakeStack17AddrIsInFakeStackEm\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting __ZN6__asan9FakeStack17AddrIsInFakeStackEm on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"__ZN6__asan9FakeStack17AddrIsInFakeStackEm\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting __ZN6__asan9FakeStack17AddrIsInFakeStackEm on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"__ZN6__asan9FakeStack8AllocateEmmm\")) {\n Object.defineProperty(Module[\"ready\"], \"__ZN6__asan9FakeStack8AllocateEmmm\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting __ZN6__asan9FakeStack8AllocateEmmm on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"__ZN6__asan9FakeStack8AllocateEmmm\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting __ZN6__asan9FakeStack8AllocateEmmm on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module[\"ready\"], \"onRuntimeInitialized\")) {\n Object.defineProperty(Module[\"ready\"], \"onRuntimeInitialized\", {\n  configurable: true,\n  get: function() {\n   abort(\"You are getting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n Object.defineProperty(Module[\"ready\"], \"onRuntimeInitialized\", {\n  configurable: true,\n  set: function() {\n   abort(\"You are setting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\");\n  }\n });\n}\n\nvar moduleOverrides = Object.assign({}, Module);\n\nvar arguments_ = [];\n\nvar thisProgram = \"./this.program\";\n\nvar quit_ = (status, toThrow) => {\n throw toThrow;\n};\n\nvar ENVIRONMENT_IS_WEB = true;\n\nvar ENVIRONMENT_IS_WORKER = false;\n\nvar ENVIRONMENT_IS_NODE = false;\n\nvar ENVIRONMENT_IS_SHELL = false;\n\nif (Module[\"ENVIRONMENT\"]) {\n throw new Error(\"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)\");\n}\n\nvar scriptDirectory = \"\";\n\nfunction locateFile(path) {\n if (Module[\"locateFile\"]) {\n  return Module[\"locateFile\"](path, scriptDirectory);\n }\n return scriptDirectory + path;\n}\n\nvar read_, readAsync, readBinary, setWindowTitle;\n\nfunction logExceptionOnExit(e) {\n if (e instanceof ExitStatus) return;\n let toLog = e;\n if (e && typeof e === \"object\" && e.stack) {\n  toLog = [ e, e.stack ];\n }\n err(\"exiting due to exception: \" + toLog);\n}\n\nif (ENVIRONMENT_IS_SHELL) {\n if (typeof process === \"object\" && \"function\" === \"function\" || typeof window === \"object\" || typeof importScripts === \"function\") throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n if (typeof read != \"undefined\") {\n  read_ = function shell_read(f) {\n   return read(f);\n  };\n }\n readBinary = function readBinary(f) {\n  let data;\n  if (typeof readbuffer === \"function\") {\n   return new Uint8Array(readbuffer(f));\n  }\n  data = read(f, \"binary\");\n  assert(typeof data === \"object\");\n  return data;\n };\n readAsync = function readAsync(f, onload, onerror) {\n  setTimeout(() => onload(readBinary(f)), 0);\n };\n if (typeof scriptArgs != \"undefined\") {\n  arguments_ = scriptArgs;\n } else if (typeof arguments != \"undefined\") {\n  arguments_ = arguments;\n }\n if (typeof quit === \"function\") {\n  quit_ = ((status, toThrow) => {\n   logExceptionOnExit(toThrow);\n   quit(status);\n  });\n }\n if (typeof print !== \"undefined\") {\n  if (typeof console === \"undefined\") console = {};\n  console.log = print;\n  console.warn = console.error = typeof printErr !== \"undefined\" ? printErr : print;\n }\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n if (ENVIRONMENT_IS_WORKER) {\n  scriptDirectory = self.location.href;\n } else if (typeof document !== \"undefined\" && document.currentScript) {\n  scriptDirectory = document.currentScript.src;\n }\n if (_scriptDir) {\n  scriptDirectory = _scriptDir;\n }\n if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n } else {\n  scriptDirectory = \"\";\n }\n if (!(typeof window === \"object\" || typeof importScripts === \"function\")) throw new Error(\"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\");\n {\n  read_ = (url => {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"GET\", url, false);\n   xhr.send(null);\n   return xhr.responseText;\n  });\n  if (ENVIRONMENT_IS_WORKER) {\n   readBinary = (url => {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n    xhr.responseType = \"arraybuffer\";\n    xhr.send(null);\n    return new Uint8Array(xhr.response);\n   });\n  }\n  readAsync = ((url, onload, onerror) => {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"GET\", url, true);\n   xhr.responseType = \"arraybuffer\";\n   xhr.onload = (() => {\n    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n     onload(xhr.response);\n     return;\n    }\n    onerror();\n   });\n   xhr.onerror = onerror;\n   xhr.send(null);\n  });\n }\n setWindowTitle = (title => document.title = title);\n} else {\n throw new Error(\"environment detection error\");\n}\n\nvar out = Module[\"print\"] || console.log.bind(console);\n\nvar err = Module[\"printErr\"] || console.warn.bind(console);\n\nObject.assign(Module, moduleOverrides);\n\nmoduleOverrides = null;\n\nif (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n\nif (!Object.getOwnPropertyDescriptor(Module, \"arguments\")) {\n Object.defineProperty(Module, \"arguments\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.arguments has been replaced with plain arguments_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n\nif (!Object.getOwnPropertyDescriptor(Module, \"thisProgram\")) {\n Object.defineProperty(Module, \"thisProgram\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.thisProgram has been replaced with plain thisProgram (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (Module[\"quit\"]) quit_ = Module[\"quit\"];\n\nif (!Object.getOwnPropertyDescriptor(Module, \"quit\")) {\n Object.defineProperty(Module, \"quit\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.quit has been replaced with plain quit_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nassert(typeof Module[\"memoryInitializerPrefixURL\"] === \"undefined\", \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"pthreadMainPrefixURL\"] === \"undefined\", \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"cdInitializerPrefixURL\"] === \"undefined\", \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"filePackagePrefixURL\"] === \"undefined\", \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\");\n\nassert(typeof Module[\"read\"] === \"undefined\", \"Module.read option was removed (modify read_ in JS)\");\n\nassert(typeof Module[\"readAsync\"] === \"undefined\", \"Module.readAsync option was removed (modify readAsync in JS)\");\n\nassert(typeof Module[\"readBinary\"] === \"undefined\", \"Module.readBinary option was removed (modify readBinary in JS)\");\n\nassert(typeof Module[\"setWindowTitle\"] === \"undefined\", \"Module.setWindowTitle option was removed (modify setWindowTitle in JS)\");\n\nassert(typeof Module[\"TOTAL_MEMORY\"] === \"undefined\", \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\");\n\nif (!Object.getOwnPropertyDescriptor(Module, \"read\")) {\n Object.defineProperty(Module, \"read\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.read has been replaced with plain read_ (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readAsync\")) {\n Object.defineProperty(Module, \"readAsync\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.readAsync has been replaced with plain readAsync (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readBinary\")) {\n Object.defineProperty(Module, \"readBinary\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.readBinary has been replaced with plain readBinary (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setWindowTitle\")) {\n Object.defineProperty(Module, \"setWindowTitle\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.setWindowTitle has been replaced with plain setWindowTitle (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nassert(!ENVIRONMENT_IS_WORKER, \"worker environment detected but not enabled at build time.  Add 'worker' to `-s ENVIRONMENT` to enable.\");\n\nassert(!ENVIRONMENT_IS_NODE, \"node environment detected but not enabled at build time.  Add 'node' to `-s ENVIRONMENT` to enable.\");\n\nassert(!ENVIRONMENT_IS_SHELL, \"shell environment detected but not enabled at build time.  Add 'shell' to `-s ENVIRONMENT` to enable.\");\n\nvar POINTER_SIZE = 4;\n\nfunction warnOnce(text) {\n if (!warnOnce.shown) warnOnce.shown = {};\n if (!warnOnce.shown[text]) {\n  warnOnce.shown[text] = 1;\n  err(text);\n }\n}\n\nfunction convertJsFunctionToWasm(func, sig) {\n if (typeof WebAssembly.Function === \"function\") {\n  var typeNames = {\n   \"i\": \"i32\",\n   \"j\": \"i64\",\n   \"f\": \"f32\",\n   \"d\": \"f64\"\n  };\n  var type = {\n   parameters: [],\n   results: sig[0] == \"v\" ? [] : [ typeNames[sig[0]] ]\n  };\n  for (var i = 1; i < sig.length; ++i) {\n   type.parameters.push(typeNames[sig[i]]);\n  }\n  return new WebAssembly.Function(type, func);\n }\n var typeSection = [ 1, 0, 1, 96 ];\n var sigRet = sig.slice(0, 1);\n var sigParam = sig.slice(1);\n var typeCodes = {\n  \"i\": 127,\n  \"j\": 126,\n  \"f\": 125,\n  \"d\": 124\n };\n typeSection.push(sigParam.length);\n for (var i = 0; i < sigParam.length; ++i) {\n  typeSection.push(typeCodes[sigParam[i]]);\n }\n if (sigRet == \"v\") {\n  typeSection.push(0);\n } else {\n  typeSection = typeSection.concat([ 1, typeCodes[sigRet] ]);\n }\n typeSection[1] = typeSection.length - 2;\n var bytes = new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0 ].concat(typeSection, [ 2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0 ]));\n var module = new WebAssembly.Module(bytes);\n var instance = new WebAssembly.Instance(module, {\n  \"e\": {\n   \"f\": func\n  }\n });\n var wrappedFunc = instance.exports[\"f\"];\n return wrappedFunc;\n}\n\nvar freeTableIndexes = [];\n\nvar functionsInTableMap;\n\nfunction getEmptyTableSlot() {\n if (freeTableIndexes.length) {\n  return freeTableIndexes.pop();\n }\n try {\n  wasmTable.grow(1);\n } catch (err) {\n  if (!(err instanceof RangeError)) {\n   throw err;\n  }\n  throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\n }\n return wasmTable.length - 1;\n}\n\nfunction updateTableMap(offset, count) {\n for (var i = offset; i < offset + count; i++) {\n  var item = getWasmTableEntry(i);\n  if (item) {\n   functionsInTableMap.set(item, i);\n  }\n }\n}\n\nvar tempRet0 = 0;\n\nvar setTempRet0 = value => {\n tempRet0 = value;\n};\n\nvar wasmBinary;\n\nif (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n\nif (!Object.getOwnPropertyDescriptor(Module, \"wasmBinary\")) {\n Object.defineProperty(Module, \"wasmBinary\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.wasmBinary has been replaced with plain wasmBinary (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nvar noExitRuntime = Module[\"noExitRuntime\"] || false;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"noExitRuntime\")) {\n Object.defineProperty(Module, \"noExitRuntime\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.noExitRuntime has been replaced with plain noExitRuntime (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nif (typeof WebAssembly !== \"object\") {\n abort(\"no native wasm support detected\");\n}\n\nfunction _asan_js_load_1(ptr) {\n if (runtimeInitialized) return _asan_c_load_1(ptr);\n return HEAP8[ptr];\n}\n\nfunction _asan_js_load_1u(ptr) {\n if (runtimeInitialized) return _asan_c_load_1u(ptr);\n return HEAPU8[ptr];\n}\n\nfunction _asan_js_load_2(ptr) {\n if (runtimeInitialized) return _asan_c_load_2(ptr);\n return HEAP16[ptr];\n}\n\nfunction _asan_js_load_2u(ptr) {\n if (runtimeInitialized) return _asan_c_load_2u(ptr);\n return HEAPU16[ptr];\n}\n\nfunction _asan_js_load_4(ptr) {\n if (runtimeInitialized) return _asan_c_load_4(ptr);\n return HEAP32[ptr];\n}\n\nfunction _asan_js_load_4u(ptr) {\n if (runtimeInitialized) return _asan_c_load_4u(ptr) >>> 0;\n return HEAPU32[ptr];\n}\n\nfunction _asan_js_load_f(ptr) {\n if (runtimeInitialized) return _asan_c_load_f(ptr);\n return HEAPF32[ptr];\n}\n\nfunction _asan_js_load_d(ptr) {\n if (runtimeInitialized) return _asan_c_load_d(ptr);\n return HEAPF64[ptr];\n}\n\nfunction _asan_js_store_1(ptr, val) {\n if (runtimeInitialized) return _asan_c_store_1(ptr, val);\n return HEAP8[ptr] = val;\n}\n\nfunction _asan_js_store_1u(ptr, val) {\n if (runtimeInitialized) return _asan_c_store_1u(ptr, val);\n return HEAPU8[ptr] = val;\n}\n\nfunction _asan_js_store_2(ptr, val) {\n if (runtimeInitialized) return _asan_c_store_2(ptr, val);\n return HEAP16[ptr] = val;\n}\n\nfunction _asan_js_store_4(ptr, val) {\n if (runtimeInitialized) return _asan_c_store_4(ptr, val);\n return HEAP32[ptr] = val;\n}\n\nfunction _asan_js_store_4u(ptr, val) {\n if (runtimeInitialized) return _asan_c_store_4u(ptr, val) >>> 0;\n return HEAPU32[ptr] = val;\n}\n\nfunction _asan_js_store_f(ptr, val) {\n if (runtimeInitialized) return _asan_c_store_f(ptr, val);\n return HEAPF32[ptr] = val;\n}\n\nfunction _asan_js_store_d(ptr, val) {\n if (runtimeInitialized) return _asan_c_store_d(ptr, val);\n return HEAPF64[ptr] = val;\n}\n\nvar wasmMemory;\n\nvar ABORT = false;\n\nvar EXITSTATUS;\n\nfunction assert(condition, text) {\n if (!condition) {\n  abort(\"Assertion failed\" + (text ? \": \" + text : \"\"));\n }\n}\n\nfunction getCFunc(ident) {\n var func = Module[\"_\" + ident];\n assert(func, \"Cannot call unknown function \" + ident + \", make sure it is exported\");\n return func;\n}\n\nfunction ccall(ident, returnType, argTypes, args, opts) {\n var toC = {\n  \"string\": function(str) {\n   var ret = 0;\n   if (str !== null && str !== undefined && str !== 0) {\n    var len = (str.length << 2) + 1;\n    ret = stackAlloc(len);\n    stringToUTF8(str, ret, len);\n   }\n   return ret;\n  },\n  \"array\": function(arr) {\n   var ret = stackAlloc(arr.length);\n   writeArrayToMemory(arr, ret);\n   return ret;\n  }\n };\n function convertReturnValue(ret) {\n  if (returnType === \"string\") return UTF8ToString(ret);\n  if (returnType === \"boolean\") return Boolean(ret);\n  return ret;\n }\n var func = getCFunc(ident);\n var cArgs = [];\n var stack = 0;\n assert(returnType !== \"array\", 'Return type should not be \"array\".');\n if (args) {\n  for (var i = 0; i < args.length; i++) {\n   var converter = toC[argTypes[i]];\n   if (converter) {\n    if (stack === 0) stack = stackSave();\n    cArgs[i] = converter(args[i]);\n   } else {\n    cArgs[i] = args[i];\n   }\n  }\n }\n var ret = func.apply(null, cArgs);\n function onDone(ret) {\n  if (stack !== 0) stackRestore(stack);\n  return convertReturnValue(ret);\n }\n ret = onDone(ret);\n return ret;\n}\n\nvar ALLOC_STACK = 1;\n\nvar UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\nfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\n var endIdx = idx + maxBytesToRead;\n var endPtr = idx;\n while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n  return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n } else {\n  var str = \"\";\n  while (idx < endPtr) {\n   var u0 = heap[idx++];\n   if (!(u0 & 128)) {\n    str += String.fromCharCode(u0);\n    continue;\n   }\n   var u1 = heap[idx++] & 63;\n   if ((u0 & 224) == 192) {\n    str += String.fromCharCode((u0 & 31) << 6 | u1);\n    continue;\n   }\n   var u2 = heap[idx++] & 63;\n   if ((u0 & 240) == 224) {\n    u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n   } else {\n    if ((u0 & 248) != 240) warnOnce(\"Invalid UTF-8 leading byte 0x\" + u0.toString(16) + \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\");\n    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\n   }\n   if (u0 < 65536) {\n    str += String.fromCharCode(u0);\n   } else {\n    var ch = u0 - 65536;\n    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n   }\n  }\n }\n return str;\n}\n\nfunction UTF8ToString(ptr, maxBytesToRead) {\n return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n}\n\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n if (!(maxBytesToWrite > 0)) return 0;\n var startIdx = outIdx;\n var endIdx = outIdx + maxBytesToWrite - 1;\n for (var i = 0; i < str.length; ++i) {\n  var u = str.charCodeAt(i);\n  if (u >= 55296 && u <= 57343) {\n   var u1 = str.charCodeAt(++i);\n   u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n  }\n  if (u <= 127) {\n   if (outIdx >= endIdx) break;\n   heap[outIdx++] = u;\n  } else if (u <= 2047) {\n   if (outIdx + 1 >= endIdx) break;\n   heap[outIdx++] = 192 | u >> 6;\n   heap[outIdx++] = 128 | u & 63;\n  } else if (u <= 65535) {\n   if (outIdx + 2 >= endIdx) break;\n   heap[outIdx++] = 224 | u >> 12;\n   heap[outIdx++] = 128 | u >> 6 & 63;\n   heap[outIdx++] = 128 | u & 63;\n  } else {\n   if (outIdx + 3 >= endIdx) break;\n   if (u > 1114111) warnOnce(\"Invalid Unicode code point 0x\" + u.toString(16) + \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\");\n   heap[outIdx++] = 240 | u >> 18;\n   heap[outIdx++] = 128 | u >> 12 & 63;\n   heap[outIdx++] = 128 | u >> 6 & 63;\n   heap[outIdx++] = 128 | u & 63;\n  }\n }\n heap[outIdx] = 0;\n return outIdx - startIdx;\n}\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n}\n\nfunction lengthBytesUTF8(str) {\n var len = 0;\n for (var i = 0; i < str.length; ++i) {\n  var u = str.charCodeAt(i);\n  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n  if (u <= 127) ++len; else if (u <= 2047) len += 2; else if (u <= 65535) len += 3; else len += 4;\n }\n return len;\n}\n\nvar UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n\nfunction UTF16ToString(ptr, maxBytesToRead) {\n assert(ptr % 2 == 0, \"Pointer passed to UTF16ToString must be aligned to two bytes!\");\n var endPtr = ptr;\n var idx = endPtr >> 1;\n var maxIdx = idx + maxBytesToRead / 2;\n while (!(idx >= maxIdx) && _asan_js_load_2u(idx)) ++idx;\n endPtr = idx << 1;\n if (endPtr - ptr > 32 && UTF16Decoder) {\n  return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n } else {\n  var str = \"\";\n  for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n   var codeUnit = _asan_js_load_2(ptr + i * 2 >> 1);\n   if (codeUnit == 0) break;\n   str += String.fromCharCode(codeUnit);\n  }\n  return str;\n }\n}\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n assert(outPtr % 2 == 0, \"Pointer passed to stringToUTF16 must be aligned to two bytes!\");\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n if (maxBytesToWrite === undefined) {\n  maxBytesToWrite = 2147483647;\n }\n if (maxBytesToWrite < 2) return 0;\n maxBytesToWrite -= 2;\n var startPtr = outPtr;\n var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n for (var i = 0; i < numCharsToWrite; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  _asan_js_store_2(outPtr >> 1, codeUnit);\n  outPtr += 2;\n }\n _asan_js_store_2(outPtr >> 1, 0);\n return outPtr - startPtr;\n}\n\nfunction lengthBytesUTF16(str) {\n return str.length * 2;\n}\n\nfunction UTF32ToString(ptr, maxBytesToRead) {\n assert(ptr % 4 == 0, \"Pointer passed to UTF32ToString must be aligned to four bytes!\");\n var i = 0;\n var str = \"\";\n while (!(i >= maxBytesToRead / 4)) {\n  var utf32 = _asan_js_load_4(ptr + i * 4 >> 2);\n  if (utf32 == 0) break;\n  ++i;\n  if (utf32 >= 65536) {\n   var ch = utf32 - 65536;\n   str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n  } else {\n   str += String.fromCharCode(utf32);\n  }\n }\n return str;\n}\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n assert(outPtr % 4 == 0, \"Pointer passed to stringToUTF32 must be aligned to four bytes!\");\n assert(typeof maxBytesToWrite == \"number\", \"stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\");\n if (maxBytesToWrite === undefined) {\n  maxBytesToWrite = 2147483647;\n }\n if (maxBytesToWrite < 4) return 0;\n var startPtr = outPtr;\n var endPtr = startPtr + maxBytesToWrite - 4;\n for (var i = 0; i < str.length; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  if (codeUnit >= 55296 && codeUnit <= 57343) {\n   var trailSurrogate = str.charCodeAt(++i);\n   codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n  }\n  _asan_js_store_4(outPtr >> 2, codeUnit);\n  outPtr += 4;\n  if (outPtr + 4 > endPtr) break;\n }\n _asan_js_store_4(outPtr >> 2, 0);\n return outPtr - startPtr;\n}\n\nfunction lengthBytesUTF32(str) {\n var len = 0;\n for (var i = 0; i < str.length; ++i) {\n  var codeUnit = str.charCodeAt(i);\n  if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n  len += 4;\n }\n return len;\n}\n\nfunction allocateUTF8(str) {\n var size = lengthBytesUTF8(str) + 1;\n var ret = _malloc(size);\n if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n return ret;\n}\n\nfunction writeArrayToMemory(array, buffer) {\n assert(array.length >= 0, \"writeArrayToMemory array must have a length (should be an array or typed array)\");\n HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n for (var i = 0; i < str.length; ++i) {\n  assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));\n  _asan_js_store_1(buffer++ >> 0, str.charCodeAt(i));\n }\n if (!dontAddNull) _asan_js_store_1(buffer >> 0, 0);\n}\n\nvar buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n buffer = buf;\n Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n}\n\nvar TOTAL_STACK = 5242880;\n\nif (Module[\"TOTAL_STACK\"]) assert(TOTAL_STACK === Module[\"TOTAL_STACK\"], \"the stack size can no longer be determined at runtime\");\n\nvar INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 79101952;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"INITIAL_MEMORY\")) {\n Object.defineProperty(Module, \"INITIAL_MEMORY\", {\n  configurable: true,\n  get: function() {\n   abort(\"Module.INITIAL_MEMORY has been replaced with plain INITIAL_MEMORY (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\");\n  }\n });\n}\n\nassert(INITIAL_MEMORY >= TOTAL_STACK, \"INITIAL_MEMORY should be larger than TOTAL_STACK, was \" + INITIAL_MEMORY + \"! (TOTAL_STACK=\" + TOTAL_STACK + \")\");\n\nassert(typeof Int32Array !== \"undefined\" && typeof Float64Array !== \"undefined\" && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, \"JS engine does not provide full typed array support\");\n\nassert(!Module[\"wasmMemory\"], \"Use of `wasmMemory` detected.  Use -s IMPORTED_MEMORY to define wasmMemory externally\");\n\nassert(INITIAL_MEMORY == 79101952, \"Detected runtime INITIAL_MEMORY setting.  Use -s IMPORTED_MEMORY to define wasmMemory dynamically\");\n\nvar wasmTable;\n\nfunction writeStackCookie() {\n var max = _emscripten_stack_get_end();\n assert((max & 3) == 0);\n _asan_js_store_4(max + 4 >> 2, 34821223);\n _asan_js_store_4(max + 8 >> 2, 2310721022);\n}\n\nfunction checkStackCookie() {\n if (ABORT) return;\n var max = _emscripten_stack_get_end();\n var cookie1 = _asan_js_load_4u(max + 4 >> 2);\n var cookie2 = _asan_js_load_4u(max + 8 >> 2);\n if (cookie1 != 34821223 || cookie2 != 2310721022) {\n  abort(\"Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x\" + cookie2.toString(16) + \" 0x\" + cookie1.toString(16));\n }\n}\n\n(function() {\n var h16 = new Int16Array(1);\n var h8 = new Int8Array(h16.buffer);\n h16[0] = 25459;\n if (h8[0] !== 115 || h8[1] !== 99) throw \"Runtime error: expected the system to be little-endian! (Run with -s SUPPORT_BIG_ENDIAN=1 to bypass)\";\n})();\n\nvar __ATPRERUN__ = [];\n\nvar __ATINIT__ = [];\n\nvar __ATEXIT__ = [];\n\nvar __ATPOSTRUN__ = [];\n\nvar runtimeInitialized = false;\n\nvar runtimeExited = false;\n\nvar runtimeKeepaliveCounter = 0;\n\nfunction keepRuntimeAlive() {\n return noExitRuntime || runtimeKeepaliveCounter > 0;\n}\n\nfunction preRun() {\n if (Module[\"preRun\"]) {\n  if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [ Module[\"preRun\"] ];\n  while (Module[\"preRun\"].length) {\n   addOnPreRun(Module[\"preRun\"].shift());\n  }\n }\n callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n checkStackCookie();\n assert(!runtimeInitialized);\n runtimeInitialized = true;\n if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n FS.ignorePermissions = false;\n TTY.init();\n callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction exitRuntime() {\n checkStackCookie();\n ___funcs_on_exit();\n callRuntimeCallbacks(__ATEXIT__);\n FS.quit();\n TTY.shutdown();\n runtimeExited = true;\n}\n\nfunction postRun() {\n checkStackCookie();\n if (Module[\"postRun\"]) {\n  if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [ Module[\"postRun\"] ];\n  while (Module[\"postRun\"].length) {\n   addOnPostRun(Module[\"postRun\"].shift());\n  }\n }\n callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n __ATINIT__.unshift(cb);\n}\n\nfunction addOnPostRun(cb) {\n __ATPOSTRUN__.unshift(cb);\n}\n\nassert(Math.imul, \"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nassert(Math.fround, \"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nassert(Math.clz32, \"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nassert(Math.trunc, \"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\");\n\nvar runDependencies = 0;\n\nvar runDependencyWatcher = null;\n\nvar dependenciesFulfilled = null;\n\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n var orig = id;\n while (1) {\n  if (!runDependencyTracking[id]) return id;\n  id = orig + Math.random();\n }\n}\n\nfunction addRunDependency(id) {\n runDependencies++;\n if (Module[\"monitorRunDependencies\"]) {\n  Module[\"monitorRunDependencies\"](runDependencies);\n }\n if (id) {\n  assert(!runDependencyTracking[id]);\n  runDependencyTracking[id] = 1;\n  if (runDependencyWatcher === null && typeof setInterval !== \"undefined\") {\n   runDependencyWatcher = setInterval(function() {\n    if (ABORT) {\n     clearInterval(runDependencyWatcher);\n     runDependencyWatcher = null;\n     return;\n    }\n    var shown = false;\n    for (var dep in runDependencyTracking) {\n     if (!shown) {\n      shown = true;\n      err(\"still waiting on run dependencies:\");\n     }\n     err(\"dependency: \" + dep);\n    }\n    if (shown) {\n     err(\"(end of list)\");\n    }\n   }, 1e4);\n  }\n } else {\n  err(\"warning: run dependency added without ID\");\n }\n}\n\nfunction removeRunDependency(id) {\n runDependencies--;\n if (Module[\"monitorRunDependencies\"]) {\n  Module[\"monitorRunDependencies\"](runDependencies);\n }\n if (id) {\n  assert(runDependencyTracking[id]);\n  delete runDependencyTracking[id];\n } else {\n  err(\"warning: run dependency removed without ID\");\n }\n if (runDependencies == 0) {\n  if (runDependencyWatcher !== null) {\n   clearInterval(runDependencyWatcher);\n   runDependencyWatcher = null;\n  }\n  if (dependenciesFulfilled) {\n   var callback = dependenciesFulfilled;\n   dependenciesFulfilled = null;\n   callback();\n  }\n }\n}\n\nModule[\"preloadedImages\"] = {};\n\nModule[\"preloadedAudios\"] = {};\n\nfunction abort(what) {\n {\n  if (Module[\"onAbort\"]) {\n   Module[\"onAbort\"](what);\n  }\n }\n what = \"Aborted(\" + what + \")\";\n err(what);\n ABORT = true;\n EXITSTATUS = 1;\n var e = new WebAssembly.RuntimeError(what);\n readyPromiseReject(e);\n throw e;\n}\n\nvar dataURIPrefix = \"data:application/octet-stream;base64,\";\n\nfunction isDataURI(filename) {\n return filename.startsWith(dataURIPrefix);\n}\n\nfunction isFileURI(filename) {\n return filename.startsWith(\"file://\");\n}\n\nfunction createExportWrapper(name, fixedasm) {\n return function() {\n  var displayName = name;\n  var asm = fixedasm;\n  if (!fixedasm) {\n   asm = Module[\"asm\"];\n  }\n  assert(runtimeInitialized, \"native function `\" + displayName + \"` called before runtime initialization\");\n  assert(!runtimeExited, \"native function `\" + displayName + \"` called after runtime exit (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");\n  if (!asm[name]) {\n   assert(asm[name], \"exported native function `\" + displayName + \"` not found\");\n  }\n  return asm[name].apply(null, arguments);\n };\n}\n\nvar wasmBinaryFile;\n\nwasmBinaryFile = \"mlsGen.wasm\";\n\nif (!isDataURI(wasmBinaryFile)) {\n wasmBinaryFile = locateFile(wasmBinaryFile);\n}\n\nfunction getBinary(file) {\n try {\n  if (file == wasmBinaryFile && wasmBinary) {\n   return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n   return readBinary(file);\n  } else {\n   throw \"both async and sync fetching of the wasm failed\";\n  }\n } catch (err) {\n  abort(err);\n }\n}\n\nfunction getBinaryPromise() {\n if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n  if (typeof fetch === \"function\") {\n   return fetch(wasmBinaryFile, {\n    credentials: \"same-origin\"\n   }).then(function(response) {\n    if (!response[\"ok\"]) {\n     throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n    }\n    return response[\"arrayBuffer\"]();\n   }).catch(function() {\n    return getBinary(wasmBinaryFile);\n   });\n  }\n }\n return Promise.resolve().then(function() {\n  return getBinary(wasmBinaryFile);\n });\n}\n\nvar wasmOffsetConverter;\n\nfunction WasmOffsetConverter(wasmBytes, wasmModule) {\n var offset = 8;\n var funcidx = 0;\n this.offset_map = {};\n this.func_starts = [];\n this.name_map = {};\n this.import_functions = 0;\n var buffer = wasmBytes;\n function unsignedLEB128() {\n  var result = 0;\n  var shift = 0;\n  do {\n   var byte = buffer[offset++];\n   result += (byte & 127) << shift;\n   shift += 7;\n  } while (byte & 128);\n  return result;\n }\n function skipLimits() {\n  var flags = unsignedLEB128();\n  unsignedLEB128();\n  var hasMax = (flags & 1) != 0;\n  if (hasMax) {\n   unsignedLEB128();\n  }\n }\n binary_parse: while (offset < buffer.length) {\n  var type = buffer[offset++];\n  var end = unsignedLEB128() + offset;\n  switch (type) {\n  case 2:\n   var count = unsignedLEB128();\n   while (count-- > 0) {\n    offset = unsignedLEB128() + offset;\n    offset = unsignedLEB128() + offset;\n    switch (buffer[offset++]) {\n    case 0:\n     ++funcidx;\n     unsignedLEB128();\n     break;\n\n    case 1:\n     ++offset;\n     skipLimits();\n     break;\n\n    case 2:\n     skipLimits();\n     break;\n\n    case 3:\n     offset += 2;\n     break;\n\n    default:\n     throw \"bad import kind\";\n    }\n   }\n   this.import_functions = funcidx;\n   break;\n\n  case 10:\n   var count = unsignedLEB128();\n   while (count-- > 0) {\n    var size = unsignedLEB128();\n    this.offset_map[funcidx++] = offset;\n    this.func_starts.push(offset);\n    offset += size;\n   }\n   break binary_parse;\n  }\n  offset = end;\n }\n var sections = WebAssembly.Module.customSections(wasmModule, \"name\");\n for (var i = 0; i < sections.length; ++i) {\n  buffer = new Uint8Array(sections[i]);\n  if (buffer[0] != 1) continue;\n  offset = 1;\n  unsignedLEB128();\n  var count = unsignedLEB128();\n  while (count-- > 0) {\n   var index = unsignedLEB128();\n   var length = unsignedLEB128();\n   this.name_map[index] = UTF8ArrayToString(buffer, offset, length);\n   offset += length;\n  }\n }\n}\n\nWasmOffsetConverter.prototype.convert = function(funcidx, offset) {\n return this.offset_map[funcidx] + offset;\n};\n\nWasmOffsetConverter.prototype.getIndex = function(offset) {\n var lo = 0;\n var hi = this.func_starts.length;\n var mid;\n while (lo < hi) {\n  mid = Math.floor((lo + hi) / 2);\n  if (this.func_starts[mid] > offset) {\n   hi = mid;\n  } else {\n   lo = mid + 1;\n  }\n }\n return lo + this.import_functions - 1;\n};\n\nWasmOffsetConverter.prototype.isSameFunc = function(offset1, offset2) {\n return this.getIndex(offset1) == this.getIndex(offset2);\n};\n\nWasmOffsetConverter.prototype.getName = function(offset) {\n var index = this.getIndex(offset);\n return this.name_map[index] || \"wasm-function[\" + index + \"]\";\n};\n\nfunction resetPrototype(constructor, attrs) {\n var object = Object.create(constructor.prototype);\n return Object.assign(object, attrs);\n}\n\nfunction createWasm() {\n var info = {\n  \"env\": asmLibraryArg,\n  \"wasi_snapshot_preview1\": asmLibraryArg\n };\n function receiveInstance(instance, module) {\n  var exports = instance.exports;\n  Module[\"asm\"] = exports;\n  wasmMemory = Module[\"asm\"][\"memory\"];\n  assert(wasmMemory, \"memory not found in wasm exports\");\n  updateGlobalBufferAndViews(wasmMemory.buffer);\n  wasmTable = Module[\"asm\"][\"__indirect_function_table\"];\n  assert(wasmTable, \"table not found in wasm exports\");\n  addOnInit(Module[\"asm\"][\"__wasm_call_ctors\"]);\n  removeRunDependency(\"wasm-instantiate\");\n }\n addRunDependency(\"wasm-instantiate\");\n var trueModule = Module;\n function receiveInstantiationResult(result) {\n  assert(Module === trueModule, \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\");\n  trueModule = null;\n  receiveInstance(result[\"instance\"]);\n }\n function instantiateArrayBuffer(receiver) {\n  var savedBinary;\n  return getBinaryPromise().then(function(binary) {\n   savedBinary = binary;\n   return WebAssembly.instantiate(binary, info);\n  }).then(function(instance) {\n   wasmOffsetConverter = new WasmOffsetConverter(savedBinary, instance.module);\n   return instance;\n  }).then(receiver, function(reason) {\n   err(\"failed to asynchronously prepare wasm: \" + reason);\n   if (isFileURI(wasmBinaryFile)) {\n    err(\"warning: Loading from a file URI (\" + wasmBinaryFile + \") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing\");\n   }\n   abort(reason);\n  });\n }\n function instantiateAsync() {\n  if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && typeof fetch === \"function\") {\n   return fetch(wasmBinaryFile, {\n    credentials: \"same-origin\"\n   }).then(function(response) {\n    var result = WebAssembly.instantiateStreaming(response, info);\n    var clonedResponsePromise = response.clone().arrayBuffer();\n    return result.then(function(instantiationResult) {\n     clonedResponsePromise.then(function(arrayBufferResult) {\n      wasmOffsetConverter = new WasmOffsetConverter(new Uint8Array(arrayBufferResult), instantiationResult.module);\n      receiveInstantiationResult(instantiationResult);\n     }, function(reason) {\n      err(\"failed to initialize offset-converter: \" + reason);\n     });\n    }, function(reason) {\n     err(\"wasm streaming compile failed: \" + reason);\n     err(\"falling back to ArrayBuffer instantiation\");\n     return instantiateArrayBuffer(receiveInstantiationResult);\n    });\n   });\n  } else {\n   return instantiateArrayBuffer(receiveInstantiationResult);\n  }\n }\n if (Module[\"instantiateWasm\"]) {\n  wasmOffsetConverter = resetPrototype(WasmOffsetConverter, Module[\"wasmOffsetData\"]);\n  try {\n   var exports = Module[\"instantiateWasm\"](info, receiveInstance);\n   return exports;\n  } catch (e) {\n   err(\"Module.instantiateWasm callback failed with error: \" + e);\n   return false;\n  }\n }\n instantiateAsync().catch(readyPromiseReject);\n return {};\n}\n\nvar tempDouble;\n\nvar tempI64;\n\nvar ASM_CONSTS = {\n 9944129: function() {\n  return withBuiltinMalloc(function() {\n   return allocateUTF8(Module[\"ASAN_OPTIONS\"] || 0);\n  });\n },\n 9944226: function() {\n  return withBuiltinMalloc(function() {\n   return allocateUTF8(Module[\"LSAN_OPTIONS\"] || 0);\n  });\n },\n 9944323: function() {\n  return withBuiltinMalloc(function() {\n   return allocateUTF8(Module[\"UBSAN_OPTIONS\"] || 0);\n  });\n },\n 9944421: function() {\n  var setting = Module[\"printWithColors\"];\n  if (setting != null) {\n   return setting;\n  } else {\n   return ENVIRONMENT_IS_NODE && process.stderr.isTTY;\n  }\n }\n};\n\nfunction callRuntimeCallbacks(callbacks) {\n while (callbacks.length > 0) {\n  var callback = callbacks.shift();\n  if (typeof callback == \"function\") {\n   callback(Module);\n   continue;\n  }\n  var func = callback.func;\n  if (typeof func === \"number\") {\n   if (callback.arg === undefined) {\n    getWasmTableEntry(func)();\n   } else {\n    getWasmTableEntry(func)(callback.arg);\n   }\n  } else {\n   func(callback.arg === undefined ? null : callback.arg);\n  }\n }\n}\n\nfunction demangle(func) {\n warnOnce(\"warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\");\n return func;\n}\n\nfunction demangleAll(text) {\n var regex = /\\b_Z[\\w\\d_]+/g;\n return text.replace(regex, function(x) {\n  var y = demangle(x);\n  return x === y ? x : y + \" [\" + x + \"]\";\n });\n}\n\nvar wasmTableMirror = [];\n\nfunction getWasmTableEntry(funcPtr) {\n var func = wasmTableMirror[funcPtr];\n if (!func) {\n  if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n  wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n }\n assert(wasmTable.get(funcPtr) == func, \"JavaScript-side Wasm function table mirror is out of date!\");\n return func;\n}\n\nfunction jsStackTrace() {\n var error = new Error();\n if (!error.stack) {\n  try {\n   throw new Error();\n  } catch (e) {\n   error = e;\n  }\n  if (!error.stack) {\n   return \"(no stack trace available)\";\n  }\n }\n return error.stack.toString();\n}\n\nfunction setWasmTableEntry(idx, func) {\n wasmTable.set(idx, func);\n wasmTableMirror[idx] = func;\n}\n\nfunction ___assert_fail(condition, filename, line, func) {\n abort(\"Assertion failed: \" + UTF8ToString(condition) + \", at: \" + [ filename ? UTF8ToString(filename) : \"unknown filename\", line, func ? UTF8ToString(func) : \"unknown function\" ]);\n}\n\nvar PATH = {\n splitPath: function(filename) {\n  var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n  return splitPathRe.exec(filename).slice(1);\n },\n normalizeArray: function(parts, allowAboveRoot) {\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n   var last = parts[i];\n   if (last === \".\") {\n    parts.splice(i, 1);\n   } else if (last === \"..\") {\n    parts.splice(i, 1);\n    up++;\n   } else if (up) {\n    parts.splice(i, 1);\n    up--;\n   }\n  }\n  if (allowAboveRoot) {\n   for (;up; up--) {\n    parts.unshift(\"..\");\n   }\n  }\n  return parts;\n },\n normalize: function(path) {\n  var isAbsolute = path.charAt(0) === \"/\", trailingSlash = path.substr(-1) === \"/\";\n  path = PATH.normalizeArray(path.split(\"/\").filter(function(p) {\n   return !!p;\n  }), !isAbsolute).join(\"/\");\n  if (!path && !isAbsolute) {\n   path = \".\";\n  }\n  if (path && trailingSlash) {\n   path += \"/\";\n  }\n  return (isAbsolute ? \"/\" : \"\") + path;\n },\n dirname: function(path) {\n  var result = PATH.splitPath(path), root = result[0], dir = result[1];\n  if (!root && !dir) {\n   return \".\";\n  }\n  if (dir) {\n   dir = dir.substr(0, dir.length - 1);\n  }\n  return root + dir;\n },\n basename: function(path) {\n  if (path === \"/\") return \"/\";\n  path = PATH.normalize(path);\n  path = path.replace(/\\/$/, \"\");\n  var lastSlash = path.lastIndexOf(\"/\");\n  if (lastSlash === -1) return path;\n  return path.substr(lastSlash + 1);\n },\n extname: function(path) {\n  return PATH.splitPath(path)[3];\n },\n join: function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return PATH.normalize(paths.join(\"/\"));\n },\n join2: function(l, r) {\n  return PATH.normalize(l + \"/\" + r);\n }\n};\n\nfunction getRandomDevice() {\n if (typeof crypto === \"object\" && typeof crypto[\"getRandomValues\"] === \"function\") {\n  var randomBuffer = new Uint8Array(1);\n  return function() {\n   crypto.getRandomValues(randomBuffer);\n   return randomBuffer[0];\n  };\n } else return function() {\n  abort(\"no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };\");\n };\n}\n\nvar PATH_FS = {\n resolve: function() {\n  var resolvedPath = \"\", resolvedAbsolute = false;\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n   var path = i >= 0 ? arguments[i] : FS.cwd();\n   if (typeof path !== \"string\") {\n    throw new TypeError(\"Arguments to path.resolve must be strings\");\n   } else if (!path) {\n    return \"\";\n   }\n   resolvedPath = path + \"/\" + resolvedPath;\n   resolvedAbsolute = path.charAt(0) === \"/\";\n  }\n  resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(function(p) {\n   return !!p;\n  }), !resolvedAbsolute).join(\"/\");\n  return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n },\n relative: function(from, to) {\n  from = PATH_FS.resolve(from).substr(1);\n  to = PATH_FS.resolve(to).substr(1);\n  function trim(arr) {\n   var start = 0;\n   for (;start < arr.length; start++) {\n    if (arr[start] !== \"\") break;\n   }\n   var end = arr.length - 1;\n   for (;end >= 0; end--) {\n    if (arr[end] !== \"\") break;\n   }\n   if (start > end) return [];\n   return arr.slice(start, end - start + 1);\n  }\n  var fromParts = trim(from.split(\"/\"));\n  var toParts = trim(to.split(\"/\"));\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n   if (fromParts[i] !== toParts[i]) {\n    samePartsLength = i;\n    break;\n   }\n  }\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n   outputParts.push(\"..\");\n  }\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n  return outputParts.join(\"/\");\n }\n};\n\nvar TTY = {\n ttys: [],\n init: function() {},\n shutdown: function() {},\n register: function(dev, ops) {\n  TTY.ttys[dev] = {\n   input: [],\n   output: [],\n   ops: ops\n  };\n  FS.registerDevice(dev, TTY.stream_ops);\n },\n stream_ops: {\n  open: function(stream) {\n   var tty = TTY.ttys[stream.node.rdev];\n   if (!tty) {\n    throw new FS.ErrnoError(43);\n   }\n   stream.tty = tty;\n   stream.seekable = false;\n  },\n  close: function(stream) {\n   stream.tty.ops.flush(stream.tty);\n  },\n  flush: function(stream) {\n   stream.tty.ops.flush(stream.tty);\n  },\n  read: function(stream, buffer, offset, length, pos) {\n   if (!stream.tty || !stream.tty.ops.get_char) {\n    throw new FS.ErrnoError(60);\n   }\n   var bytesRead = 0;\n   for (var i = 0; i < length; i++) {\n    var result;\n    try {\n     result = stream.tty.ops.get_char(stream.tty);\n    } catch (e) {\n     throw new FS.ErrnoError(29);\n    }\n    if (result === undefined && bytesRead === 0) {\n     throw new FS.ErrnoError(6);\n    }\n    if (result === null || result === undefined) break;\n    bytesRead++;\n    buffer[offset + i] = result;\n   }\n   if (bytesRead) {\n    stream.node.timestamp = Date.now();\n   }\n   return bytesRead;\n  },\n  write: function(stream, buffer, offset, length, pos) {\n   if (!stream.tty || !stream.tty.ops.put_char) {\n    throw new FS.ErrnoError(60);\n   }\n   try {\n    for (var i = 0; i < length; i++) {\n     stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n    }\n   } catch (e) {\n    throw new FS.ErrnoError(29);\n   }\n   if (length) {\n    stream.node.timestamp = Date.now();\n   }\n   return i;\n  }\n },\n default_tty_ops: {\n  get_char: function(tty) {\n   if (!tty.input.length) {\n    var result = null;\n    if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n     result = window.prompt(\"Input: \");\n     if (result !== null) {\n      result += \"\\n\";\n     }\n    } else if (typeof readline == \"function\") {\n     result = readline();\n     if (result !== null) {\n      result += \"\\n\";\n     }\n    }\n    if (!result) {\n     return null;\n    }\n    tty.input = intArrayFromString(result, true);\n   }\n   return tty.input.shift();\n  },\n  put_char: function(tty, val) {\n   if (val === null || val === 10) {\n    out(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   } else {\n    if (val != 0) tty.output.push(val);\n   }\n  },\n  flush: function(tty) {\n   if (tty.output && tty.output.length > 0) {\n    out(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   }\n  }\n },\n default_tty1_ops: {\n  put_char: function(tty, val) {\n   if (val === null || val === 10) {\n    err(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   } else {\n    if (val != 0) tty.output.push(val);\n   }\n  },\n  flush: function(tty) {\n   if (tty.output && tty.output.length > 0) {\n    err(UTF8ArrayToString(tty.output, 0));\n    tty.output = [];\n   }\n  }\n }\n};\n\nfunction zeroMemory(address, size) {\n HEAPU8.fill(0, address, address + size);\n}\n\nfunction alignMemory(size, alignment) {\n assert(alignment, \"alignment argument is required\");\n return Math.ceil(size / alignment) * alignment;\n}\n\nfunction mmapAlloc(size) {\n size = alignMemory(size, 65536);\n var ptr = _memalign(65536, size);\n if (!ptr) return 0;\n zeroMemory(ptr, size);\n return ptr;\n}\n\nvar MEMFS = {\n ops_table: null,\n mount: function(mount) {\n  return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n },\n createNode: function(parent, name, mode, dev) {\n  if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n   throw new FS.ErrnoError(63);\n  }\n  if (!MEMFS.ops_table) {\n   MEMFS.ops_table = {\n    dir: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr,\n      lookup: MEMFS.node_ops.lookup,\n      mknod: MEMFS.node_ops.mknod,\n      rename: MEMFS.node_ops.rename,\n      unlink: MEMFS.node_ops.unlink,\n      rmdir: MEMFS.node_ops.rmdir,\n      readdir: MEMFS.node_ops.readdir,\n      symlink: MEMFS.node_ops.symlink\n     },\n     stream: {\n      llseek: MEMFS.stream_ops.llseek\n     }\n    },\n    file: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr\n     },\n     stream: {\n      llseek: MEMFS.stream_ops.llseek,\n      read: MEMFS.stream_ops.read,\n      write: MEMFS.stream_ops.write,\n      allocate: MEMFS.stream_ops.allocate,\n      mmap: MEMFS.stream_ops.mmap,\n      msync: MEMFS.stream_ops.msync\n     }\n    },\n    link: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr,\n      readlink: MEMFS.node_ops.readlink\n     },\n     stream: {}\n    },\n    chrdev: {\n     node: {\n      getattr: MEMFS.node_ops.getattr,\n      setattr: MEMFS.node_ops.setattr\n     },\n     stream: FS.chrdev_stream_ops\n    }\n   };\n  }\n  var node = FS.createNode(parent, name, mode, dev);\n  if (FS.isDir(node.mode)) {\n   node.node_ops = MEMFS.ops_table.dir.node;\n   node.stream_ops = MEMFS.ops_table.dir.stream;\n   node.contents = {};\n  } else if (FS.isFile(node.mode)) {\n   node.node_ops = MEMFS.ops_table.file.node;\n   node.stream_ops = MEMFS.ops_table.file.stream;\n   node.usedBytes = 0;\n   node.contents = null;\n  } else if (FS.isLink(node.mode)) {\n   node.node_ops = MEMFS.ops_table.link.node;\n   node.stream_ops = MEMFS.ops_table.link.stream;\n  } else if (FS.isChrdev(node.mode)) {\n   node.node_ops = MEMFS.ops_table.chrdev.node;\n   node.stream_ops = MEMFS.ops_table.chrdev.stream;\n  }\n  node.timestamp = Date.now();\n  if (parent) {\n   parent.contents[name] = node;\n   parent.timestamp = node.timestamp;\n  }\n  return node;\n },\n getFileDataAsTypedArray: function(node) {\n  if (!node.contents) return new Uint8Array(0);\n  if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n  return new Uint8Array(node.contents);\n },\n expandFileStorage: function(node, newCapacity) {\n  var prevCapacity = node.contents ? node.contents.length : 0;\n  if (prevCapacity >= newCapacity) return;\n  var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n  newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n  if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n  var oldContents = node.contents;\n  node.contents = new Uint8Array(newCapacity);\n  if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n },\n resizeFileStorage: function(node, newSize) {\n  if (node.usedBytes == newSize) return;\n  if (newSize == 0) {\n   node.contents = null;\n   node.usedBytes = 0;\n  } else {\n   var oldContents = node.contents;\n   node.contents = new Uint8Array(newSize);\n   if (oldContents) {\n    node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n   }\n   node.usedBytes = newSize;\n  }\n },\n node_ops: {\n  getattr: function(node) {\n   var attr = {};\n   attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n   attr.ino = node.id;\n   attr.mode = node.mode;\n   attr.nlink = 1;\n   attr.uid = 0;\n   attr.gid = 0;\n   attr.rdev = node.rdev;\n   if (FS.isDir(node.mode)) {\n    attr.size = 4096;\n   } else if (FS.isFile(node.mode)) {\n    attr.size = node.usedBytes;\n   } else if (FS.isLink(node.mode)) {\n    attr.size = node.link.length;\n   } else {\n    attr.size = 0;\n   }\n   attr.atime = new Date(node.timestamp);\n   attr.mtime = new Date(node.timestamp);\n   attr.ctime = new Date(node.timestamp);\n   attr.blksize = 4096;\n   attr.blocks = Math.ceil(attr.size / attr.blksize);\n   return attr;\n  },\n  setattr: function(node, attr) {\n   if (attr.mode !== undefined) {\n    node.mode = attr.mode;\n   }\n   if (attr.timestamp !== undefined) {\n    node.timestamp = attr.timestamp;\n   }\n   if (attr.size !== undefined) {\n    MEMFS.resizeFileStorage(node, attr.size);\n   }\n  },\n  lookup: function(parent, name) {\n   throw FS.genericErrors[44];\n  },\n  mknod: function(parent, name, mode, dev) {\n   return MEMFS.createNode(parent, name, mode, dev);\n  },\n  rename: function(old_node, new_dir, new_name) {\n   if (FS.isDir(old_node.mode)) {\n    var new_node;\n    try {\n     new_node = FS.lookupNode(new_dir, new_name);\n    } catch (e) {}\n    if (new_node) {\n     for (var i in new_node.contents) {\n      throw new FS.ErrnoError(55);\n     }\n    }\n   }\n   delete old_node.parent.contents[old_node.name];\n   old_node.parent.timestamp = Date.now();\n   old_node.name = new_name;\n   new_dir.contents[new_name] = old_node;\n   new_dir.timestamp = old_node.parent.timestamp;\n   old_node.parent = new_dir;\n  },\n  unlink: function(parent, name) {\n   delete parent.contents[name];\n   parent.timestamp = Date.now();\n  },\n  rmdir: function(parent, name) {\n   var node = FS.lookupNode(parent, name);\n   for (var i in node.contents) {\n    throw new FS.ErrnoError(55);\n   }\n   delete parent.contents[name];\n   parent.timestamp = Date.now();\n  },\n  readdir: function(node) {\n   var entries = [ \".\", \"..\" ];\n   for (var key in node.contents) {\n    if (!node.contents.hasOwnProperty(key)) {\n     continue;\n    }\n    entries.push(key);\n   }\n   return entries;\n  },\n  symlink: function(parent, newname, oldpath) {\n   var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n   node.link = oldpath;\n   return node;\n  },\n  readlink: function(node) {\n   if (!FS.isLink(node.mode)) {\n    throw new FS.ErrnoError(28);\n   }\n   return node.link;\n  }\n },\n stream_ops: {\n  read: function(stream, buffer, offset, length, position) {\n   var contents = stream.node.contents;\n   if (position >= stream.node.usedBytes) return 0;\n   var size = Math.min(stream.node.usedBytes - position, length);\n   assert(size >= 0);\n   if (size > 8 && contents.subarray) {\n    buffer.set(contents.subarray(position, position + size), offset);\n   } else {\n    for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n   }\n   return size;\n  },\n  write: function(stream, buffer, offset, length, position, canOwn) {\n   assert(!(buffer instanceof ArrayBuffer));\n   if (!length) return 0;\n   var node = stream.node;\n   node.timestamp = Date.now();\n   if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n    if (canOwn) {\n     assert(position === 0, \"canOwn must imply no weird position inside the file\");\n     node.contents = buffer.subarray(offset, offset + length);\n     node.usedBytes = length;\n     return length;\n    } else if (node.usedBytes === 0 && position === 0) {\n     node.contents = buffer.slice(offset, offset + length);\n     node.usedBytes = length;\n     return length;\n    } else if (position + length <= node.usedBytes) {\n     node.contents.set(buffer.subarray(offset, offset + length), position);\n     return length;\n    }\n   }\n   MEMFS.expandFileStorage(node, position + length);\n   if (node.contents.subarray && buffer.subarray) {\n    node.contents.set(buffer.subarray(offset, offset + length), position);\n   } else {\n    for (var i = 0; i < length; i++) {\n     node.contents[position + i] = buffer[offset + i];\n    }\n   }\n   node.usedBytes = Math.max(node.usedBytes, position + length);\n   return length;\n  },\n  llseek: function(stream, offset, whence) {\n   var position = offset;\n   if (whence === 1) {\n    position += stream.position;\n   } else if (whence === 2) {\n    if (FS.isFile(stream.node.mode)) {\n     position += stream.node.usedBytes;\n    }\n   }\n   if (position < 0) {\n    throw new FS.ErrnoError(28);\n   }\n   return position;\n  },\n  allocate: function(stream, offset, length) {\n   MEMFS.expandFileStorage(stream.node, offset + length);\n   stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n  },\n  mmap: function(stream, address, length, position, prot, flags) {\n   if (address !== 0) {\n    throw new FS.ErrnoError(28);\n   }\n   if (!FS.isFile(stream.node.mode)) {\n    throw new FS.ErrnoError(43);\n   }\n   var ptr;\n   var allocated;\n   var contents = stream.node.contents;\n   if (!(flags & 2) && contents.buffer === buffer) {\n    allocated = false;\n    ptr = contents.byteOffset;\n   } else {\n    if (position > 0 || position + length < contents.length) {\n     if (contents.subarray) {\n      contents = contents.subarray(position, position + length);\n     } else {\n      contents = Array.prototype.slice.call(contents, position, position + length);\n     }\n    }\n    allocated = true;\n    ptr = mmapAlloc(length);\n    if (!ptr) {\n     throw new FS.ErrnoError(48);\n    }\n    HEAP8.set(contents, ptr);\n   }\n   return {\n    ptr: ptr,\n    allocated: allocated\n   };\n  },\n  msync: function(stream, buffer, offset, length, mmapFlags) {\n   if (!FS.isFile(stream.node.mode)) {\n    throw new FS.ErrnoError(43);\n   }\n   if (mmapFlags & 2) {\n    return 0;\n   }\n   var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n   return 0;\n  }\n }\n};\n\nfunction asyncLoad(url, onload, onerror, noRunDep) {\n var dep = !noRunDep ? getUniqueRunDependency(\"al \" + url) : \"\";\n readAsync(url, function(arrayBuffer) {\n  assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).');\n  onload(new Uint8Array(arrayBuffer));\n  if (dep) removeRunDependency(dep);\n }, function(event) {\n  if (onerror) {\n   onerror();\n  } else {\n   throw 'Loading data file \"' + url + '\" failed.';\n  }\n });\n if (dep) addRunDependency(dep);\n}\n\nvar ERRNO_MESSAGES = {\n 0: \"Success\",\n 1: \"Arg list too long\",\n 2: \"Permission denied\",\n 3: \"Address already in use\",\n 4: \"Address not available\",\n 5: \"Address family not supported by protocol family\",\n 6: \"No more processes\",\n 7: \"Socket already connected\",\n 8: \"Bad file number\",\n 9: \"Trying to read unreadable message\",\n 10: \"Mount device busy\",\n 11: \"Operation canceled\",\n 12: \"No children\",\n 13: \"Connection aborted\",\n 14: \"Connection refused\",\n 15: \"Connection reset by peer\",\n 16: \"File locking deadlock error\",\n 17: \"Destination address required\",\n 18: \"Math arg out of domain of func\",\n 19: \"Quota exceeded\",\n 20: \"File exists\",\n 21: \"Bad address\",\n 22: \"File too large\",\n 23: \"Host is unreachable\",\n 24: \"Identifier removed\",\n 25: \"Illegal byte sequence\",\n 26: \"Connection already in progress\",\n 27: \"Interrupted system call\",\n 28: \"Invalid argument\",\n 29: \"I/O error\",\n 30: \"Socket is already connected\",\n 31: \"Is a directory\",\n 32: \"Too many symbolic links\",\n 33: \"Too many open files\",\n 34: \"Too many links\",\n 35: \"Message too long\",\n 36: \"Multihop attempted\",\n 37: \"File or path name too long\",\n 38: \"Network interface is not configured\",\n 39: \"Connection reset by network\",\n 40: \"Network is unreachable\",\n 41: \"Too many open files in system\",\n 42: \"No buffer space available\",\n 43: \"No such device\",\n 44: \"No such file or directory\",\n 45: \"Exec format error\",\n 46: \"No record locks available\",\n 47: \"The link has been severed\",\n 48: \"Not enough core\",\n 49: \"No message of desired type\",\n 50: \"Protocol not available\",\n 51: \"No space left on device\",\n 52: \"Function not implemented\",\n 53: \"Socket is not connected\",\n 54: \"Not a directory\",\n 55: \"Directory not empty\",\n 56: \"State not recoverable\",\n 57: \"Socket operation on non-socket\",\n 59: \"Not a typewriter\",\n 60: \"No such device or address\",\n 61: \"Value too large for defined data type\",\n 62: \"Previous owner died\",\n 63: \"Not super-user\",\n 64: \"Broken pipe\",\n 65: \"Protocol error\",\n 66: \"Unknown protocol\",\n 67: \"Protocol wrong type for socket\",\n 68: \"Math result not representable\",\n 69: \"Read only file system\",\n 70: \"Illegal seek\",\n 71: \"No such process\",\n 72: \"Stale file handle\",\n 73: \"Connection timed out\",\n 74: \"Text file busy\",\n 75: \"Cross-device link\",\n 100: \"Device not a stream\",\n 101: \"Bad font file fmt\",\n 102: \"Invalid slot\",\n 103: \"Invalid request code\",\n 104: \"No anode\",\n 105: \"Block device required\",\n 106: \"Channel number out of range\",\n 107: \"Level 3 halted\",\n 108: \"Level 3 reset\",\n 109: \"Link number out of range\",\n 110: \"Protocol driver not attached\",\n 111: \"No CSI structure available\",\n 112: \"Level 2 halted\",\n 113: \"Invalid exchange\",\n 114: \"Invalid request descriptor\",\n 115: \"Exchange full\",\n 116: \"No data (for no delay io)\",\n 117: \"Timer expired\",\n 118: \"Out of streams resources\",\n 119: \"Machine is not on the network\",\n 120: \"Package not installed\",\n 121: \"The object is remote\",\n 122: \"Advertise error\",\n 123: \"Srmount error\",\n 124: \"Communication error on send\",\n 125: \"Cross mount point (not really error)\",\n 126: \"Given log. name not unique\",\n 127: \"f.d. invalid for this operation\",\n 128: \"Remote address changed\",\n 129: \"Can   access a needed shared lib\",\n 130: \"Accessing a corrupted shared lib\",\n 131: \".lib section in a.out corrupted\",\n 132: \"Attempting to link in too many libs\",\n 133: \"Attempting to exec a shared library\",\n 135: \"Streams pipe error\",\n 136: \"Too many users\",\n 137: \"Socket type not supported\",\n 138: \"Not supported\",\n 139: \"Protocol family not supported\",\n 140: \"Can't send after socket shutdown\",\n 141: \"Too many references\",\n 142: \"Host is down\",\n 148: \"No medium (in tape drive)\",\n 156: \"Level 2 not synchronized\"\n};\n\nvar ERRNO_CODES = {};\n\nvar FS = {\n root: null,\n mounts: [],\n devices: {},\n streams: [],\n nextInode: 1,\n nameTable: null,\n currentPath: \"/\",\n initialized: false,\n ignorePermissions: true,\n ErrnoError: null,\n genericErrors: {},\n filesystems: null,\n syncFSRequests: 0,\n lookupPath: (path, opts = {}) => {\n  path = PATH_FS.resolve(FS.cwd(), path);\n  if (!path) return {\n   path: \"\",\n   node: null\n  };\n  var defaults = {\n   follow_mount: true,\n   recurse_count: 0\n  };\n  for (var key in defaults) {\n   if (opts[key] === undefined) {\n    opts[key] = defaults[key];\n   }\n  }\n  if (opts.recurse_count > 8) {\n   throw new FS.ErrnoError(32);\n  }\n  var parts = PATH.normalizeArray(path.split(\"/\").filter(p => !!p), false);\n  var current = FS.root;\n  var current_path = \"/\";\n  for (var i = 0; i < parts.length; i++) {\n   var islast = i === parts.length - 1;\n   if (islast && opts.parent) {\n    break;\n   }\n   current = FS.lookupNode(current, parts[i]);\n   current_path = PATH.join2(current_path, parts[i]);\n   if (FS.isMountpoint(current)) {\n    if (!islast || islast && opts.follow_mount) {\n     current = current.mounted.root;\n    }\n   }\n   if (!islast || opts.follow) {\n    var count = 0;\n    while (FS.isLink(current.mode)) {\n     var link = FS.readlink(current_path);\n     current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n     var lookup = FS.lookupPath(current_path, {\n      recurse_count: opts.recurse_count\n     });\n     current = lookup.node;\n     if (count++ > 40) {\n      throw new FS.ErrnoError(32);\n     }\n    }\n   }\n  }\n  return {\n   path: current_path,\n   node: current\n  };\n },\n getPath: node => {\n  var path;\n  while (true) {\n   if (FS.isRoot(node)) {\n    var mount = node.mount.mountpoint;\n    if (!path) return mount;\n    return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path;\n   }\n   path = path ? node.name + \"/\" + path : node.name;\n   node = node.parent;\n  }\n },\n hashName: (parentid, name) => {\n  var hash = 0;\n  for (var i = 0; i < name.length; i++) {\n   hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n  }\n  return (parentid + hash >>> 0) % FS.nameTable.length;\n },\n hashAddNode: node => {\n  var hash = FS.hashName(node.parent.id, node.name);\n  node.name_next = FS.nameTable[hash];\n  FS.nameTable[hash] = node;\n },\n hashRemoveNode: node => {\n  var hash = FS.hashName(node.parent.id, node.name);\n  if (FS.nameTable[hash] === node) {\n   FS.nameTable[hash] = node.name_next;\n  } else {\n   var current = FS.nameTable[hash];\n   while (current) {\n    if (current.name_next === node) {\n     current.name_next = node.name_next;\n     break;\n    }\n    current = current.name_next;\n   }\n  }\n },\n lookupNode: (parent, name) => {\n  var errCode = FS.mayLookup(parent);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode, parent);\n  }\n  var hash = FS.hashName(parent.id, name);\n  for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n   var nodeName = node.name;\n   if (node.parent.id === parent.id && nodeName === name) {\n    return node;\n   }\n  }\n  return FS.lookup(parent, name);\n },\n createNode: (parent, name, mode, rdev) => {\n  assert(typeof parent === \"object\");\n  var node = new FS.FSNode(parent, name, mode, rdev);\n  FS.hashAddNode(node);\n  return node;\n },\n destroyNode: node => {\n  FS.hashRemoveNode(node);\n },\n isRoot: node => {\n  return node === node.parent;\n },\n isMountpoint: node => {\n  return !!node.mounted;\n },\n isFile: mode => {\n  return (mode & 61440) === 32768;\n },\n isDir: mode => {\n  return (mode & 61440) === 16384;\n },\n isLink: mode => {\n  return (mode & 61440) === 40960;\n },\n isChrdev: mode => {\n  return (mode & 61440) === 8192;\n },\n isBlkdev: mode => {\n  return (mode & 61440) === 24576;\n },\n isFIFO: mode => {\n  return (mode & 61440) === 4096;\n },\n isSocket: mode => {\n  return (mode & 49152) === 49152;\n },\n flagModes: {\n  \"r\": 0,\n  \"r+\": 2,\n  \"w\": 577,\n  \"w+\": 578,\n  \"a\": 1089,\n  \"a+\": 1090\n },\n modeStringToFlags: str => {\n  var flags = FS.flagModes[str];\n  if (typeof flags === \"undefined\") {\n   throw new Error(\"Unknown file open mode: \" + str);\n  }\n  return flags;\n },\n flagsToPermissionString: flag => {\n  var perms = [ \"r\", \"w\", \"rw\" ][flag & 3];\n  if (flag & 512) {\n   perms += \"w\";\n  }\n  return perms;\n },\n nodePermissions: (node, perms) => {\n  if (FS.ignorePermissions) {\n   return 0;\n  }\n  if (perms.includes(\"r\") && !(node.mode & 292)) {\n   return 2;\n  } else if (perms.includes(\"w\") && !(node.mode & 146)) {\n   return 2;\n  } else if (perms.includes(\"x\") && !(node.mode & 73)) {\n   return 2;\n  }\n  return 0;\n },\n mayLookup: dir => {\n  var errCode = FS.nodePermissions(dir, \"x\");\n  if (errCode) return errCode;\n  if (!dir.node_ops.lookup) return 2;\n  return 0;\n },\n mayCreate: (dir, name) => {\n  try {\n   var node = FS.lookupNode(dir, name);\n   return 20;\n  } catch (e) {}\n  return FS.nodePermissions(dir, \"wx\");\n },\n mayDelete: (dir, name, isdir) => {\n  var node;\n  try {\n   node = FS.lookupNode(dir, name);\n  } catch (e) {\n   return e.errno;\n  }\n  var errCode = FS.nodePermissions(dir, \"wx\");\n  if (errCode) {\n   return errCode;\n  }\n  if (isdir) {\n   if (!FS.isDir(node.mode)) {\n    return 54;\n   }\n   if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n    return 10;\n   }\n  } else {\n   if (FS.isDir(node.mode)) {\n    return 31;\n   }\n  }\n  return 0;\n },\n mayOpen: (node, flags) => {\n  if (!node) {\n   return 44;\n  }\n  if (FS.isLink(node.mode)) {\n   return 32;\n  } else if (FS.isDir(node.mode)) {\n   if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n    return 31;\n   }\n  }\n  return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n },\n MAX_OPEN_FDS: 4096,\n nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {\n  for (var fd = fd_start; fd <= fd_end; fd++) {\n   if (!FS.streams[fd]) {\n    return fd;\n   }\n  }\n  throw new FS.ErrnoError(33);\n },\n getStream: fd => FS.streams[fd],\n createStream: (stream, fd_start, fd_end) => {\n  if (!FS.FSStream) {\n   FS.FSStream = function() {};\n   FS.FSStream.prototype = {\n    object: {\n     get: function() {\n      return this.node;\n     },\n     set: function(val) {\n      this.node = val;\n     }\n    },\n    isRead: {\n     get: function() {\n      return (this.flags & 2097155) !== 1;\n     }\n    },\n    isWrite: {\n     get: function() {\n      return (this.flags & 2097155) !== 0;\n     }\n    },\n    isAppend: {\n     get: function() {\n      return this.flags & 1024;\n     }\n    }\n   };\n  }\n  stream = Object.assign(new FS.FSStream(), stream);\n  var fd = FS.nextfd(fd_start, fd_end);\n  stream.fd = fd;\n  FS.streams[fd] = stream;\n  return stream;\n },\n closeStream: fd => {\n  FS.streams[fd] = null;\n },\n chrdev_stream_ops: {\n  open: stream => {\n   var device = FS.getDevice(stream.node.rdev);\n   stream.stream_ops = device.stream_ops;\n   if (stream.stream_ops.open) {\n    stream.stream_ops.open(stream);\n   }\n  },\n  llseek: () => {\n   throw new FS.ErrnoError(70);\n  }\n },\n major: dev => dev >> 8,\n minor: dev => dev & 255,\n makedev: (ma, mi) => ma << 8 | mi,\n registerDevice: (dev, ops) => {\n  FS.devices[dev] = {\n   stream_ops: ops\n  };\n },\n getDevice: dev => FS.devices[dev],\n getMounts: mount => {\n  var mounts = [];\n  var check = [ mount ];\n  while (check.length) {\n   var m = check.pop();\n   mounts.push(m);\n   check.push.apply(check, m.mounts);\n  }\n  return mounts;\n },\n syncfs: (populate, callback) => {\n  if (typeof populate === \"function\") {\n   callback = populate;\n   populate = false;\n  }\n  FS.syncFSRequests++;\n  if (FS.syncFSRequests > 1) {\n   err(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\");\n  }\n  var mounts = FS.getMounts(FS.root.mount);\n  var completed = 0;\n  function doCallback(errCode) {\n   assert(FS.syncFSRequests > 0);\n   FS.syncFSRequests--;\n   return callback(errCode);\n  }\n  function done(errCode) {\n   if (errCode) {\n    if (!done.errored) {\n     done.errored = true;\n     return doCallback(errCode);\n    }\n    return;\n   }\n   if (++completed >= mounts.length) {\n    doCallback(null);\n   }\n  }\n  mounts.forEach(mount => {\n   if (!mount.type.syncfs) {\n    return done(null);\n   }\n   mount.type.syncfs(mount, populate, done);\n  });\n },\n mount: (type, opts, mountpoint) => {\n  if (typeof type === \"string\") {\n   throw type;\n  }\n  var root = mountpoint === \"/\";\n  var pseudo = !mountpoint;\n  var node;\n  if (root && FS.root) {\n   throw new FS.ErrnoError(10);\n  } else if (!root && !pseudo) {\n   var lookup = FS.lookupPath(mountpoint, {\n    follow_mount: false\n   });\n   mountpoint = lookup.path;\n   node = lookup.node;\n   if (FS.isMountpoint(node)) {\n    throw new FS.ErrnoError(10);\n   }\n   if (!FS.isDir(node.mode)) {\n    throw new FS.ErrnoError(54);\n   }\n  }\n  var mount = {\n   type: type,\n   opts: opts,\n   mountpoint: mountpoint,\n   mounts: []\n  };\n  var mountRoot = type.mount(mount);\n  mountRoot.mount = mount;\n  mount.root = mountRoot;\n  if (root) {\n   FS.root = mountRoot;\n  } else if (node) {\n   node.mounted = mount;\n   if (node.mount) {\n    node.mount.mounts.push(mount);\n   }\n  }\n  return mountRoot;\n },\n unmount: mountpoint => {\n  var lookup = FS.lookupPath(mountpoint, {\n   follow_mount: false\n  });\n  if (!FS.isMountpoint(lookup.node)) {\n   throw new FS.ErrnoError(28);\n  }\n  var node = lookup.node;\n  var mount = node.mounted;\n  var mounts = FS.getMounts(mount);\n  Object.keys(FS.nameTable).forEach(hash => {\n   var current = FS.nameTable[hash];\n   while (current) {\n    var next = current.name_next;\n    if (mounts.includes(current.mount)) {\n     FS.destroyNode(current);\n    }\n    current = next;\n   }\n  });\n  node.mounted = null;\n  var idx = node.mount.mounts.indexOf(mount);\n  assert(idx !== -1);\n  node.mount.mounts.splice(idx, 1);\n },\n lookup: (parent, name) => {\n  return parent.node_ops.lookup(parent, name);\n },\n mknod: (path, mode, dev) => {\n  var lookup = FS.lookupPath(path, {\n   parent: true\n  });\n  var parent = lookup.node;\n  var name = PATH.basename(path);\n  if (!name || name === \".\" || name === \"..\") {\n   throw new FS.ErrnoError(28);\n  }\n  var errCode = FS.mayCreate(parent, name);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.mknod) {\n   throw new FS.ErrnoError(63);\n  }\n  return parent.node_ops.mknod(parent, name, mode, dev);\n },\n create: (path, mode) => {\n  mode = mode !== undefined ? mode : 438;\n  mode &= 4095;\n  mode |= 32768;\n  return FS.mknod(path, mode, 0);\n },\n mkdir: (path, mode) => {\n  mode = mode !== undefined ? mode : 511;\n  mode &= 511 | 512;\n  mode |= 16384;\n  return FS.mknod(path, mode, 0);\n },\n mkdirTree: (path, mode) => {\n  var dirs = path.split(\"/\");\n  var d = \"\";\n  for (var i = 0; i < dirs.length; ++i) {\n   if (!dirs[i]) continue;\n   d += \"/\" + dirs[i];\n   try {\n    FS.mkdir(d, mode);\n   } catch (e) {\n    if (e.errno != 20) throw e;\n   }\n  }\n },\n mkdev: (path, mode, dev) => {\n  if (typeof dev === \"undefined\") {\n   dev = mode;\n   mode = 438;\n  }\n  mode |= 8192;\n  return FS.mknod(path, mode, dev);\n },\n symlink: (oldpath, newpath) => {\n  if (!PATH_FS.resolve(oldpath)) {\n   throw new FS.ErrnoError(44);\n  }\n  var lookup = FS.lookupPath(newpath, {\n   parent: true\n  });\n  var parent = lookup.node;\n  if (!parent) {\n   throw new FS.ErrnoError(44);\n  }\n  var newname = PATH.basename(newpath);\n  var errCode = FS.mayCreate(parent, newname);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.symlink) {\n   throw new FS.ErrnoError(63);\n  }\n  return parent.node_ops.symlink(parent, newname, oldpath);\n },\n rename: (old_path, new_path) => {\n  var old_dirname = PATH.dirname(old_path);\n  var new_dirname = PATH.dirname(new_path);\n  var old_name = PATH.basename(old_path);\n  var new_name = PATH.basename(new_path);\n  var lookup, old_dir, new_dir;\n  lookup = FS.lookupPath(old_path, {\n   parent: true\n  });\n  old_dir = lookup.node;\n  lookup = FS.lookupPath(new_path, {\n   parent: true\n  });\n  new_dir = lookup.node;\n  if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n  if (old_dir.mount !== new_dir.mount) {\n   throw new FS.ErrnoError(75);\n  }\n  var old_node = FS.lookupNode(old_dir, old_name);\n  var relative = PATH_FS.relative(old_path, new_dirname);\n  if (relative.charAt(0) !== \".\") {\n   throw new FS.ErrnoError(28);\n  }\n  relative = PATH_FS.relative(new_path, old_dirname);\n  if (relative.charAt(0) !== \".\") {\n   throw new FS.ErrnoError(55);\n  }\n  var new_node;\n  try {\n   new_node = FS.lookupNode(new_dir, new_name);\n  } catch (e) {}\n  if (old_node === new_node) {\n   return;\n  }\n  var isdir = FS.isDir(old_node.mode);\n  var errCode = FS.mayDelete(old_dir, old_name, isdir);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!old_dir.node_ops.rename) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n   throw new FS.ErrnoError(10);\n  }\n  if (new_dir !== old_dir) {\n   errCode = FS.nodePermissions(old_dir, \"w\");\n   if (errCode) {\n    throw new FS.ErrnoError(errCode);\n   }\n  }\n  FS.hashRemoveNode(old_node);\n  try {\n   old_dir.node_ops.rename(old_node, new_dir, new_name);\n  } catch (e) {\n   throw e;\n  } finally {\n   FS.hashAddNode(old_node);\n  }\n },\n rmdir: path => {\n  var lookup = FS.lookupPath(path, {\n   parent: true\n  });\n  var parent = lookup.node;\n  var name = PATH.basename(path);\n  var node = FS.lookupNode(parent, name);\n  var errCode = FS.mayDelete(parent, name, true);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.rmdir) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isMountpoint(node)) {\n   throw new FS.ErrnoError(10);\n  }\n  parent.node_ops.rmdir(parent, name);\n  FS.destroyNode(node);\n },\n readdir: path => {\n  var lookup = FS.lookupPath(path, {\n   follow: true\n  });\n  var node = lookup.node;\n  if (!node.node_ops.readdir) {\n   throw new FS.ErrnoError(54);\n  }\n  return node.node_ops.readdir(node);\n },\n unlink: path => {\n  var lookup = FS.lookupPath(path, {\n   parent: true\n  });\n  var parent = lookup.node;\n  if (!parent) {\n   throw new FS.ErrnoError(44);\n  }\n  var name = PATH.basename(path);\n  var node = FS.lookupNode(parent, name);\n  var errCode = FS.mayDelete(parent, name, false);\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  if (!parent.node_ops.unlink) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isMountpoint(node)) {\n   throw new FS.ErrnoError(10);\n  }\n  parent.node_ops.unlink(parent, name);\n  FS.destroyNode(node);\n },\n readlink: path => {\n  var lookup = FS.lookupPath(path);\n  var link = lookup.node;\n  if (!link) {\n   throw new FS.ErrnoError(44);\n  }\n  if (!link.node_ops.readlink) {\n   throw new FS.ErrnoError(28);\n  }\n  return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n },\n stat: (path, dontFollow) => {\n  var lookup = FS.lookupPath(path, {\n   follow: !dontFollow\n  });\n  var node = lookup.node;\n  if (!node) {\n   throw new FS.ErrnoError(44);\n  }\n  if (!node.node_ops.getattr) {\n   throw new FS.ErrnoError(63);\n  }\n  return node.node_ops.getattr(node);\n },\n lstat: path => {\n  return FS.stat(path, true);\n },\n chmod: (path, mode, dontFollow) => {\n  var node;\n  if (typeof path === \"string\") {\n   var lookup = FS.lookupPath(path, {\n    follow: !dontFollow\n   });\n   node = lookup.node;\n  } else {\n   node = path;\n  }\n  if (!node.node_ops.setattr) {\n   throw new FS.ErrnoError(63);\n  }\n  node.node_ops.setattr(node, {\n   mode: mode & 4095 | node.mode & ~4095,\n   timestamp: Date.now()\n  });\n },\n lchmod: (path, mode) => {\n  FS.chmod(path, mode, true);\n },\n fchmod: (fd, mode) => {\n  var stream = FS.getStream(fd);\n  if (!stream) {\n   throw new FS.ErrnoError(8);\n  }\n  FS.chmod(stream.node, mode);\n },\n chown: (path, uid, gid, dontFollow) => {\n  var node;\n  if (typeof path === \"string\") {\n   var lookup = FS.lookupPath(path, {\n    follow: !dontFollow\n   });\n   node = lookup.node;\n  } else {\n   node = path;\n  }\n  if (!node.node_ops.setattr) {\n   throw new FS.ErrnoError(63);\n  }\n  node.node_ops.setattr(node, {\n   timestamp: Date.now()\n  });\n },\n lchown: (path, uid, gid) => {\n  FS.chown(path, uid, gid, true);\n },\n fchown: (fd, uid, gid) => {\n  var stream = FS.getStream(fd);\n  if (!stream) {\n   throw new FS.ErrnoError(8);\n  }\n  FS.chown(stream.node, uid, gid);\n },\n truncate: (path, len) => {\n  if (len < 0) {\n   throw new FS.ErrnoError(28);\n  }\n  var node;\n  if (typeof path === \"string\") {\n   var lookup = FS.lookupPath(path, {\n    follow: true\n   });\n   node = lookup.node;\n  } else {\n   node = path;\n  }\n  if (!node.node_ops.setattr) {\n   throw new FS.ErrnoError(63);\n  }\n  if (FS.isDir(node.mode)) {\n   throw new FS.ErrnoError(31);\n  }\n  if (!FS.isFile(node.mode)) {\n   throw new FS.ErrnoError(28);\n  }\n  var errCode = FS.nodePermissions(node, \"w\");\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  node.node_ops.setattr(node, {\n   size: len,\n   timestamp: Date.now()\n  });\n },\n ftruncate: (fd, len) => {\n  var stream = FS.getStream(fd);\n  if (!stream) {\n   throw new FS.ErrnoError(8);\n  }\n  if ((stream.flags & 2097155) === 0) {\n   throw new FS.ErrnoError(28);\n  }\n  FS.truncate(stream.node, len);\n },\n utime: (path, atime, mtime) => {\n  var lookup = FS.lookupPath(path, {\n   follow: true\n  });\n  var node = lookup.node;\n  node.node_ops.setattr(node, {\n   timestamp: Math.max(atime, mtime)\n  });\n },\n open: (path, flags, mode, fd_start, fd_end) => {\n  if (path === \"\") {\n   throw new FS.ErrnoError(44);\n  }\n  flags = typeof flags === \"string\" ? FS.modeStringToFlags(flags) : flags;\n  mode = typeof mode === \"undefined\" ? 438 : mode;\n  if (flags & 64) {\n   mode = mode & 4095 | 32768;\n  } else {\n   mode = 0;\n  }\n  var node;\n  if (typeof path === \"object\") {\n   node = path;\n  } else {\n   path = PATH.normalize(path);\n   try {\n    var lookup = FS.lookupPath(path, {\n     follow: !(flags & 131072)\n    });\n    node = lookup.node;\n   } catch (e) {}\n  }\n  var created = false;\n  if (flags & 64) {\n   if (node) {\n    if (flags & 128) {\n     throw new FS.ErrnoError(20);\n    }\n   } else {\n    node = FS.mknod(path, mode, 0);\n    created = true;\n   }\n  }\n  if (!node) {\n   throw new FS.ErrnoError(44);\n  }\n  if (FS.isChrdev(node.mode)) {\n   flags &= ~512;\n  }\n  if (flags & 65536 && !FS.isDir(node.mode)) {\n   throw new FS.ErrnoError(54);\n  }\n  if (!created) {\n   var errCode = FS.mayOpen(node, flags);\n   if (errCode) {\n    throw new FS.ErrnoError(errCode);\n   }\n  }\n  if (flags & 512) {\n   FS.truncate(node, 0);\n  }\n  flags &= ~(128 | 512 | 131072);\n  var stream = FS.createStream({\n   node: node,\n   path: FS.getPath(node),\n   flags: flags,\n   seekable: true,\n   position: 0,\n   stream_ops: node.stream_ops,\n   ungotten: [],\n   error: false\n  }, fd_start, fd_end);\n  if (stream.stream_ops.open) {\n   stream.stream_ops.open(stream);\n  }\n  if (Module[\"logReadFiles\"] && !(flags & 1)) {\n   if (!FS.readFiles) FS.readFiles = {};\n   if (!(path in FS.readFiles)) {\n    FS.readFiles[path] = 1;\n   }\n  }\n  return stream;\n },\n close: stream => {\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if (stream.getdents) stream.getdents = null;\n  try {\n   if (stream.stream_ops.close) {\n    stream.stream_ops.close(stream);\n   }\n  } catch (e) {\n   throw e;\n  } finally {\n   FS.closeStream(stream.fd);\n  }\n  stream.fd = null;\n },\n isClosed: stream => {\n  return stream.fd === null;\n },\n llseek: (stream, offset, whence) => {\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if (!stream.seekable || !stream.stream_ops.llseek) {\n   throw new FS.ErrnoError(70);\n  }\n  if (whence != 0 && whence != 1 && whence != 2) {\n   throw new FS.ErrnoError(28);\n  }\n  stream.position = stream.stream_ops.llseek(stream, offset, whence);\n  stream.ungotten = [];\n  return stream.position;\n },\n read: (stream, buffer, offset, length, position) => {\n  if (length < 0 || position < 0) {\n   throw new FS.ErrnoError(28);\n  }\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if ((stream.flags & 2097155) === 1) {\n   throw new FS.ErrnoError(8);\n  }\n  if (FS.isDir(stream.node.mode)) {\n   throw new FS.ErrnoError(31);\n  }\n  if (!stream.stream_ops.read) {\n   throw new FS.ErrnoError(28);\n  }\n  var seeking = typeof position !== \"undefined\";\n  if (!seeking) {\n   position = stream.position;\n  } else if (!stream.seekable) {\n   throw new FS.ErrnoError(70);\n  }\n  var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n  if (!seeking) stream.position += bytesRead;\n  return bytesRead;\n },\n write: (stream, buffer, offset, length, position, canOwn) => {\n  if (length < 0 || position < 0) {\n   throw new FS.ErrnoError(28);\n  }\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if ((stream.flags & 2097155) === 0) {\n   throw new FS.ErrnoError(8);\n  }\n  if (FS.isDir(stream.node.mode)) {\n   throw new FS.ErrnoError(31);\n  }\n  if (!stream.stream_ops.write) {\n   throw new FS.ErrnoError(28);\n  }\n  if (stream.seekable && stream.flags & 1024) {\n   FS.llseek(stream, 0, 2);\n  }\n  var seeking = typeof position !== \"undefined\";\n  if (!seeking) {\n   position = stream.position;\n  } else if (!stream.seekable) {\n   throw new FS.ErrnoError(70);\n  }\n  var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n  if (!seeking) stream.position += bytesWritten;\n  return bytesWritten;\n },\n allocate: (stream, offset, length) => {\n  if (FS.isClosed(stream)) {\n   throw new FS.ErrnoError(8);\n  }\n  if (offset < 0 || length <= 0) {\n   throw new FS.ErrnoError(28);\n  }\n  if ((stream.flags & 2097155) === 0) {\n   throw new FS.ErrnoError(8);\n  }\n  if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n   throw new FS.ErrnoError(43);\n  }\n  if (!stream.stream_ops.allocate) {\n   throw new FS.ErrnoError(138);\n  }\n  stream.stream_ops.allocate(stream, offset, length);\n },\n mmap: (stream, address, length, position, prot, flags) => {\n  if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n   throw new FS.ErrnoError(2);\n  }\n  if ((stream.flags & 2097155) === 1) {\n   throw new FS.ErrnoError(2);\n  }\n  if (!stream.stream_ops.mmap) {\n   throw new FS.ErrnoError(43);\n  }\n  return stream.stream_ops.mmap(stream, address, length, position, prot, flags);\n },\n msync: (stream, buffer, offset, length, mmapFlags) => {\n  if (!stream || !stream.stream_ops.msync) {\n   return 0;\n  }\n  return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n },\n munmap: stream => 0,\n ioctl: (stream, cmd, arg) => {\n  if (!stream.stream_ops.ioctl) {\n   throw new FS.ErrnoError(59);\n  }\n  return stream.stream_ops.ioctl(stream, cmd, arg);\n },\n readFile: (path, opts = {}) => {\n  opts.flags = opts.flags || 0;\n  opts.encoding = opts.encoding || \"binary\";\n  if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n   throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n  }\n  var ret;\n  var stream = FS.open(path, opts.flags);\n  var stat = FS.stat(path);\n  var length = stat.size;\n  var buf = new Uint8Array(length);\n  FS.read(stream, buf, 0, length, 0);\n  if (opts.encoding === \"utf8\") {\n   ret = UTF8ArrayToString(buf, 0);\n  } else if (opts.encoding === \"binary\") {\n   ret = buf;\n  }\n  FS.close(stream);\n  return ret;\n },\n writeFile: (path, data, opts = {}) => {\n  opts.flags = opts.flags || 577;\n  var stream = FS.open(path, opts.flags, opts.mode);\n  if (typeof data === \"string\") {\n   var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n   var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n   FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n  } else if (ArrayBuffer.isView(data)) {\n   FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n  } else {\n   throw new Error(\"Unsupported data type\");\n  }\n  FS.close(stream);\n },\n cwd: () => FS.currentPath,\n chdir: path => {\n  var lookup = FS.lookupPath(path, {\n   follow: true\n  });\n  if (lookup.node === null) {\n   throw new FS.ErrnoError(44);\n  }\n  if (!FS.isDir(lookup.node.mode)) {\n   throw new FS.ErrnoError(54);\n  }\n  var errCode = FS.nodePermissions(lookup.node, \"x\");\n  if (errCode) {\n   throw new FS.ErrnoError(errCode);\n  }\n  FS.currentPath = lookup.path;\n },\n createDefaultDirectories: () => {\n  FS.mkdir(\"/tmp\");\n  FS.mkdir(\"/home\");\n  FS.mkdir(\"/home/web_user\");\n },\n createDefaultDevices: () => {\n  FS.mkdir(\"/dev\");\n  FS.registerDevice(FS.makedev(1, 3), {\n   read: () => 0,\n   write: (stream, buffer, offset, length, pos) => length\n  });\n  FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n  TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n  TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n  FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n  FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n  var random_device = getRandomDevice();\n  FS.createDevice(\"/dev\", \"random\", random_device);\n  FS.createDevice(\"/dev\", \"urandom\", random_device);\n  FS.mkdir(\"/dev/shm\");\n  FS.mkdir(\"/dev/shm/tmp\");\n },\n createSpecialDirectories: () => {\n  FS.mkdir(\"/proc\");\n  var proc_self = FS.mkdir(\"/proc/self\");\n  FS.mkdir(\"/proc/self/fd\");\n  FS.mount({\n   mount: () => {\n    var node = FS.createNode(proc_self, \"fd\", 16384 | 511, 73);\n    node.node_ops = {\n     lookup: (parent, name) => {\n      var fd = +name;\n      var stream = FS.getStream(fd);\n      if (!stream) throw new FS.ErrnoError(8);\n      var ret = {\n       parent: null,\n       mount: {\n        mountpoint: \"fake\"\n       },\n       node_ops: {\n        readlink: () => stream.path\n       }\n      };\n      ret.parent = ret;\n      return ret;\n     }\n    };\n    return node;\n   }\n  }, {}, \"/proc/self/fd\");\n },\n createStandardStreams: () => {\n  if (Module[\"stdin\"]) {\n   FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n  } else {\n   FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n  }\n  if (Module[\"stdout\"]) {\n   FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n  } else {\n   FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n  }\n  if (Module[\"stderr\"]) {\n   FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n  } else {\n   FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n  }\n  var stdin = FS.open(\"/dev/stdin\", 0);\n  var stdout = FS.open(\"/dev/stdout\", 1);\n  var stderr = FS.open(\"/dev/stderr\", 1);\n  assert(stdin.fd === 0, \"invalid handle for stdin (\" + stdin.fd + \")\");\n  assert(stdout.fd === 1, \"invalid handle for stdout (\" + stdout.fd + \")\");\n  assert(stderr.fd === 2, \"invalid handle for stderr (\" + stderr.fd + \")\");\n },\n ensureErrnoError: () => {\n  if (FS.ErrnoError) return;\n  FS.ErrnoError = function ErrnoError(errno, node) {\n   this.node = node;\n   this.setErrno = function(errno) {\n    this.errno = errno;\n    for (var key in ERRNO_CODES) {\n     if (ERRNO_CODES[key] === errno) {\n      this.code = key;\n      break;\n     }\n    }\n   };\n   this.setErrno(errno);\n   this.message = ERRNO_MESSAGES[errno];\n   if (this.stack) {\n    Object.defineProperty(this, \"stack\", {\n     value: new Error().stack,\n     writable: true\n    });\n    this.stack = demangleAll(this.stack);\n   }\n  };\n  FS.ErrnoError.prototype = new Error();\n  FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n  [ 44 ].forEach(code => {\n   FS.genericErrors[code] = new FS.ErrnoError(code);\n   FS.genericErrors[code].stack = \"<generic error, no stack>\";\n  });\n },\n staticInit: () => {\n  FS.ensureErrnoError();\n  FS.nameTable = new Array(4096);\n  FS.mount(MEMFS, {}, \"/\");\n  FS.createDefaultDirectories();\n  FS.createDefaultDevices();\n  FS.createSpecialDirectories();\n  FS.filesystems = {\n   \"MEMFS\": MEMFS\n  };\n },\n init: (input, output, error) => {\n  assert(!FS.init.initialized, \"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\");\n  FS.init.initialized = true;\n  FS.ensureErrnoError();\n  Module[\"stdin\"] = input || Module[\"stdin\"];\n  Module[\"stdout\"] = output || Module[\"stdout\"];\n  Module[\"stderr\"] = error || Module[\"stderr\"];\n  FS.createStandardStreams();\n },\n quit: () => {\n  FS.init.initialized = false;\n  ___stdio_exit();\n  for (var i = 0; i < FS.streams.length; i++) {\n   var stream = FS.streams[i];\n   if (!stream) {\n    continue;\n   }\n   FS.close(stream);\n  }\n },\n getMode: (canRead, canWrite) => {\n  var mode = 0;\n  if (canRead) mode |= 292 | 73;\n  if (canWrite) mode |= 146;\n  return mode;\n },\n findObject: (path, dontResolveLastLink) => {\n  var ret = FS.analyzePath(path, dontResolveLastLink);\n  if (ret.exists) {\n   return ret.object;\n  } else {\n   return null;\n  }\n },\n analyzePath: (path, dontResolveLastLink) => {\n  try {\n   var lookup = FS.lookupPath(path, {\n    follow: !dontResolveLastLink\n   });\n   path = lookup.path;\n  } catch (e) {}\n  var ret = {\n   isRoot: false,\n   exists: false,\n   error: 0,\n   name: null,\n   path: null,\n   object: null,\n   parentExists: false,\n   parentPath: null,\n   parentObject: null\n  };\n  try {\n   var lookup = FS.lookupPath(path, {\n    parent: true\n   });\n   ret.parentExists = true;\n   ret.parentPath = lookup.path;\n   ret.parentObject = lookup.node;\n   ret.name = PATH.basename(path);\n   lookup = FS.lookupPath(path, {\n    follow: !dontResolveLastLink\n   });\n   ret.exists = true;\n   ret.path = lookup.path;\n   ret.object = lookup.node;\n   ret.name = lookup.node.name;\n   ret.isRoot = lookup.path === \"/\";\n  } catch (e) {\n   ret.error = e.errno;\n  }\n  return ret;\n },\n createPath: (parent, path, canRead, canWrite) => {\n  parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\n  var parts = path.split(\"/\").reverse();\n  while (parts.length) {\n   var part = parts.pop();\n   if (!part) continue;\n   var current = PATH.join2(parent, part);\n   try {\n    FS.mkdir(current);\n   } catch (e) {}\n   parent = current;\n  }\n  return current;\n },\n createFile: (parent, name, properties, canRead, canWrite) => {\n  var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n  var mode = FS.getMode(canRead, canWrite);\n  return FS.create(path, mode);\n },\n createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {\n  var path = name;\n  if (parent) {\n   parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\n   path = name ? PATH.join2(parent, name) : parent;\n  }\n  var mode = FS.getMode(canRead, canWrite);\n  var node = FS.create(path, mode);\n  if (data) {\n   if (typeof data === \"string\") {\n    var arr = new Array(data.length);\n    for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n    data = arr;\n   }\n   FS.chmod(node, mode | 146);\n   var stream = FS.open(node, 577);\n   FS.write(stream, data, 0, data.length, 0, canOwn);\n   FS.close(stream);\n   FS.chmod(node, mode);\n  }\n  return node;\n },\n createDevice: (parent, name, input, output) => {\n  var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n  var mode = FS.getMode(!!input, !!output);\n  if (!FS.createDevice.major) FS.createDevice.major = 64;\n  var dev = FS.makedev(FS.createDevice.major++, 0);\n  FS.registerDevice(dev, {\n   open: stream => {\n    stream.seekable = false;\n   },\n   close: stream => {\n    if (output && output.buffer && output.buffer.length) {\n     output(10);\n    }\n   },\n   read: (stream, buffer, offset, length, pos) => {\n    var bytesRead = 0;\n    for (var i = 0; i < length; i++) {\n     var result;\n     try {\n      result = input();\n     } catch (e) {\n      throw new FS.ErrnoError(29);\n     }\n     if (result === undefined && bytesRead === 0) {\n      throw new FS.ErrnoError(6);\n     }\n     if (result === null || result === undefined) break;\n     bytesRead++;\n     buffer[offset + i] = result;\n    }\n    if (bytesRead) {\n     stream.node.timestamp = Date.now();\n    }\n    return bytesRead;\n   },\n   write: (stream, buffer, offset, length, pos) => {\n    for (var i = 0; i < length; i++) {\n     try {\n      output(buffer[offset + i]);\n     } catch (e) {\n      throw new FS.ErrnoError(29);\n     }\n    }\n    if (length) {\n     stream.node.timestamp = Date.now();\n    }\n    return i;\n   }\n  });\n  return FS.mkdev(path, mode, dev);\n },\n forceLoadFile: obj => {\n  if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n  if (typeof XMLHttpRequest !== \"undefined\") {\n   throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n  } else if (read_) {\n   try {\n    obj.contents = intArrayFromString(read_(obj.url), true);\n    obj.usedBytes = obj.contents.length;\n   } catch (e) {\n    throw new FS.ErrnoError(29);\n   }\n  } else {\n   throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n  }\n },\n createLazyFile: (parent, name, url, canRead, canWrite) => {\n  function LazyUint8Array() {\n   this.lengthKnown = false;\n   this.chunks = [];\n  }\n  LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n   if (idx > this.length - 1 || idx < 0) {\n    return undefined;\n   }\n   var chunkOffset = idx % this.chunkSize;\n   var chunkNum = idx / this.chunkSize | 0;\n   return this.getter(chunkNum)[chunkOffset];\n  };\n  LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n   this.getter = getter;\n  };\n  LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n   var xhr = new XMLHttpRequest();\n   xhr.open(\"HEAD\", url, false);\n   xhr.send(null);\n   if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n   var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n   var header;\n   var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n   var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n   var chunkSize = 1024 * 1024;\n   if (!hasByteServing) chunkSize = datalength;\n   var doXHR = (from, to) => {\n    if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n    if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n    if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n    xhr.responseType = \"arraybuffer\";\n    if (xhr.overrideMimeType) {\n     xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n    }\n    xhr.send(null);\n    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n    if (xhr.response !== undefined) {\n     return new Uint8Array(xhr.response || []);\n    } else {\n     return intArrayFromString(xhr.responseText || \"\", true);\n    }\n   };\n   var lazyArray = this;\n   lazyArray.setDataGetter(chunkNum => {\n    var start = chunkNum * chunkSize;\n    var end = (chunkNum + 1) * chunkSize - 1;\n    end = Math.min(end, datalength - 1);\n    if (typeof lazyArray.chunks[chunkNum] === \"undefined\") {\n     lazyArray.chunks[chunkNum] = doXHR(start, end);\n    }\n    if (typeof lazyArray.chunks[chunkNum] === \"undefined\") throw new Error(\"doXHR failed!\");\n    return lazyArray.chunks[chunkNum];\n   });\n   if (usesGzip || !datalength) {\n    chunkSize = datalength = 1;\n    datalength = this.getter(0).length;\n    chunkSize = datalength;\n    out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n   }\n   this._length = datalength;\n   this._chunkSize = chunkSize;\n   this.lengthKnown = true;\n  };\n  if (typeof XMLHttpRequest !== \"undefined\") {\n   if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n   var lazyArray = new LazyUint8Array();\n   Object.defineProperties(lazyArray, {\n    length: {\n     get: function() {\n      if (!this.lengthKnown) {\n       this.cacheLength();\n      }\n      return this._length;\n     }\n    },\n    chunkSize: {\n     get: function() {\n      if (!this.lengthKnown) {\n       this.cacheLength();\n      }\n      return this._chunkSize;\n     }\n    }\n   });\n   var properties = {\n    isDevice: false,\n    contents: lazyArray\n   };\n  } else {\n   var properties = {\n    isDevice: false,\n    url: url\n   };\n  }\n  var node = FS.createFile(parent, name, properties, canRead, canWrite);\n  if (properties.contents) {\n   node.contents = properties.contents;\n  } else if (properties.url) {\n   node.contents = null;\n   node.url = properties.url;\n  }\n  Object.defineProperties(node, {\n   usedBytes: {\n    get: function() {\n     return this.contents.length;\n    }\n   }\n  });\n  var stream_ops = {};\n  var keys = Object.keys(node.stream_ops);\n  keys.forEach(key => {\n   var fn = node.stream_ops[key];\n   stream_ops[key] = function forceLoadLazyFile() {\n    FS.forceLoadFile(node);\n    return fn.apply(null, arguments);\n   };\n  });\n  stream_ops.read = ((stream, buffer, offset, length, position) => {\n   FS.forceLoadFile(node);\n   var contents = stream.node.contents;\n   if (position >= contents.length) return 0;\n   var size = Math.min(contents.length - position, length);\n   assert(size >= 0);\n   if (contents.slice) {\n    for (var i = 0; i < size; i++) {\n     buffer[offset + i] = contents[position + i];\n    }\n   } else {\n    for (var i = 0; i < size; i++) {\n     buffer[offset + i] = contents.get(position + i);\n    }\n   }\n   return size;\n  });\n  node.stream_ops = stream_ops;\n  return node;\n },\n createPreloadedFile: (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\n  var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n  var dep = getUniqueRunDependency(\"cp \" + fullname);\n  function processData(byteArray) {\n   function finish(byteArray) {\n    if (preFinish) preFinish();\n    if (!dontCreateFile) {\n     FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n    }\n    if (onload) onload();\n    removeRunDependency(dep);\n   }\n   if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {\n    if (onerror) onerror();\n    removeRunDependency(dep);\n   })) {\n    return;\n   }\n   finish(byteArray);\n  }\n  addRunDependency(dep);\n  if (typeof url == \"string\") {\n   asyncLoad(url, byteArray => processData(byteArray), onerror);\n  } else {\n   processData(url);\n  }\n },\n indexedDB: () => {\n  return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n },\n DB_NAME: () => {\n  return \"EM_FS_\" + window.location.pathname;\n },\n DB_VERSION: 20,\n DB_STORE_NAME: \"FILE_DATA\",\n saveFilesToDB: (paths, onload, onerror) => {\n  onload = onload || (() => {});\n  onerror = onerror || (() => {});\n  var indexedDB = FS.indexedDB();\n  try {\n   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n  } catch (e) {\n   return onerror(e);\n  }\n  openRequest.onupgradeneeded = (() => {\n   out(\"creating db\");\n   var db = openRequest.result;\n   db.createObjectStore(FS.DB_STORE_NAME);\n  });\n  openRequest.onsuccess = (() => {\n   var db = openRequest.result;\n   var transaction = db.transaction([ FS.DB_STORE_NAME ], \"readwrite\");\n   var files = transaction.objectStore(FS.DB_STORE_NAME);\n   var ok = 0, fail = 0, total = paths.length;\n   function finish() {\n    if (fail == 0) onload(); else onerror();\n   }\n   paths.forEach(path => {\n    var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n    putRequest.onsuccess = (() => {\n     ok++;\n     if (ok + fail == total) finish();\n    });\n    putRequest.onerror = (() => {\n     fail++;\n     if (ok + fail == total) finish();\n    });\n   });\n   transaction.onerror = onerror;\n  });\n  openRequest.onerror = onerror;\n },\n loadFilesFromDB: (paths, onload, onerror) => {\n  onload = onload || (() => {});\n  onerror = onerror || (() => {});\n  var indexedDB = FS.indexedDB();\n  try {\n   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n  } catch (e) {\n   return onerror(e);\n  }\n  openRequest.onupgradeneeded = onerror;\n  openRequest.onsuccess = (() => {\n   var db = openRequest.result;\n   try {\n    var transaction = db.transaction([ FS.DB_STORE_NAME ], \"readonly\");\n   } catch (e) {\n    onerror(e);\n    return;\n   }\n   var files = transaction.objectStore(FS.DB_STORE_NAME);\n   var ok = 0, fail = 0, total = paths.length;\n   function finish() {\n    if (fail == 0) onload(); else onerror();\n   }\n   paths.forEach(path => {\n    var getRequest = files.get(path);\n    getRequest.onsuccess = (() => {\n     if (FS.analyzePath(path).exists) {\n      FS.unlink(path);\n     }\n     FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n     ok++;\n     if (ok + fail == total) finish();\n    });\n    getRequest.onerror = (() => {\n     fail++;\n     if (ok + fail == total) finish();\n    });\n   });\n   transaction.onerror = onerror;\n  });\n  openRequest.onerror = onerror;\n },\n absolutePath: () => {\n  abort(\"FS.absolutePath has been removed; use PATH_FS.resolve instead\");\n },\n createFolder: () => {\n  abort(\"FS.createFolder has been removed; use FS.mkdir instead\");\n },\n createLink: () => {\n  abort(\"FS.createLink has been removed; use FS.symlink instead\");\n },\n joinPath: () => {\n  abort(\"FS.joinPath has been removed; use PATH.join instead\");\n },\n mmapAlloc: () => {\n  abort(\"FS.mmapAlloc has been replaced by the top level function mmapAlloc\");\n },\n standardizePath: () => {\n  abort(\"FS.standardizePath has been removed; use PATH.normalize instead\");\n }\n};\n\nvar SYSCALLS = {\n mappings: {},\n DEFAULT_POLLMASK: 5,\n calculateAt: function(dirfd, path, allowEmpty) {\n  if (path[0] === \"/\") {\n   return path;\n  }\n  var dir;\n  if (dirfd === -100) {\n   dir = FS.cwd();\n  } else {\n   var dirstream = FS.getStream(dirfd);\n   if (!dirstream) throw new FS.ErrnoError(8);\n   dir = dirstream.path;\n  }\n  if (path.length == 0) {\n   if (!allowEmpty) {\n    throw new FS.ErrnoError(44);\n   }\n   return dir;\n  }\n  return PATH.join2(dir, path);\n },\n doStat: function(func, path, buf) {\n  try {\n   var stat = func(path);\n  } catch (e) {\n   if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n    return -54;\n   }\n   throw e;\n  }\n  _asan_js_store_4(buf >> 2, stat.dev);\n  _asan_js_store_4(buf + 4 >> 2, 0);\n  _asan_js_store_4(buf + 8 >> 2, stat.ino);\n  _asan_js_store_4(buf + 12 >> 2, stat.mode);\n  _asan_js_store_4(buf + 16 >> 2, stat.nlink);\n  _asan_js_store_4(buf + 20 >> 2, stat.uid);\n  _asan_js_store_4(buf + 24 >> 2, stat.gid);\n  _asan_js_store_4(buf + 28 >> 2, stat.rdev);\n  _asan_js_store_4(buf + 32 >> 2, 0);\n  tempI64 = [ stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  _asan_js_store_4(buf + 40 >> 2, tempI64[0]), _asan_js_store_4(buf + 44 >> 2, tempI64[1]);\n  _asan_js_store_4(buf + 48 >> 2, 4096);\n  _asan_js_store_4(buf + 52 >> 2, stat.blocks);\n  _asan_js_store_4(buf + 56 >> 2, stat.atime.getTime() / 1e3 | 0);\n  _asan_js_store_4(buf + 60 >> 2, 0);\n  _asan_js_store_4(buf + 64 >> 2, stat.mtime.getTime() / 1e3 | 0);\n  _asan_js_store_4(buf + 68 >> 2, 0);\n  _asan_js_store_4(buf + 72 >> 2, stat.ctime.getTime() / 1e3 | 0);\n  _asan_js_store_4(buf + 76 >> 2, 0);\n  tempI64 = [ stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], \n  _asan_js_store_4(buf + 80 >> 2, tempI64[0]), _asan_js_store_4(buf + 84 >> 2, tempI64[1]);\n  return 0;\n },\n doMsync: function(addr, stream, len, flags, offset) {\n  var buffer = HEAPU8.slice(addr, addr + len);\n  FS.msync(stream, buffer, offset, len, flags);\n },\n doMkdir: function(path, mode) {\n  path = PATH.normalize(path);\n  if (path[path.length - 1] === \"/\") path = path.substr(0, path.length - 1);\n  FS.mkdir(path, mode, 0);\n  return 0;\n },\n doMknod: function(path, mode, dev) {\n  switch (mode & 61440) {\n  case 32768:\n  case 8192:\n  case 24576:\n  case 4096:\n  case 49152:\n   break;\n\n  default:\n   return -28;\n  }\n  FS.mknod(path, mode, dev);\n  return 0;\n },\n doReadlink: function(path, buf, bufsize) {\n  if (bufsize <= 0) return -28;\n  var ret = FS.readlink(path);\n  var len = Math.min(bufsize, lengthBytesUTF8(ret));\n  var endChar = _asan_js_load_1(buf + len);\n  stringToUTF8(ret, buf, bufsize + 1);\n  _asan_js_store_1(buf + len, endChar);\n  return len;\n },\n doAccess: function(path, amode) {\n  if (amode & ~7) {\n   return -28;\n  }\n  var lookup = FS.lookupPath(path, {\n   follow: true\n  });\n  var node = lookup.node;\n  if (!node) {\n   return -44;\n  }\n  var perms = \"\";\n  if (amode & 4) perms += \"r\";\n  if (amode & 2) perms += \"w\";\n  if (amode & 1) perms += \"x\";\n  if (perms && FS.nodePermissions(node, perms)) {\n   return -2;\n  }\n  return 0;\n },\n doDup: function(path, flags, suggestFD) {\n  var suggest = FS.getStream(suggestFD);\n  if (suggest) FS.close(suggest);\n  return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n },\n doReadv: function(stream, iov, iovcnt, offset) {\n  var ret = 0;\n  for (var i = 0; i < iovcnt; i++) {\n   var ptr = _asan_js_load_4(iov + i * 8 >> 2);\n   var len = _asan_js_load_4(iov + (i * 8 + 4) >> 2);\n   var curr = FS.read(stream, HEAP8, ptr, len, offset);\n   if (curr < 0) return -1;\n   ret += curr;\n   if (curr < len) break;\n  }\n  return ret;\n },\n doWritev: function(stream, iov, iovcnt, offset) {\n  var ret = 0;\n  for (var i = 0; i < iovcnt; i++) {\n   var ptr = _asan_js_load_4(iov + i * 8 >> 2);\n   var len = _asan_js_load_4(iov + (i * 8 + 4) >> 2);\n   var curr = FS.write(stream, HEAP8, ptr, len, offset);\n   if (curr < 0) return -1;\n   ret += curr;\n  }\n  return ret;\n },\n varargs: undefined,\n get: function() {\n  assert(SYSCALLS.varargs != undefined);\n  SYSCALLS.varargs += 4;\n  var ret = _asan_js_load_4(SYSCALLS.varargs - 4 >> 2);\n  return ret;\n },\n getStr: function(ptr) {\n  var ret = UTF8ToString(ptr);\n  return ret;\n },\n getStreamFromFD: function(fd) {\n  var stream = FS.getStream(fd);\n  if (!stream) throw new FS.ErrnoError(8);\n  return stream;\n },\n get64: function(low, high) {\n  if (low >= 0) assert(high === 0); else assert(high === -1);\n  return low;\n }\n};\n\nfunction ___syscall_dup(fd) {\n try {\n  var old = SYSCALLS.getStreamFromFD(fd);\n  return FS.open(old.path, old.flags, 0).fd;\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\n  return -e.errno;\n }\n}\n\nfunction ___syscall_open(path, flags, varargs) {\n SYSCALLS.varargs = varargs;\n try {\n  var pathname = SYSCALLS.getStr(path);\n  var mode = varargs ? SYSCALLS.get() : 0;\n  var stream = FS.open(pathname, flags, mode);\n  return stream.fd;\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\n  return -e.errno;\n }\n}\n\nfunction ___syscall_stat64(path, buf) {\n try {\n  path = SYSCALLS.getStr(path);\n  return SYSCALLS.doStat(FS.stat, path, buf);\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\n  return -e.errno;\n }\n}\n\nfunction __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\n\nfunction getShiftFromSize(size) {\n switch (size) {\n case 1:\n  return 0;\n\n case 2:\n  return 1;\n\n case 4:\n  return 2;\n\n case 8:\n  return 3;\n\n default:\n  throw new TypeError(\"Unknown type size: \" + size);\n }\n}\n\nfunction embind_init_charCodes() {\n var codes = new Array(256);\n for (var i = 0; i < 256; ++i) {\n  codes[i] = String.fromCharCode(i);\n }\n embind_charCodes = codes;\n}\n\nvar embind_charCodes = undefined;\n\nfunction readLatin1String(ptr) {\n var ret = \"\";\n var c = ptr;\n while (_asan_js_load_1u(c)) {\n  ret += embind_charCodes[_asan_js_load_1u(c++)];\n }\n return ret;\n}\n\nvar awaitingDependencies = {};\n\nvar registeredTypes = {};\n\nvar typeDependencies = {};\n\nvar char_0 = 48;\n\nvar char_9 = 57;\n\nfunction makeLegalFunctionName(name) {\n if (undefined === name) {\n  return \"_unknown\";\n }\n name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n var f = name.charCodeAt(0);\n if (f >= char_0 && f <= char_9) {\n  return \"_\" + name;\n } else {\n  return name;\n }\n}\n\nfunction createNamedFunction(name, body) {\n name = makeLegalFunctionName(name);\n return new Function(\"body\", \"return function \" + name + \"() {\\n\" + '    \"use strict\";' + \"    return body.apply(this, arguments);\\n\" + \"};\\n\")(body);\n}\n\nfunction extendError(baseErrorType, errorName) {\n var errorClass = createNamedFunction(errorName, function(message) {\n  this.name = errorName;\n  this.message = message;\n  var stack = new Error(message).stack;\n  if (stack !== undefined) {\n   this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n  }\n });\n errorClass.prototype = Object.create(baseErrorType.prototype);\n errorClass.prototype.constructor = errorClass;\n errorClass.prototype.toString = function() {\n  if (this.message === undefined) {\n   return this.name;\n  } else {\n   return this.name + \": \" + this.message;\n  }\n };\n return errorClass;\n}\n\nvar BindingError = undefined;\n\nfunction throwBindingError(message) {\n throw new BindingError(message);\n}\n\nvar InternalError = undefined;\n\nfunction throwInternalError(message) {\n throw new InternalError(message);\n}\n\nfunction whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n myTypes.forEach(function(type) {\n  typeDependencies[type] = dependentTypes;\n });\n function onComplete(typeConverters) {\n  var myTypeConverters = getTypeConverters(typeConverters);\n  if (myTypeConverters.length !== myTypes.length) {\n   throwInternalError(\"Mismatched type converter count\");\n  }\n  for (var i = 0; i < myTypes.length; ++i) {\n   registerType(myTypes[i], myTypeConverters[i]);\n  }\n }\n var typeConverters = new Array(dependentTypes.length);\n var unregisteredTypes = [];\n var registered = 0;\n dependentTypes.forEach(function(dt, i) {\n  if (registeredTypes.hasOwnProperty(dt)) {\n   typeConverters[i] = registeredTypes[dt];\n  } else {\n   unregisteredTypes.push(dt);\n   if (!awaitingDependencies.hasOwnProperty(dt)) {\n    awaitingDependencies[dt] = [];\n   }\n   awaitingDependencies[dt].push(function() {\n    typeConverters[i] = registeredTypes[dt];\n    ++registered;\n    if (registered === unregisteredTypes.length) {\n     onComplete(typeConverters);\n    }\n   });\n  }\n });\n if (0 === unregisteredTypes.length) {\n  onComplete(typeConverters);\n }\n}\n\nfunction registerType(rawType, registeredInstance, options = {}) {\n if (!(\"argPackAdvance\" in registeredInstance)) {\n  throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n }\n var name = registeredInstance.name;\n if (!rawType) {\n  throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n }\n if (registeredTypes.hasOwnProperty(rawType)) {\n  if (options.ignoreDuplicateRegistrations) {\n   return;\n  } else {\n   throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n  }\n }\n registeredTypes[rawType] = registeredInstance;\n delete typeDependencies[rawType];\n if (awaitingDependencies.hasOwnProperty(rawType)) {\n  var callbacks = awaitingDependencies[rawType];\n  delete awaitingDependencies[rawType];\n  callbacks.forEach(function(cb) {\n   cb();\n  });\n }\n}\n\nfunction __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n var shift = getShiftFromSize(size);\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(wt) {\n   return !!wt;\n  },\n  \"toWireType\": function(destructors, o) {\n   return o ? trueValue : falseValue;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": function(pointer) {\n   var heap;\n   if (size === 1) {\n    heap = HEAP8;\n   } else if (size === 2) {\n    heap = HEAP16;\n   } else if (size === 4) {\n    heap = HEAP32;\n   } else {\n    throw new TypeError(\"Unknown boolean type size: \" + name);\n   }\n   return this[\"fromWireType\"](heap[pointer >> shift]);\n  },\n  destructorFunction: null\n });\n}\n\nfunction ClassHandle_isAliasOf(other) {\n if (!(this instanceof ClassHandle)) {\n  return false;\n }\n if (!(other instanceof ClassHandle)) {\n  return false;\n }\n var leftClass = this.$$.ptrType.registeredClass;\n var left = this.$$.ptr;\n var rightClass = other.$$.ptrType.registeredClass;\n var right = other.$$.ptr;\n while (leftClass.baseClass) {\n  left = leftClass.upcast(left);\n  leftClass = leftClass.baseClass;\n }\n while (rightClass.baseClass) {\n  right = rightClass.upcast(right);\n  rightClass = rightClass.baseClass;\n }\n return leftClass === rightClass && left === right;\n}\n\nfunction shallowCopyInternalPointer(o) {\n return {\n  count: o.count,\n  deleteScheduled: o.deleteScheduled,\n  preservePointerOnDelete: o.preservePointerOnDelete,\n  ptr: o.ptr,\n  ptrType: o.ptrType,\n  smartPtr: o.smartPtr,\n  smartPtrType: o.smartPtrType\n };\n}\n\nfunction throwInstanceAlreadyDeleted(obj) {\n function getInstanceTypeName(handle) {\n  return handle.$$.ptrType.registeredClass.name;\n }\n throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n}\n\nvar finalizationRegistry = false;\n\nfunction detachFinalizer(handle) {}\n\nfunction runDestructor($$) {\n if ($$.smartPtr) {\n  $$.smartPtrType.rawDestructor($$.smartPtr);\n } else {\n  $$.ptrType.registeredClass.rawDestructor($$.ptr);\n }\n}\n\nfunction releaseClassHandle($$) {\n $$.count.value -= 1;\n var toDelete = 0 === $$.count.value;\n if (toDelete) {\n  runDestructor($$);\n }\n}\n\nfunction downcastPointer(ptr, ptrClass, desiredClass) {\n if (ptrClass === desiredClass) {\n  return ptr;\n }\n if (undefined === desiredClass.baseClass) {\n  return null;\n }\n var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n if (rv === null) {\n  return null;\n }\n return desiredClass.downcast(rv);\n}\n\nvar registeredPointers = {};\n\nfunction getInheritedInstanceCount() {\n return Object.keys(registeredInstances).length;\n}\n\nfunction getLiveInheritedInstances() {\n var rv = [];\n for (var k in registeredInstances) {\n  if (registeredInstances.hasOwnProperty(k)) {\n   rv.push(registeredInstances[k]);\n  }\n }\n return rv;\n}\n\nvar deletionQueue = [];\n\nfunction flushPendingDeletes() {\n while (deletionQueue.length) {\n  var obj = deletionQueue.pop();\n  obj.$$.deleteScheduled = false;\n  obj[\"delete\"]();\n }\n}\n\nvar delayFunction = undefined;\n\nfunction setDelayFunction(fn) {\n delayFunction = fn;\n if (deletionQueue.length && delayFunction) {\n  delayFunction(flushPendingDeletes);\n }\n}\n\nfunction init_embind() {\n Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n Module[\"setDelayFunction\"] = setDelayFunction;\n}\n\nvar registeredInstances = {};\n\nfunction getBasestPointer(class_, ptr) {\n if (ptr === undefined) {\n  throwBindingError(\"ptr should not be undefined\");\n }\n while (class_.baseClass) {\n  ptr = class_.upcast(ptr);\n  class_ = class_.baseClass;\n }\n return ptr;\n}\n\nfunction getInheritedInstance(class_, ptr) {\n ptr = getBasestPointer(class_, ptr);\n return registeredInstances[ptr];\n}\n\nfunction makeClassHandle(prototype, record) {\n if (!record.ptrType || !record.ptr) {\n  throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n }\n var hasSmartPtrType = !!record.smartPtrType;\n var hasSmartPtr = !!record.smartPtr;\n if (hasSmartPtrType !== hasSmartPtr) {\n  throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n }\n record.count = {\n  value: 1\n };\n return attachFinalizer(Object.create(prototype, {\n  $$: {\n   value: record\n  }\n }));\n}\n\nfunction RegisteredPointer_fromWireType(ptr) {\n var rawPointer = this.getPointee(ptr);\n if (!rawPointer) {\n  this.destructor(ptr);\n  return null;\n }\n var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n if (undefined !== registeredInstance) {\n  if (0 === registeredInstance.$$.count.value) {\n   registeredInstance.$$.ptr = rawPointer;\n   registeredInstance.$$.smartPtr = ptr;\n   return registeredInstance[\"clone\"]();\n  } else {\n   var rv = registeredInstance[\"clone\"]();\n   this.destructor(ptr);\n   return rv;\n  }\n }\n function makeDefaultHandle() {\n  if (this.isSmartPointer) {\n   return makeClassHandle(this.registeredClass.instancePrototype, {\n    ptrType: this.pointeeType,\n    ptr: rawPointer,\n    smartPtrType: this,\n    smartPtr: ptr\n   });\n  } else {\n   return makeClassHandle(this.registeredClass.instancePrototype, {\n    ptrType: this,\n    ptr: ptr\n   });\n  }\n }\n var actualType = this.registeredClass.getActualType(rawPointer);\n var registeredPointerRecord = registeredPointers[actualType];\n if (!registeredPointerRecord) {\n  return makeDefaultHandle.call(this);\n }\n var toType;\n if (this.isConst) {\n  toType = registeredPointerRecord.constPointerType;\n } else {\n  toType = registeredPointerRecord.pointerType;\n }\n var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n if (dp === null) {\n  return makeDefaultHandle.call(this);\n }\n if (this.isSmartPointer) {\n  return makeClassHandle(toType.registeredClass.instancePrototype, {\n   ptrType: toType,\n   ptr: dp,\n   smartPtrType: this,\n   smartPtr: ptr\n  });\n } else {\n  return makeClassHandle(toType.registeredClass.instancePrototype, {\n   ptrType: toType,\n   ptr: dp\n  });\n }\n}\n\nfunction attachFinalizer(handle) {\n if (\"undefined\" === typeof FinalizationRegistry) {\n  attachFinalizer = (handle => handle);\n  return handle;\n }\n finalizationRegistry = new FinalizationRegistry(info => {\n  console.warn(info.leakWarning.stack.replace(/^Error: /, \"\"));\n  releaseClassHandle(info.$$);\n });\n attachFinalizer = (handle => {\n  var $$ = handle.$$;\n  var hasSmartPtr = !!$$.smartPtr;\n  if (hasSmartPtr) {\n   var info = {\n    $$: $$\n   };\n   var cls = $$.ptrType.registeredClass;\n   info.leakWarning = new Error(\"Embind found a leaked C++ instance \" + cls.name + \" <0x\" + $$.ptr.toString(16) + \">.\\n\" + \"We'll free it automatically in this case, but this functionality is not reliable across various environments.\\n\" + \"Make sure to invoke .delete() manually once you're done with the instance instead.\\n\" + \"Originally allocated\");\n   if (\"captureStackTrace\" in Error) {\n    Error.captureStackTrace(info.leakWarning, RegisteredPointer_fromWireType);\n   }\n   finalizationRegistry.register(handle, info, handle);\n  }\n  return handle;\n });\n detachFinalizer = (handle => finalizationRegistry.unregister(handle));\n return attachFinalizer(handle);\n}\n\nfunction ClassHandle_clone() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.preservePointerOnDelete) {\n  this.$$.count.value += 1;\n  return this;\n } else {\n  var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n   $$: {\n    value: shallowCopyInternalPointer(this.$$)\n   }\n  }));\n  clone.$$.count.value += 1;\n  clone.$$.deleteScheduled = false;\n  return clone;\n }\n}\n\nfunction ClassHandle_delete() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n  throwBindingError(\"Object already scheduled for deletion\");\n }\n detachFinalizer(this);\n releaseClassHandle(this.$$);\n if (!this.$$.preservePointerOnDelete) {\n  this.$$.smartPtr = undefined;\n  this.$$.ptr = undefined;\n }\n}\n\nfunction ClassHandle_isDeleted() {\n return !this.$$.ptr;\n}\n\nfunction ClassHandle_deleteLater() {\n if (!this.$$.ptr) {\n  throwInstanceAlreadyDeleted(this);\n }\n if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n  throwBindingError(\"Object already scheduled for deletion\");\n }\n deletionQueue.push(this);\n if (deletionQueue.length === 1 && delayFunction) {\n  delayFunction(flushPendingDeletes);\n }\n this.$$.deleteScheduled = true;\n return this;\n}\n\nfunction init_ClassHandle() {\n ClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\n ClassHandle.prototype[\"clone\"] = ClassHandle_clone;\n ClassHandle.prototype[\"delete\"] = ClassHandle_delete;\n ClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\n ClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater;\n}\n\nfunction ClassHandle() {}\n\nfunction ensureOverloadTable(proto, methodName, humanName) {\n if (undefined === proto[methodName].overloadTable) {\n  var prevFunc = proto[methodName];\n  proto[methodName] = function() {\n   if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n    throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n   }\n   return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n  };\n  proto[methodName].overloadTable = [];\n  proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n }\n}\n\nfunction exposePublicSymbol(name, value, numArguments) {\n if (Module.hasOwnProperty(name)) {\n  if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n   throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n  }\n  ensureOverloadTable(Module, name, name);\n  if (Module.hasOwnProperty(numArguments)) {\n   throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n  }\n  Module[name].overloadTable[numArguments] = value;\n } else {\n  Module[name] = value;\n  if (undefined !== numArguments) {\n   Module[name].numArguments = numArguments;\n  }\n }\n}\n\nfunction RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n this.name = name;\n this.constructor = constructor;\n this.instancePrototype = instancePrototype;\n this.rawDestructor = rawDestructor;\n this.baseClass = baseClass;\n this.getActualType = getActualType;\n this.upcast = upcast;\n this.downcast = downcast;\n this.pureVirtualFunctions = [];\n}\n\nfunction upcastPointer(ptr, ptrClass, desiredClass) {\n while (ptrClass !== desiredClass) {\n  if (!ptrClass.upcast) {\n   throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n  }\n  ptr = ptrClass.upcast(ptr);\n  ptrClass = ptrClass.baseClass;\n }\n return ptr;\n}\n\nfunction constNoSmartPtrRawPointerToWireType(destructors, handle) {\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  return 0;\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n return ptr;\n}\n\nfunction genericPointerToWireType(destructors, handle) {\n var ptr;\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  if (this.isSmartPointer) {\n   ptr = this.rawConstructor();\n   if (destructors !== null) {\n    destructors.push(this.rawDestructor, ptr);\n   }\n   return ptr;\n  } else {\n   return 0;\n  }\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n if (!this.isConst && handle.$$.ptrType.isConst) {\n  throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n if (this.isSmartPointer) {\n  if (undefined === handle.$$.smartPtr) {\n   throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n  }\n  switch (this.sharingPolicy) {\n  case 0:\n   if (handle.$$.smartPtrType === this) {\n    ptr = handle.$$.smartPtr;\n   } else {\n    throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n   }\n   break;\n\n  case 1:\n   ptr = handle.$$.smartPtr;\n   break;\n\n  case 2:\n   if (handle.$$.smartPtrType === this) {\n    ptr = handle.$$.smartPtr;\n   } else {\n    var clonedHandle = handle[\"clone\"]();\n    ptr = this.rawShare(ptr, Emval.toHandle(function() {\n     clonedHandle[\"delete\"]();\n    }));\n    if (destructors !== null) {\n     destructors.push(this.rawDestructor, ptr);\n    }\n   }\n   break;\n\n  default:\n   throwBindingError(\"Unsupporting sharing policy\");\n  }\n }\n return ptr;\n}\n\nfunction nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n if (handle === null) {\n  if (this.isReference) {\n   throwBindingError(\"null is not a valid \" + this.name);\n  }\n  return 0;\n }\n if (!handle.$$) {\n  throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n }\n if (!handle.$$.ptr) {\n  throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n }\n if (handle.$$.ptrType.isConst) {\n  throwBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name);\n }\n var handleClass = handle.$$.ptrType.registeredClass;\n var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n return ptr;\n}\n\nfunction simpleReadValueFromPointer(pointer) {\n return this[\"fromWireType\"](_asan_js_load_4u(pointer >> 2));\n}\n\nfunction RegisteredPointer_getPointee(ptr) {\n if (this.rawGetPointee) {\n  ptr = this.rawGetPointee(ptr);\n }\n return ptr;\n}\n\nfunction RegisteredPointer_destructor(ptr) {\n if (this.rawDestructor) {\n  this.rawDestructor(ptr);\n }\n}\n\nfunction RegisteredPointer_deleteObject(handle) {\n if (handle !== null) {\n  handle[\"delete\"]();\n }\n}\n\nfunction init_RegisteredPointer() {\n RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n RegisteredPointer.prototype[\"argPackAdvance\"] = 8;\n RegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\n RegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\n RegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType;\n}\n\nfunction RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n this.name = name;\n this.registeredClass = registeredClass;\n this.isReference = isReference;\n this.isConst = isConst;\n this.isSmartPointer = isSmartPointer;\n this.pointeeType = pointeeType;\n this.sharingPolicy = sharingPolicy;\n this.rawGetPointee = rawGetPointee;\n this.rawConstructor = rawConstructor;\n this.rawShare = rawShare;\n this.rawDestructor = rawDestructor;\n if (!isSmartPointer && registeredClass.baseClass === undefined) {\n  if (isConst) {\n   this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n   this.destructorFunction = null;\n  } else {\n   this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n   this.destructorFunction = null;\n  }\n } else {\n  this[\"toWireType\"] = genericPointerToWireType;\n }\n}\n\nfunction replacePublicSymbol(name, value, numArguments) {\n if (!Module.hasOwnProperty(name)) {\n  throwInternalError(\"Replacing nonexistant public symbol\");\n }\n if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n  Module[name].overloadTable[numArguments] = value;\n } else {\n  Module[name] = value;\n  Module[name].argCount = numArguments;\n }\n}\n\nfunction dynCallLegacy(sig, ptr, args) {\n assert(\"dynCall_\" + sig in Module, \"bad function pointer type - no table for sig '\" + sig + \"'\");\n if (args && args.length) {\n  assert(args.length === sig.substring(1).replace(/j/g, \"--\").length);\n } else {\n  assert(sig.length == 1);\n }\n var f = Module[\"dynCall_\" + sig];\n return args && args.length ? f.apply(null, [ ptr ].concat(args)) : f.call(null, ptr);\n}\n\nfunction dynCall(sig, ptr, args) {\n if (sig.includes(\"j\")) {\n  return dynCallLegacy(sig, ptr, args);\n }\n assert(getWasmTableEntry(ptr), \"missing table entry in dynCall: \" + ptr);\n return getWasmTableEntry(ptr).apply(null, args);\n}\n\nfunction getDynCaller(sig, ptr) {\n assert(sig.includes(\"j\"), \"getDynCaller should only be called with i64 sigs\");\n var argCache = [];\n return function() {\n  argCache.length = 0;\n  Object.assign(argCache, arguments);\n  return dynCall(sig, ptr, argCache);\n };\n}\n\nfunction embind__requireFunction(signature, rawFunction) {\n signature = readLatin1String(signature);\n function makeDynCaller() {\n  if (signature.includes(\"j\")) {\n   return getDynCaller(signature, rawFunction);\n  }\n  return getWasmTableEntry(rawFunction);\n }\n var fp = makeDynCaller();\n if (typeof fp !== \"function\") {\n  throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n }\n return fp;\n}\n\nvar UnboundTypeError = undefined;\n\nfunction getTypeName(type) {\n var ptr = ___getTypeName(type);\n var rv = readLatin1String(ptr);\n _free(ptr);\n return rv;\n}\n\nfunction throwUnboundTypeError(message, types) {\n var unboundTypes = [];\n var seen = {};\n function visit(type) {\n  if (seen[type]) {\n   return;\n  }\n  if (registeredTypes[type]) {\n   return;\n  }\n  if (typeDependencies[type]) {\n   typeDependencies[type].forEach(visit);\n   return;\n  }\n  unboundTypes.push(type);\n  seen[type] = true;\n }\n types.forEach(visit);\n throw new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([ \", \" ]));\n}\n\nfunction __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n name = readLatin1String(name);\n getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n if (upcast) {\n  upcast = embind__requireFunction(upcastSignature, upcast);\n }\n if (downcast) {\n  downcast = embind__requireFunction(downcastSignature, downcast);\n }\n rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n var legalFunctionName = makeLegalFunctionName(name);\n exposePublicSymbol(legalFunctionName, function() {\n  throwUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [ baseClassRawType ]);\n });\n whenDependentTypesAreResolved([ rawType, rawPointerType, rawConstPointerType ], baseClassRawType ? [ baseClassRawType ] : [], function(base) {\n  base = base[0];\n  var baseClass;\n  var basePrototype;\n  if (baseClassRawType) {\n   baseClass = base.registeredClass;\n   basePrototype = baseClass.instancePrototype;\n  } else {\n   basePrototype = ClassHandle.prototype;\n  }\n  var constructor = createNamedFunction(legalFunctionName, function() {\n   if (Object.getPrototypeOf(this) !== instancePrototype) {\n    throw new BindingError(\"Use 'new' to construct \" + name);\n   }\n   if (undefined === registeredClass.constructor_body) {\n    throw new BindingError(name + \" has no accessible constructor\");\n   }\n   var body = registeredClass.constructor_body[arguments.length];\n   if (undefined === body) {\n    throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n   }\n   return body.apply(this, arguments);\n  });\n  var instancePrototype = Object.create(basePrototype, {\n   constructor: {\n    value: constructor\n   }\n  });\n  constructor.prototype = instancePrototype;\n  var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n  var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n  var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n  var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n  registeredPointers[rawType] = {\n   pointerType: pointerConverter,\n   constPointerType: constPointerConverter\n  };\n  replacePublicSymbol(legalFunctionName, constructor);\n  return [ referenceConverter, pointerConverter, constPointerConverter ];\n });\n}\n\nfunction heap32VectorToArray(count, firstElement) {\n var array = [];\n for (var i = 0; i < count; i++) {\n  array.push(_asan_js_load_4((firstElement >> 2) + i));\n }\n return array;\n}\n\nfunction runDestructors(destructors) {\n while (destructors.length) {\n  var ptr = destructors.pop();\n  var del = destructors.pop();\n  del(ptr);\n }\n}\n\nfunction __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n assert(argCount > 0);\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n invoker = embind__requireFunction(invokerSignature, invoker);\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = \"constructor \" + classType.name;\n  if (undefined === classType.registeredClass.constructor_body) {\n   classType.registeredClass.constructor_body = [];\n  }\n  if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n   throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n  }\n  classType.registeredClass.constructor_body[argCount - 1] = (() => {\n   throwUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes);\n  });\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n   argTypes.splice(1, 0, null);\n   classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n   return [];\n  });\n  return [];\n });\n}\n\nfunction new_(constructor, argumentList) {\n if (!(constructor instanceof Function)) {\n  throw new TypeError(\"new_ called with constructor type \" + typeof constructor + \" which is not a function\");\n }\n var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {});\n dummy.prototype = constructor.prototype;\n var obj = new dummy();\n var r = constructor.apply(obj, argumentList);\n return r instanceof Object ? r : obj;\n}\n\nfunction craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n var argCount = argTypes.length;\n if (argCount < 2) {\n  throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n }\n var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n var needsDestructorStack = false;\n for (var i = 1; i < argTypes.length; ++i) {\n  if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n   needsDestructorStack = true;\n   break;\n  }\n }\n var returns = argTypes[0].name !== \"void\";\n var argsList = \"\";\n var argsListWired = \"\";\n for (var i = 0; i < argCount - 2; ++i) {\n  argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n  argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n }\n var invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\n\" + \"if (arguments.length !== \" + (argCount - 2) + \") {\\n\" + \"throwBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n\" + \"}\\n\";\n if (needsDestructorStack) {\n  invokerFnBody += \"var destructors = [];\\n\";\n }\n var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n var args1 = [ \"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\" ];\n var args2 = [ throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1] ];\n if (isClassMethodFunc) {\n  invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n }\n for (var i = 0; i < argCount - 2; ++i) {\n  invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n  args1.push(\"argType\" + i);\n  args2.push(argTypes[i + 2]);\n }\n if (isClassMethodFunc) {\n  argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n }\n invokerFnBody += (returns ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n if (needsDestructorStack) {\n  invokerFnBody += \"runDestructors(destructors);\\n\";\n } else {\n  for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n   var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n   if (argTypes[i].destructorFunction !== null) {\n    invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n    args1.push(paramName + \"_dtor\");\n    args2.push(argTypes[i].destructorFunction);\n   }\n  }\n }\n if (returns) {\n  invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n } else {}\n invokerFnBody += \"}\\n\";\n args1.push(invokerFnBody);\n var invokerFunction = new_(Function, args1).apply(null, args2);\n return invokerFunction;\n}\n\nfunction __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {\n var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n methodName = readLatin1String(methodName);\n rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n whenDependentTypesAreResolved([], [ rawClassType ], function(classType) {\n  classType = classType[0];\n  var humanName = classType.name + \".\" + methodName;\n  if (methodName.startsWith(\"@@\")) {\n   methodName = Symbol[methodName.substring(2)];\n  }\n  if (isPureVirtual) {\n   classType.registeredClass.pureVirtualFunctions.push(methodName);\n  }\n  function unboundTypesHandler() {\n   throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n  }\n  var proto = classType.registeredClass.instancePrototype;\n  var method = proto[methodName];\n  if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n   unboundTypesHandler.argCount = argCount - 2;\n   unboundTypesHandler.className = classType.name;\n   proto[methodName] = unboundTypesHandler;\n  } else {\n   ensureOverloadTable(proto, methodName, humanName);\n   proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n  }\n  whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n   var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\n   if (undefined === proto[methodName].overloadTable) {\n    memberFunction.argCount = argCount - 2;\n    proto[methodName] = memberFunction;\n   } else {\n    proto[methodName].overloadTable[argCount - 2] = memberFunction;\n   }\n   return [];\n  });\n  return [];\n });\n}\n\nvar emval_free_list = [];\n\nvar emval_handle_array = [ {}, {\n value: undefined\n}, {\n value: null\n}, {\n value: true\n}, {\n value: false\n} ];\n\nfunction __emval_decref(handle) {\n if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n  emval_handle_array[handle] = undefined;\n  emval_free_list.push(handle);\n }\n}\n\nfunction count_emval_handles() {\n var count = 0;\n for (var i = 5; i < emval_handle_array.length; ++i) {\n  if (emval_handle_array[i] !== undefined) {\n   ++count;\n  }\n }\n return count;\n}\n\nfunction get_first_emval() {\n for (var i = 5; i < emval_handle_array.length; ++i) {\n  if (emval_handle_array[i] !== undefined) {\n   return emval_handle_array[i];\n  }\n }\n return null;\n}\n\nfunction init_emval() {\n Module[\"count_emval_handles\"] = count_emval_handles;\n Module[\"get_first_emval\"] = get_first_emval;\n}\n\nvar Emval = {\n toValue: function(handle) {\n  if (!handle) {\n   throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n  }\n  return emval_handle_array[handle].value;\n },\n toHandle: function(value) {\n  switch (value) {\n  case undefined:\n   {\n    return 1;\n   }\n\n  case null:\n   {\n    return 2;\n   }\n\n  case true:\n   {\n    return 3;\n   }\n\n  case false:\n   {\n    return 4;\n   }\n\n  default:\n   {\n    var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n    emval_handle_array[handle] = {\n     refcount: 1,\n     value: value\n    };\n    return handle;\n   }\n  }\n }\n};\n\nfunction __embind_register_emval(rawType, name) {\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(handle) {\n   var rv = Emval.toValue(handle);\n   __emval_decref(handle);\n   return rv;\n  },\n  \"toWireType\": function(destructors, value) {\n   return Emval.toHandle(value);\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: null\n });\n}\n\nfunction _embind_repr(v) {\n if (v === null) {\n  return \"null\";\n }\n var t = typeof v;\n if (t === \"object\" || t === \"array\" || t === \"function\") {\n  return v.toString();\n } else {\n  return \"\" + v;\n }\n}\n\nfunction floatReadValueFromPointer(name, shift) {\n switch (shift) {\n case 2:\n  return function(pointer) {\n   return this[\"fromWireType\"](_asan_js_load_f(pointer >> 2));\n  };\n\n case 3:\n  return function(pointer) {\n   return this[\"fromWireType\"](_asan_js_load_d(pointer >> 3));\n  };\n\n default:\n  throw new TypeError(\"Unknown float type: \" + name);\n }\n}\n\nfunction __embind_register_float(rawType, name, size) {\n var shift = getShiftFromSize(size);\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   return value;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n    throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n   }\n   return value;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": floatReadValueFromPointer(name, shift),\n  destructorFunction: null\n });\n}\n\nfunction __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\n var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n name = readLatin1String(name);\n rawInvoker = embind__requireFunction(signature, rawInvoker);\n exposePublicSymbol(name, function() {\n  throwUnboundTypeError(\"Cannot call \" + name + \" due to unbound types\", argTypes);\n }, argCount - 1);\n whenDependentTypesAreResolved([], argTypes, function(argTypes) {\n  var invokerArgsArray = [ argTypes[0], null ].concat(argTypes.slice(1));\n  replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);\n  return [];\n });\n}\n\nfunction integerReadValueFromPointer(name, shift, signed) {\n switch (shift) {\n case 0:\n  return signed ? function readS8FromPointer(pointer) {\n   return _asan_js_load_1(pointer);\n  } : function readU8FromPointer(pointer) {\n   return _asan_js_load_1u(pointer);\n  };\n\n case 1:\n  return signed ? function readS16FromPointer(pointer) {\n   return _asan_js_load_2(pointer >> 1);\n  } : function readU16FromPointer(pointer) {\n   return _asan_js_load_2u(pointer >> 1);\n  };\n\n case 2:\n  return signed ? function readS32FromPointer(pointer) {\n   return _asan_js_load_4(pointer >> 2);\n  } : function readU32FromPointer(pointer) {\n   return _asan_js_load_4u(pointer >> 2);\n  };\n\n default:\n  throw new TypeError(\"Unknown integer type: \" + name);\n }\n}\n\nfunction __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n name = readLatin1String(name);\n if (maxRange === -1) {\n  maxRange = 4294967295;\n }\n var shift = getShiftFromSize(size);\n var fromWireType = value => value;\n if (minRange === 0) {\n  var bitshift = 32 - 8 * size;\n  fromWireType = (value => value << bitshift >>> bitshift);\n }\n var isUnsignedType = name.includes(\"unsigned\");\n var checkAssertions = (value, toTypeName) => {\n  if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n   throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + toTypeName);\n  }\n  if (value < minRange || value > maxRange) {\n   throw new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + \", \" + maxRange + \"]!\");\n  }\n };\n var toWireType;\n if (isUnsignedType) {\n  toWireType = function(destructors, value) {\n   checkAssertions(value, this.name);\n   return value >>> 0;\n  };\n } else {\n  toWireType = function(destructors, value) {\n   checkAssertions(value, this.name);\n   return value;\n  };\n }\n registerType(primitiveType, {\n  name: name,\n  \"fromWireType\": fromWireType,\n  \"toWireType\": toWireType,\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": integerReadValueFromPointer(name, shift, minRange !== 0),\n  destructorFunction: null\n });\n}\n\nfunction __embind_register_memory_view(rawType, dataTypeIndex, name) {\n var typeMapping = [ Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];\n var TA = typeMapping[dataTypeIndex];\n function decodeMemoryView(handle) {\n  handle = handle >> 2;\n  var heap = HEAPU32;\n  var size = heap[handle];\n  var data = heap[handle + 1];\n  return new TA(buffer, data, size);\n }\n name = readLatin1String(name);\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": decodeMemoryView,\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": decodeMemoryView\n }, {\n  ignoreDuplicateRegistrations: true\n });\n}\n\nfunction __embind_register_std_string(rawType, name) {\n name = readLatin1String(name);\n var stdStringIsUTF8 = name === \"std::string\";\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   var length = _asan_js_load_4u(value >> 2);\n   var str;\n   if (stdStringIsUTF8) {\n    var decodeStartPtr = value + 4;\n    for (var i = 0; i <= length; ++i) {\n     var currentBytePtr = value + 4 + i;\n     if (i == length || _asan_js_load_1u(currentBytePtr) == 0) {\n      var maxRead = currentBytePtr - decodeStartPtr;\n      var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n      if (str === undefined) {\n       str = stringSegment;\n      } else {\n       str += String.fromCharCode(0);\n       str += stringSegment;\n      }\n      decodeStartPtr = currentBytePtr + 1;\n     }\n    }\n   } else {\n    var a = new Array(length);\n    for (var i = 0; i < length; ++i) {\n     a[i] = String.fromCharCode(_asan_js_load_1u(value + 4 + i));\n    }\n    str = a.join(\"\");\n   }\n   _free(value);\n   return str;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (value instanceof ArrayBuffer) {\n    value = new Uint8Array(value);\n   }\n   var getLength;\n   var valueIsOfTypeString = typeof value === \"string\";\n   if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n    throwBindingError(\"Cannot pass non-string to std::string\");\n   }\n   if (stdStringIsUTF8 && valueIsOfTypeString) {\n    getLength = (() => lengthBytesUTF8(value));\n   } else {\n    getLength = (() => value.length);\n   }\n   var length = getLength();\n   var ptr = _malloc(4 + length + 1);\n   _asan_js_store_4u(ptr >> 2, length);\n   if (stdStringIsUTF8 && valueIsOfTypeString) {\n    stringToUTF8(value, ptr + 4, length + 1);\n   } else {\n    if (valueIsOfTypeString) {\n     for (var i = 0; i < length; ++i) {\n      var charCode = value.charCodeAt(i);\n      if (charCode > 255) {\n       _free(ptr);\n       throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n      }\n      _asan_js_store_1u(ptr + 4 + i, charCode);\n     }\n    } else {\n     for (var i = 0; i < length; ++i) {\n      _asan_js_store_1u(ptr + 4 + i, value[i]);\n     }\n    }\n   }\n   if (destructors !== null) {\n    destructors.push(_free, ptr);\n   }\n   return ptr;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: function(ptr) {\n   _free(ptr);\n  }\n });\n}\n\nfunction __embind_register_std_wstring(rawType, charSize, name) {\n name = readLatin1String(name);\n var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n if (charSize === 2) {\n  decodeString = UTF16ToString;\n  encodeString = stringToUTF16;\n  lengthBytesUTF = lengthBytesUTF16;\n  getHeap = (() => HEAPU16);\n  shift = 1;\n } else if (charSize === 4) {\n  decodeString = UTF32ToString;\n  encodeString = stringToUTF32;\n  lengthBytesUTF = lengthBytesUTF32;\n  getHeap = (() => HEAPU32);\n  shift = 2;\n }\n registerType(rawType, {\n  name: name,\n  \"fromWireType\": function(value) {\n   var length = _asan_js_load_4u(value >> 2);\n   var HEAP = getHeap();\n   var str;\n   var decodeStartPtr = value + 4;\n   for (var i = 0; i <= length; ++i) {\n    var currentBytePtr = value + 4 + i * charSize;\n    if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n     var maxReadBytes = currentBytePtr - decodeStartPtr;\n     var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n     if (str === undefined) {\n      str = stringSegment;\n     } else {\n      str += String.fromCharCode(0);\n      str += stringSegment;\n     }\n     decodeStartPtr = currentBytePtr + charSize;\n    }\n   }\n   _free(value);\n   return str;\n  },\n  \"toWireType\": function(destructors, value) {\n   if (!(typeof value === \"string\")) {\n    throwBindingError(\"Cannot pass non-string to C++ string type \" + name);\n   }\n   var length = lengthBytesUTF(value);\n   var ptr = _malloc(4 + length + charSize);\n   _asan_js_store_4u(ptr >> 2, length >> shift);\n   encodeString(value, ptr + 4, length + charSize);\n   if (destructors !== null) {\n    destructors.push(_free, ptr);\n   }\n   return ptr;\n  },\n  \"argPackAdvance\": 8,\n  \"readValueFromPointer\": simpleReadValueFromPointer,\n  destructorFunction: function(ptr) {\n   _free(ptr);\n  }\n });\n}\n\nfunction __embind_register_void(rawType, name) {\n name = readLatin1String(name);\n registerType(rawType, {\n  isVoid: true,\n  name: name,\n  \"argPackAdvance\": 0,\n  \"fromWireType\": function() {\n   return undefined;\n  },\n  \"toWireType\": function(destructors, o) {\n   return undefined;\n  }\n });\n}\n\nfunction __emval_incref(handle) {\n if (handle > 4) {\n  emval_handle_array[handle].refcount += 1;\n }\n}\n\nfunction requireRegisteredType(rawType, humanName) {\n var impl = registeredTypes[rawType];\n if (undefined === impl) {\n  throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n }\n return impl;\n}\n\nfunction __emval_take_value(type, argv) {\n type = requireRegisteredType(type, \"_emval_take_value\");\n var v = type[\"readValueFromPointer\"](argv);\n return Emval.toHandle(v);\n}\n\nfunction _abort() {\n abort(\"native code called abort()\");\n}\n\nvar readAsmConstArgsArray = [];\n\nfunction readAsmConstArgs(sigPtr, buf) {\n assert(Array.isArray(readAsmConstArgsArray));\n assert(buf % 16 == 0);\n readAsmConstArgsArray.length = 0;\n var ch;\n buf >>= 2;\n while (ch = _asan_js_load_1u(sigPtr++)) {\n  assert(ch === 100 || ch === 102 || ch === 105);\n  var readAsmConstArgsDouble = ch < 105;\n  if (readAsmConstArgsDouble && buf & 1) buf++;\n  readAsmConstArgsArray.push(readAsmConstArgsDouble ? _asan_js_load_d(buf++ >> 1) : _asan_js_load_4(buf));\n  ++buf;\n }\n return readAsmConstArgsArray;\n}\n\nfunction _emscripten_asm_const_int(code, sigPtr, argbuf) {\n var args = readAsmConstArgs(sigPtr, argbuf);\n if (!ASM_CONSTS.hasOwnProperty(code)) abort(\"No EM_ASM constant found at address \" + code);\n return ASM_CONSTS[code].apply(null, args);\n}\n\nfunction _emscripten_asm_const_double(a0, a1, a2) {\n return _emscripten_asm_const_int(a0, a1, a2);\n}\n\nfunction syscallMmap2(addr, len, prot, flags, fd, off) {\n off <<= 12;\n var ptr;\n var allocated = false;\n if ((flags & 16) !== 0 && addr % 65536 !== 0) {\n  return -28;\n }\n if ((flags & 32) !== 0) {\n  ptr = mmapAlloc(len);\n  if (!ptr) return -48;\n  allocated = true;\n } else {\n  var info = FS.getStream(fd);\n  if (!info) return -8;\n  var res = FS.mmap(info, addr, len, off, prot, flags);\n  ptr = res.ptr;\n  allocated = res.allocated;\n }\n SYSCALLS.mappings[ptr] = {\n  malloc: ptr,\n  len: len,\n  allocated: allocated,\n  fd: fd,\n  prot: prot,\n  flags: flags,\n  offset: off\n };\n return ptr;\n}\n\nfunction withBuiltinMalloc(func) {\n var prev_malloc = typeof _malloc !== \"undefined\" ? _malloc : undefined;\n var prev_memalign = typeof _memalign !== \"undefined\" ? _memalign : undefined;\n var prev_free = typeof _free !== \"undefined\" ? _free : undefined;\n _malloc = _emscripten_builtin_malloc;\n _memalign = _emscripten_builtin_memalign;\n _free = _emscripten_builtin_free;\n try {\n  return func();\n } finally {\n  _malloc = prev_malloc;\n  _memalign = prev_memalign;\n  _free = prev_free;\n }\n}\n\nfunction _emscripten_builtin_mmap2(addr, len, prot, flags, fd, off) {\n return withBuiltinMalloc(function() {\n  return syscallMmap2(addr, len, prot, flags, fd, off);\n });\n}\n\nfunction syscallMunmap(addr, len) {\n var info = SYSCALLS.mappings[addr];\n if (len === 0 || !info) {\n  return -28;\n }\n if (len === info.len) {\n  var stream = FS.getStream(info.fd);\n  if (stream) {\n   if (info.prot & 2) {\n    SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);\n   }\n   FS.munmap(stream);\n  }\n  SYSCALLS.mappings[addr] = null;\n  if (info.allocated) {\n   _free(info.malloc);\n  }\n }\n return 0;\n}\n\nfunction _emscripten_builtin_munmap(addr, len) {\n return withBuiltinMalloc(function() {\n  return syscallMunmap(addr, len);\n });\n}\n\nfunction _emscripten_console_error(str) {\n assert(typeof str === \"number\");\n console.error(UTF8ToString(str));\n}\n\nfunction _emscripten_get_heap_max() {\n return HEAPU8.length;\n}\n\nfunction _emscripten_get_module_name(buf, length) {\n return stringToUTF8(wasmBinaryFile, buf, length);\n}\n\nvar _emscripten_get_now;\n\n_emscripten_get_now = (() => performance.now());\n\nvar UNWIND_CACHE = {};\n\nfunction convertFrameToPC(frame) {\n assert(wasmOffsetConverter);\n var match;\n if (match = /\\bwasm-function\\[\\d+\\]:(0x[0-9a-f]+)/.exec(frame)) {\n  return +match[1];\n } else if (match = /\\bwasm-function\\[(\\d+)\\]:(\\d+)/.exec(frame)) {\n  return wasmOffsetConverter.convert(+match[1], +match[2]);\n } else if (match = /:(\\d+):\\d+(?:\\)|$)/.exec(frame)) {\n  return 2147483648 | +match[1];\n }\n return 0;\n}\n\nfunction convertPCtoSourceLocation(pc) {\n if (UNWIND_CACHE.last_get_source_pc == pc) return UNWIND_CACHE.last_source;\n var match;\n var source;\n if (!source) {\n  var frame = UNWIND_CACHE[pc];\n  if (!frame) return null;\n  if (match = /\\((.*):(\\d+):(\\d+)\\)$/.exec(frame)) {\n   source = {\n    file: match[1],\n    line: match[2],\n    column: match[3]\n   };\n  } else if (match = /@(.*):(\\d+):(\\d+)/.exec(frame)) {\n   source = {\n    file: match[1],\n    line: match[2],\n    column: match[3]\n   };\n  }\n }\n UNWIND_CACHE.last_get_source_pc = pc;\n UNWIND_CACHE.last_source = source;\n return source;\n}\n\nfunction _emscripten_pc_get_column(pc) {\n var result = convertPCtoSourceLocation(pc);\n return result ? result.column || 0 : 0;\n}\n\nfunction _emscripten_pc_get_file(pc) {\n return withBuiltinMalloc(function() {\n  var result = convertPCtoSourceLocation(pc);\n  if (!result) return 0;\n  if (_emscripten_pc_get_file.ret) _free(_emscripten_pc_get_file.ret);\n  _emscripten_pc_get_file.ret = allocateUTF8(result.file);\n  return _emscripten_pc_get_file.ret;\n });\n}\n\nfunction _emscripten_pc_get_function(pc) {\n return withBuiltinMalloc(function() {\n  var name;\n  if (pc & 2147483648) {\n   var frame = UNWIND_CACHE[pc];\n   if (!frame) return 0;\n   var match;\n   if (match = /^\\s+at (.*) \\(.*\\)$/.exec(frame)) {\n    name = match[1];\n   } else if (match = /^(.+?)@/.exec(frame)) {\n    name = match[1];\n   } else {\n    return 0;\n   }\n  } else {\n   name = wasmOffsetConverter.getName(pc);\n  }\n  if (_emscripten_pc_get_function.ret) _free(_emscripten_pc_get_function.ret);\n  _emscripten_pc_get_function.ret = allocateUTF8(name);\n  return _emscripten_pc_get_function.ret;\n });\n}\n\nfunction _emscripten_pc_get_line(pc) {\n var result = convertPCtoSourceLocation(pc);\n return result ? result.line : 0;\n}\n\nfunction abortOnCannotGrowMemory(requestedSize) {\n abort(\"Cannot enlarge memory arrays to size \" + requestedSize + \" bytes (OOM). Either (1) compile with  -s INITIAL_MEMORY=X  with X higher than the current value \" + HEAP8.length + \", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 \");\n}\n\nfunction _emscripten_resize_heap(requestedSize) {\n var oldSize = HEAPU8.length;\n requestedSize = requestedSize >>> 0;\n abortOnCannotGrowMemory(requestedSize);\n}\n\nfunction _emscripten_return_address(level) {\n var callstack = new Error().stack.split(\"\\n\");\n if (callstack[0] == \"Error\") {\n  callstack.shift();\n }\n return convertFrameToPC(callstack[level + 2]);\n}\n\nfunction saveInUnwindCache(callstack) {\n callstack.forEach(function(frame) {\n  var pc = convertFrameToPC(frame);\n  if (pc) {\n   UNWIND_CACHE[pc] = frame;\n  }\n });\n}\n\nfunction _emscripten_stack_snapshot() {\n var callstack = new Error().stack.split(\"\\n\");\n if (callstack[0] == \"Error\") {\n  callstack.shift();\n }\n saveInUnwindCache(callstack);\n UNWIND_CACHE.last_addr = convertFrameToPC(callstack[2]);\n UNWIND_CACHE.last_stack = callstack;\n return UNWIND_CACHE.last_addr;\n}\n\nfunction _emscripten_stack_unwind_buffer(addr, buffer, count) {\n var stack;\n if (UNWIND_CACHE.last_addr == addr) {\n  stack = UNWIND_CACHE.last_stack;\n } else {\n  stack = new Error().stack.split(\"\\n\");\n  if (stack[0] == \"Error\") {\n   stack.shift();\n  }\n  saveInUnwindCache(stack);\n }\n var offset = 2;\n while (stack[offset] && convertFrameToPC(stack[offset]) != addr) {\n  ++offset;\n }\n for (var i = 0; i < count && stack[i + offset]; ++i) {\n  _asan_js_store_4(buffer + i * 4 >> 2, convertFrameToPC(stack[i + offset]));\n }\n return i;\n}\n\nvar ENV = {};\n\nfunction getExecutableName() {\n return thisProgram || \"./this.program\";\n}\n\nfunction getEnvStrings() {\n if (!getEnvStrings.strings) {\n  var lang = (typeof navigator === \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n  var env = {\n   \"USER\": \"web_user\",\n   \"LOGNAME\": \"web_user\",\n   \"PATH\": \"/\",\n   \"PWD\": \"/\",\n   \"HOME\": \"/home/web_user\",\n   \"LANG\": lang,\n   \"_\": getExecutableName()\n  };\n  for (var x in ENV) {\n   if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x];\n  }\n  var strings = [];\n  for (var x in env) {\n   strings.push(x + \"=\" + env[x]);\n  }\n  getEnvStrings.strings = strings;\n }\n return getEnvStrings.strings;\n}\n\nfunction _environ_get(__environ, environ_buf) {\n var bufSize = 0;\n getEnvStrings().forEach(function(string, i) {\n  var ptr = environ_buf + bufSize;\n  _asan_js_store_4(__environ + i * 4 >> 2, ptr);\n  writeAsciiToMemory(string, ptr);\n  bufSize += string.length + 1;\n });\n return 0;\n}\n\nfunction _environ_sizes_get(penviron_count, penviron_buf_size) {\n var strings = getEnvStrings();\n _asan_js_store_4(penviron_count >> 2, strings.length);\n var bufSize = 0;\n strings.forEach(function(string) {\n  bufSize += string.length + 1;\n });\n _asan_js_store_4(penviron_buf_size >> 2, bufSize);\n return 0;\n}\n\nfunction _fd_close(fd) {\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  FS.close(stream);\n  return 0;\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\n  return e.errno;\n }\n}\n\nfunction _fd_read(fd, iov, iovcnt, pnum) {\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  var num = SYSCALLS.doReadv(stream, iov, iovcnt);\n  _asan_js_store_4(pnum >> 2, num);\n  return 0;\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\n  return e.errno;\n }\n}\n\nfunction _fd_write(fd, iov, iovcnt, pnum) {\n try {\n  var stream = SYSCALLS.getStreamFromFD(fd);\n  var num = SYSCALLS.doWritev(stream, iov, iovcnt);\n  _asan_js_store_4(pnum >> 2, num);\n  return 0;\n } catch (e) {\n  if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) throw e;\n  return e.errno;\n }\n}\n\nfunction _proc_exit(code) {\n procExit(code);\n}\n\nfunction _setTempRet0(val) {\n setTempRet0(val);\n}\n\nvar FSNode = function(parent, name, mode, rdev) {\n if (!parent) {\n  parent = this;\n }\n this.parent = parent;\n this.mount = parent.mount;\n this.mounted = null;\n this.id = FS.nextInode++;\n this.name = name;\n this.mode = mode;\n this.node_ops = {};\n this.stream_ops = {};\n this.rdev = rdev;\n};\n\nvar readMode = 292 | 73;\n\nvar writeMode = 146;\n\nObject.defineProperties(FSNode.prototype, {\n read: {\n  get: function() {\n   return (this.mode & readMode) === readMode;\n  },\n  set: function(val) {\n   val ? this.mode |= readMode : this.mode &= ~readMode;\n  }\n },\n write: {\n  get: function() {\n   return (this.mode & writeMode) === writeMode;\n  },\n  set: function(val) {\n   val ? this.mode |= writeMode : this.mode &= ~writeMode;\n  }\n },\n isFolder: {\n  get: function() {\n   return FS.isDir(this.mode);\n  }\n },\n isDevice: {\n  get: function() {\n   return FS.isChrdev(this.mode);\n  }\n }\n});\n\nFS.FSNode = FSNode;\n\nFS.staticInit();\n\nERRNO_CODES = {\n \"EPERM\": 63,\n \"ENOENT\": 44,\n \"ESRCH\": 71,\n \"EINTR\": 27,\n \"EIO\": 29,\n \"ENXIO\": 60,\n \"E2BIG\": 1,\n \"ENOEXEC\": 45,\n \"EBADF\": 8,\n \"ECHILD\": 12,\n \"EAGAIN\": 6,\n \"EWOULDBLOCK\": 6,\n \"ENOMEM\": 48,\n \"EACCES\": 2,\n \"EFAULT\": 21,\n \"ENOTBLK\": 105,\n \"EBUSY\": 10,\n \"EEXIST\": 20,\n \"EXDEV\": 75,\n \"ENODEV\": 43,\n \"ENOTDIR\": 54,\n \"EISDIR\": 31,\n \"EINVAL\": 28,\n \"ENFILE\": 41,\n \"EMFILE\": 33,\n \"ENOTTY\": 59,\n \"ETXTBSY\": 74,\n \"EFBIG\": 22,\n \"ENOSPC\": 51,\n \"ESPIPE\": 70,\n \"EROFS\": 69,\n \"EMLINK\": 34,\n \"EPIPE\": 64,\n \"EDOM\": 18,\n \"ERANGE\": 68,\n \"ENOMSG\": 49,\n \"EIDRM\": 24,\n \"ECHRNG\": 106,\n \"EL2NSYNC\": 156,\n \"EL3HLT\": 107,\n \"EL3RST\": 108,\n \"ELNRNG\": 109,\n \"EUNATCH\": 110,\n \"ENOCSI\": 111,\n \"EL2HLT\": 112,\n \"EDEADLK\": 16,\n \"ENOLCK\": 46,\n \"EBADE\": 113,\n \"EBADR\": 114,\n \"EXFULL\": 115,\n \"ENOANO\": 104,\n \"EBADRQC\": 103,\n \"EBADSLT\": 102,\n \"EDEADLOCK\": 16,\n \"EBFONT\": 101,\n \"ENOSTR\": 100,\n \"ENODATA\": 116,\n \"ETIME\": 117,\n \"ENOSR\": 118,\n \"ENONET\": 119,\n \"ENOPKG\": 120,\n \"EREMOTE\": 121,\n \"ENOLINK\": 47,\n \"EADV\": 122,\n \"ESRMNT\": 123,\n \"ECOMM\": 124,\n \"EPROTO\": 65,\n \"EMULTIHOP\": 36,\n \"EDOTDOT\": 125,\n \"EBADMSG\": 9,\n \"ENOTUNIQ\": 126,\n \"EBADFD\": 127,\n \"EREMCHG\": 128,\n \"ELIBACC\": 129,\n \"ELIBBAD\": 130,\n \"ELIBSCN\": 131,\n \"ELIBMAX\": 132,\n \"ELIBEXEC\": 133,\n \"ENOSYS\": 52,\n \"ENOTEMPTY\": 55,\n \"ENAMETOOLONG\": 37,\n \"ELOOP\": 32,\n \"EOPNOTSUPP\": 138,\n \"EPFNOSUPPORT\": 139,\n \"ECONNRESET\": 15,\n \"ENOBUFS\": 42,\n \"EAFNOSUPPORT\": 5,\n \"EPROTOTYPE\": 67,\n \"ENOTSOCK\": 57,\n \"ENOPROTOOPT\": 50,\n \"ESHUTDOWN\": 140,\n \"ECONNREFUSED\": 14,\n \"EADDRINUSE\": 3,\n \"ECONNABORTED\": 13,\n \"ENETUNREACH\": 40,\n \"ENETDOWN\": 38,\n \"ETIMEDOUT\": 73,\n \"EHOSTDOWN\": 142,\n \"EHOSTUNREACH\": 23,\n \"EINPROGRESS\": 26,\n \"EALREADY\": 7,\n \"EDESTADDRREQ\": 17,\n \"EMSGSIZE\": 35,\n \"EPROTONOSUPPORT\": 66,\n \"ESOCKTNOSUPPORT\": 137,\n \"EADDRNOTAVAIL\": 4,\n \"ENETRESET\": 39,\n \"EISCONN\": 30,\n \"ENOTCONN\": 53,\n \"ETOOMANYREFS\": 141,\n \"EUSERS\": 136,\n \"EDQUOT\": 19,\n \"ESTALE\": 72,\n \"ENOTSUP\": 138,\n \"ENOMEDIUM\": 148,\n \"EILSEQ\": 25,\n \"EOVERFLOW\": 61,\n \"ECANCELED\": 11,\n \"ENOTRECOVERABLE\": 56,\n \"EOWNERDEAD\": 62,\n \"ESTRPIPE\": 135\n};\n\nembind_init_charCodes();\n\nBindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n\nInternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\n\ninit_ClassHandle();\n\ninit_embind();\n\ninit_RegisteredPointer();\n\nUnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n\ninit_emval();\n\nvar ASSERTIONS = true;\n\nfunction intArrayFromString(stringy, dontAddNull, length) {\n var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n var u8array = new Array(len);\n var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n if (dontAddNull) u8array.length = numBytesWritten;\n return u8array;\n}\n\nvar asmLibraryArg = {\n \"__assert_fail\": ___assert_fail,\n \"__syscall_dup\": ___syscall_dup,\n \"__syscall_open\": ___syscall_open,\n \"__syscall_stat64\": ___syscall_stat64,\n \"_embind_register_bigint\": __embind_register_bigint,\n \"_embind_register_bool\": __embind_register_bool,\n \"_embind_register_class\": __embind_register_class,\n \"_embind_register_class_constructor\": __embind_register_class_constructor,\n \"_embind_register_class_function\": __embind_register_class_function,\n \"_embind_register_emval\": __embind_register_emval,\n \"_embind_register_float\": __embind_register_float,\n \"_embind_register_function\": __embind_register_function,\n \"_embind_register_integer\": __embind_register_integer,\n \"_embind_register_memory_view\": __embind_register_memory_view,\n \"_embind_register_std_string\": __embind_register_std_string,\n \"_embind_register_std_wstring\": __embind_register_std_wstring,\n \"_embind_register_void\": __embind_register_void,\n \"_emval_decref\": __emval_decref,\n \"_emval_incref\": __emval_incref,\n \"_emval_take_value\": __emval_take_value,\n \"abort\": _abort,\n \"emscripten_asm_const_double\": _emscripten_asm_const_double,\n \"emscripten_asm_const_int\": _emscripten_asm_const_int,\n \"emscripten_builtin_mmap2\": _emscripten_builtin_mmap2,\n \"emscripten_builtin_munmap\": _emscripten_builtin_munmap,\n \"emscripten_console_error\": _emscripten_console_error,\n \"emscripten_get_heap_max\": _emscripten_get_heap_max,\n \"emscripten_get_module_name\": _emscripten_get_module_name,\n \"emscripten_get_now\": _emscripten_get_now,\n \"emscripten_pc_get_column\": _emscripten_pc_get_column,\n \"emscripten_pc_get_file\": _emscripten_pc_get_file,\n \"emscripten_pc_get_function\": _emscripten_pc_get_function,\n \"emscripten_pc_get_line\": _emscripten_pc_get_line,\n \"emscripten_resize_heap\": _emscripten_resize_heap,\n \"emscripten_return_address\": _emscripten_return_address,\n \"emscripten_stack_snapshot\": _emscripten_stack_snapshot,\n \"emscripten_stack_unwind_buffer\": _emscripten_stack_unwind_buffer,\n \"environ_get\": _environ_get,\n \"environ_sizes_get\": _environ_sizes_get,\n \"fd_close\": _fd_close,\n \"fd_read\": _fd_read,\n \"fd_write\": _fd_write,\n \"proc_exit\": _proc_exit,\n \"setTempRet0\": _setTempRet0\n};\n\nvar asm = createWasm();\n\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = createExportWrapper(\"__wasm_call_ctors\");\n\nvar ___getTypeName = Module[\"___getTypeName\"] = createExportWrapper(\"__getTypeName\");\n\nvar ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = createExportWrapper(\"__embind_register_native_and_builtin_types\");\n\nvar ___errno_location = Module[\"___errno_location\"] = createExportWrapper(\"__errno_location\");\n\nvar ___stdio_exit = Module[\"___stdio_exit\"] = createExportWrapper(\"__stdio_exit\");\n\nvar ___funcs_on_exit = Module[\"___funcs_on_exit\"] = createExportWrapper(\"__funcs_on_exit\");\n\nvar _malloc = Module[\"_malloc\"] = createExportWrapper(\"malloc\");\n\nvar _free = Module[\"_free\"] = createExportWrapper(\"free\");\n\nvar _memalign = Module[\"_memalign\"] = createExportWrapper(\"memalign\");\n\nvar _emscripten_builtin_malloc = Module[\"_emscripten_builtin_malloc\"] = createExportWrapper(\"emscripten_builtin_malloc\");\n\nvar _emscripten_builtin_free = Module[\"_emscripten_builtin_free\"] = createExportWrapper(\"emscripten_builtin_free\");\n\nvar _emscripten_builtin_memalign = Module[\"_emscripten_builtin_memalign\"] = createExportWrapper(\"emscripten_builtin_memalign\");\n\nvar _emscripten_stack_init = Module[\"_emscripten_stack_init\"] = function() {\n return (_emscripten_stack_init = Module[\"_emscripten_stack_init\"] = Module[\"asm\"][\"emscripten_stack_init\"]).apply(null, arguments);\n};\n\nvar _emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = function() {\n return (_emscripten_stack_get_free = Module[\"_emscripten_stack_get_free\"] = Module[\"asm\"][\"emscripten_stack_get_free\"]).apply(null, arguments);\n};\n\nvar _emscripten_stack_get_base = Module[\"_emscripten_stack_get_base\"] = function() {\n return (_emscripten_stack_get_base = Module[\"_emscripten_stack_get_base\"] = Module[\"asm\"][\"emscripten_stack_get_base\"]).apply(null, arguments);\n};\n\nvar _emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = function() {\n return (_emscripten_stack_get_end = Module[\"_emscripten_stack_get_end\"] = Module[\"asm\"][\"emscripten_stack_get_end\"]).apply(null, arguments);\n};\n\nvar stackSave = Module[\"stackSave\"] = createExportWrapper(\"stackSave\");\n\nvar stackRestore = Module[\"stackRestore\"] = createExportWrapper(\"stackRestore\");\n\nvar stackAlloc = Module[\"stackAlloc\"] = createExportWrapper(\"stackAlloc\");\n\nvar __ZN6__asan9FakeStack17AddrIsInFakeStackEm = Module[\"__ZN6__asan9FakeStack17AddrIsInFakeStackEm\"] = createExportWrapper(\"_ZN6__asan9FakeStack17AddrIsInFakeStackEm\");\n\nvar __ZN6__asan9FakeStack8AllocateEmmm = Module[\"__ZN6__asan9FakeStack8AllocateEmmm\"] = createExportWrapper(\"_ZN6__asan9FakeStack8AllocateEmmm\");\n\nvar _asan_c_load_1 = Module[\"_asan_c_load_1\"] = createExportWrapper(\"asan_c_load_1\");\n\nvar _asan_c_load_1u = Module[\"_asan_c_load_1u\"] = createExportWrapper(\"asan_c_load_1u\");\n\nvar _asan_c_load_2 = Module[\"_asan_c_load_2\"] = createExportWrapper(\"asan_c_load_2\");\n\nvar _asan_c_load_2u = Module[\"_asan_c_load_2u\"] = createExportWrapper(\"asan_c_load_2u\");\n\nvar _asan_c_load_4 = Module[\"_asan_c_load_4\"] = createExportWrapper(\"asan_c_load_4\");\n\nvar _asan_c_load_4u = Module[\"_asan_c_load_4u\"] = createExportWrapper(\"asan_c_load_4u\");\n\nvar _asan_c_load_f = Module[\"_asan_c_load_f\"] = createExportWrapper(\"asan_c_load_f\");\n\nvar _asan_c_load_d = Module[\"_asan_c_load_d\"] = createExportWrapper(\"asan_c_load_d\");\n\nvar _asan_c_store_1 = Module[\"_asan_c_store_1\"] = createExportWrapper(\"asan_c_store_1\");\n\nvar _asan_c_store_1u = Module[\"_asan_c_store_1u\"] = createExportWrapper(\"asan_c_store_1u\");\n\nvar _asan_c_store_2 = Module[\"_asan_c_store_2\"] = createExportWrapper(\"asan_c_store_2\");\n\nvar _asan_c_store_2u = Module[\"_asan_c_store_2u\"] = createExportWrapper(\"asan_c_store_2u\");\n\nvar _asan_c_store_4 = Module[\"_asan_c_store_4\"] = createExportWrapper(\"asan_c_store_4\");\n\nvar _asan_c_store_4u = Module[\"_asan_c_store_4u\"] = createExportWrapper(\"asan_c_store_4u\");\n\nvar _asan_c_store_f = Module[\"_asan_c_store_f\"] = createExportWrapper(\"asan_c_store_f\");\n\nvar _asan_c_store_d = Module[\"_asan_c_store_d\"] = createExportWrapper(\"asan_c_store_d\");\n\nvar dynCall_jii = Module[\"dynCall_jii\"] = createExportWrapper(\"dynCall_jii\");\n\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayFromString\")) Module[\"intArrayFromString\"] = (() => abort(\"'intArrayFromString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayToString\")) Module[\"intArrayToString\"] = (() => abort(\"'intArrayToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ccall\")) Module[\"ccall\"] = (() => abort(\"'ccall' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"cwrap\")) Module[\"cwrap\"] = (() => abort(\"'cwrap' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setValue\")) Module[\"setValue\"] = (() => abort(\"'setValue' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getValue\")) Module[\"getValue\"] = (() => abort(\"'getValue' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"allocate\")) Module[\"allocate\"] = (() => abort(\"'allocate' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF8ArrayToString\")) Module[\"UTF8ArrayToString\"] = (() => abort(\"'UTF8ArrayToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF8ToString\")) Module[\"UTF8ToString\"] = (() => abort(\"'UTF8ToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8Array\")) Module[\"stringToUTF8Array\"] = (() => abort(\"'stringToUTF8Array' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8\")) Module[\"stringToUTF8\"] = (() => abort(\"'stringToUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF8\")) Module[\"lengthBytesUTF8\"] = (() => abort(\"'lengthBytesUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = (() => abort(\"'stackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreRun\")) Module[\"addOnPreRun\"] = (() => abort(\"'addOnPreRun' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnInit\")) Module[\"addOnInit\"] = (() => abort(\"'addOnInit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreMain\")) Module[\"addOnPreMain\"] = (() => abort(\"'addOnPreMain' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnExit\")) Module[\"addOnExit\"] = (() => abort(\"'addOnExit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPostRun\")) Module[\"addOnPostRun\"] = (() => abort(\"'addOnPostRun' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeStringToMemory\")) Module[\"writeStringToMemory\"] = (() => abort(\"'writeStringToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeArrayToMemory\")) Module[\"writeArrayToMemory\"] = (() => abort(\"'writeArrayToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeAsciiToMemory\")) Module[\"writeAsciiToMemory\"] = (() => abort(\"'writeAsciiToMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addRunDependency\")) Module[\"addRunDependency\"] = (() => abort(\"'addRunDependency' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"removeRunDependency\")) Module[\"removeRunDependency\"] = (() => abort(\"'removeRunDependency' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createFolder\")) Module[\"FS_createFolder\"] = (() => abort(\"'FS_createFolder' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createPath\")) Module[\"FS_createPath\"] = (() => abort(\"'FS_createPath' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createDataFile\")) Module[\"FS_createDataFile\"] = (() => abort(\"'FS_createDataFile' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createPreloadedFile\")) Module[\"FS_createPreloadedFile\"] = (() => abort(\"'FS_createPreloadedFile' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createLazyFile\")) Module[\"FS_createLazyFile\"] = (() => abort(\"'FS_createLazyFile' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createLink\")) Module[\"FS_createLink\"] = (() => abort(\"'FS_createLink' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createDevice\")) Module[\"FS_createDevice\"] = (() => abort(\"'FS_createDevice' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_unlink\")) Module[\"FS_unlink\"] = (() => abort(\"'FS_unlink' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getLEB\")) Module[\"getLEB\"] = (() => abort(\"'getLEB' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getFunctionTables\")) Module[\"getFunctionTables\"] = (() => abort(\"'getFunctionTables' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"alignFunctionTables\")) Module[\"alignFunctionTables\"] = (() => abort(\"'alignFunctionTables' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFunctions\")) Module[\"registerFunctions\"] = (() => abort(\"'registerFunctions' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"addFunction\")) Module[\"addFunction\"] = (() => abort(\"'addFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"removeFunction\")) Module[\"removeFunction\"] = (() => abort(\"'removeFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = (() => abort(\"'getFuncWrapper' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"prettyPrint\")) Module[\"prettyPrint\"] = (() => abort(\"'prettyPrint' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = (() => abort(\"'dynCall' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getCompilerSetting\")) Module[\"getCompilerSetting\"] = (() => abort(\"'getCompilerSetting' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"print\")) Module[\"print\"] = (() => abort(\"'print' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"printErr\")) Module[\"printErr\"] = (() => abort(\"'printErr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getTempRet0\")) Module[\"getTempRet0\"] = (() => abort(\"'getTempRet0' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setTempRet0\")) Module[\"setTempRet0\"] = (() => abort(\"'setTempRet0' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"callMain\")) Module[\"callMain\"] = (() => abort(\"'callMain' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"abort\")) Module[\"abort\"] = (() => abort(\"'abort' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"keepRuntimeAlive\")) Module[\"keepRuntimeAlive\"] = (() => abort(\"'keepRuntimeAlive' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"WasmOffsetConverter\")) Module[\"WasmOffsetConverter\"] = (() => abort(\"'WasmOffsetConverter' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"zeroMemory\")) Module[\"zeroMemory\"] = (() => abort(\"'zeroMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToNewUTF8\")) Module[\"stringToNewUTF8\"] = (() => abort(\"'stringToNewUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setFileTime\")) Module[\"setFileTime\"] = (() => abort(\"'setFileTime' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"abortOnCannotGrowMemory\")) Module[\"abortOnCannotGrowMemory\"] = (() => abort(\"'abortOnCannotGrowMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emscripten_realloc_buffer\")) Module[\"emscripten_realloc_buffer\"] = (() => abort(\"'emscripten_realloc_buffer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ENV\")) Module[\"ENV\"] = (() => abort(\"'ENV' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"withStackSave\")) Module[\"withStackSave\"] = (() => abort(\"'withStackSave' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_CODES\")) Module[\"ERRNO_CODES\"] = (() => abort(\"'ERRNO_CODES' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_MESSAGES\")) Module[\"ERRNO_MESSAGES\"] = (() => abort(\"'ERRNO_MESSAGES' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setErrNo\")) Module[\"setErrNo\"] = (() => abort(\"'setErrNo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"inetPton4\")) Module[\"inetPton4\"] = (() => abort(\"'inetPton4' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"inetNtop4\")) Module[\"inetNtop4\"] = (() => abort(\"'inetNtop4' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"inetPton6\")) Module[\"inetPton6\"] = (() => abort(\"'inetPton6' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"inetNtop6\")) Module[\"inetNtop6\"] = (() => abort(\"'inetNtop6' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readSockaddr\")) Module[\"readSockaddr\"] = (() => abort(\"'readSockaddr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeSockaddr\")) Module[\"writeSockaddr\"] = (() => abort(\"'writeSockaddr' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"DNS\")) Module[\"DNS\"] = (() => abort(\"'DNS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getHostByName\")) Module[\"getHostByName\"] = (() => abort(\"'getHostByName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"Protocols\")) Module[\"Protocols\"] = (() => abort(\"'Protocols' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"Sockets\")) Module[\"Sockets\"] = (() => abort(\"'Sockets' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getRandomDevice\")) Module[\"getRandomDevice\"] = (() => abort(\"'getRandomDevice' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"traverseStack\")) Module[\"traverseStack\"] = (() => abort(\"'traverseStack' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"convertFrameToPC\")) Module[\"convertFrameToPC\"] = (() => abort(\"'convertFrameToPC' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"UNWIND_CACHE\")) Module[\"UNWIND_CACHE\"] = (() => abort(\"'UNWIND_CACHE' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"saveInUnwindCache\")) Module[\"saveInUnwindCache\"] = (() => abort(\"'saveInUnwindCache' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"convertPCtoSourceLocation\")) Module[\"convertPCtoSourceLocation\"] = (() => abort(\"'convertPCtoSourceLocation' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"withBuiltinMalloc\")) Module[\"withBuiltinMalloc\"] = (() => abort(\"'withBuiltinMalloc' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readAsmConstArgsArray\")) Module[\"readAsmConstArgsArray\"] = (() => abort(\"'readAsmConstArgsArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readAsmConstArgs\")) Module[\"readAsmConstArgs\"] = (() => abort(\"'readAsmConstArgs' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"mainThreadEM_ASM\")) Module[\"mainThreadEM_ASM\"] = (() => abort(\"'mainThreadEM_ASM' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"jstoi_q\")) Module[\"jstoi_q\"] = (() => abort(\"'jstoi_q' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"jstoi_s\")) Module[\"jstoi_s\"] = (() => abort(\"'jstoi_s' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getExecutableName\")) Module[\"getExecutableName\"] = (() => abort(\"'getExecutableName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"listenOnce\")) Module[\"listenOnce\"] = (() => abort(\"'listenOnce' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"autoResumeAudioContext\")) Module[\"autoResumeAudioContext\"] = (() => abort(\"'autoResumeAudioContext' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCallLegacy\")) Module[\"dynCallLegacy\"] = (() => abort(\"'dynCallLegacy' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getDynCaller\")) Module[\"getDynCaller\"] = (() => abort(\"'getDynCaller' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = (() => abort(\"'dynCall' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"callRuntimeCallbacks\")) Module[\"callRuntimeCallbacks\"] = (() => abort(\"'callRuntimeCallbacks' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"wasmTableMirror\")) Module[\"wasmTableMirror\"] = (() => abort(\"'wasmTableMirror' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setWasmTableEntry\")) Module[\"setWasmTableEntry\"] = (() => abort(\"'setWasmTableEntry' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getWasmTableEntry\")) Module[\"getWasmTableEntry\"] = (() => abort(\"'getWasmTableEntry' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"handleException\")) Module[\"handleException\"] = (() => abort(\"'handleException' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"runtimeKeepalivePush\")) Module[\"runtimeKeepalivePush\"] = (() => abort(\"'runtimeKeepalivePush' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"runtimeKeepalivePop\")) Module[\"runtimeKeepalivePop\"] = (() => abort(\"'runtimeKeepalivePop' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"callUserCallback\")) Module[\"callUserCallback\"] = (() => abort(\"'callUserCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"maybeExit\")) Module[\"maybeExit\"] = (() => abort(\"'maybeExit' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"safeSetTimeout\")) Module[\"safeSetTimeout\"] = (() => abort(\"'safeSetTimeout' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"asmjsMangle\")) Module[\"asmjsMangle\"] = (() => abort(\"'asmjsMangle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"asyncLoad\")) Module[\"asyncLoad\"] = (() => abort(\"'asyncLoad' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"alignMemory\")) Module[\"alignMemory\"] = (() => abort(\"'alignMemory' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"mmapAlloc\")) Module[\"mmapAlloc\"] = (() => abort(\"'mmapAlloc' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"reallyNegative\")) Module[\"reallyNegative\"] = (() => abort(\"'reallyNegative' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"unSign\")) Module[\"unSign\"] = (() => abort(\"'unSign' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"reSign\")) Module[\"reSign\"] = (() => abort(\"'reSign' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"formatString\")) Module[\"formatString\"] = (() => abort(\"'formatString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH\")) Module[\"PATH\"] = (() => abort(\"'PATH' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH_FS\")) Module[\"PATH_FS\"] = (() => abort(\"'PATH_FS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SYSCALLS\")) Module[\"SYSCALLS\"] = (() => abort(\"'SYSCALLS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"syscallMmap2\")) Module[\"syscallMmap2\"] = (() => abort(\"'syscallMmap2' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"syscallMunmap\")) Module[\"syscallMunmap\"] = (() => abort(\"'syscallMunmap' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getSocketFromFD\")) Module[\"getSocketFromFD\"] = (() => abort(\"'getSocketFromFD' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getSocketAddress\")) Module[\"getSocketAddress\"] = (() => abort(\"'getSocketAddress' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"JSEvents\")) Module[\"JSEvents\"] = (() => abort(\"'JSEvents' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerKeyEventCallback\")) Module[\"registerKeyEventCallback\"] = (() => abort(\"'registerKeyEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"specialHTMLTargets\")) Module[\"specialHTMLTargets\"] = (() => abort(\"'specialHTMLTargets' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"maybeCStringToJsString\")) Module[\"maybeCStringToJsString\"] = (() => abort(\"'maybeCStringToJsString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"findEventTarget\")) Module[\"findEventTarget\"] = (() => abort(\"'findEventTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"findCanvasEventTarget\")) Module[\"findCanvasEventTarget\"] = (() => abort(\"'findCanvasEventTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getBoundingClientRect\")) Module[\"getBoundingClientRect\"] = (() => abort(\"'getBoundingClientRect' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillMouseEventData\")) Module[\"fillMouseEventData\"] = (() => abort(\"'fillMouseEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerMouseEventCallback\")) Module[\"registerMouseEventCallback\"] = (() => abort(\"'registerMouseEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerWheelEventCallback\")) Module[\"registerWheelEventCallback\"] = (() => abort(\"'registerWheelEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerUiEventCallback\")) Module[\"registerUiEventCallback\"] = (() => abort(\"'registerUiEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFocusEventCallback\")) Module[\"registerFocusEventCallback\"] = (() => abort(\"'registerFocusEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillDeviceOrientationEventData\")) Module[\"fillDeviceOrientationEventData\"] = (() => abort(\"'fillDeviceOrientationEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerDeviceOrientationEventCallback\")) Module[\"registerDeviceOrientationEventCallback\"] = (() => abort(\"'registerDeviceOrientationEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillDeviceMotionEventData\")) Module[\"fillDeviceMotionEventData\"] = (() => abort(\"'fillDeviceMotionEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerDeviceMotionEventCallback\")) Module[\"registerDeviceMotionEventCallback\"] = (() => abort(\"'registerDeviceMotionEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"screenOrientation\")) Module[\"screenOrientation\"] = (() => abort(\"'screenOrientation' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillOrientationChangeEventData\")) Module[\"fillOrientationChangeEventData\"] = (() => abort(\"'fillOrientationChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerOrientationChangeEventCallback\")) Module[\"registerOrientationChangeEventCallback\"] = (() => abort(\"'registerOrientationChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillFullscreenChangeEventData\")) Module[\"fillFullscreenChangeEventData\"] = (() => abort(\"'fillFullscreenChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFullscreenChangeEventCallback\")) Module[\"registerFullscreenChangeEventCallback\"] = (() => abort(\"'registerFullscreenChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerRestoreOldStyle\")) Module[\"registerRestoreOldStyle\"] = (() => abort(\"'registerRestoreOldStyle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"hideEverythingExceptGivenElement\")) Module[\"hideEverythingExceptGivenElement\"] = (() => abort(\"'hideEverythingExceptGivenElement' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"restoreHiddenElements\")) Module[\"restoreHiddenElements\"] = (() => abort(\"'restoreHiddenElements' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setLetterbox\")) Module[\"setLetterbox\"] = (() => abort(\"'setLetterbox' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"currentFullscreenStrategy\")) Module[\"currentFullscreenStrategy\"] = (() => abort(\"'currentFullscreenStrategy' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"restoreOldWindowedStyle\")) Module[\"restoreOldWindowedStyle\"] = (() => abort(\"'restoreOldWindowedStyle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"softFullscreenResizeWebGLRenderTarget\")) Module[\"softFullscreenResizeWebGLRenderTarget\"] = (() => abort(\"'softFullscreenResizeWebGLRenderTarget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"doRequestFullscreen\")) Module[\"doRequestFullscreen\"] = (() => abort(\"'doRequestFullscreen' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillPointerlockChangeEventData\")) Module[\"fillPointerlockChangeEventData\"] = (() => abort(\"'fillPointerlockChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerPointerlockChangeEventCallback\")) Module[\"registerPointerlockChangeEventCallback\"] = (() => abort(\"'registerPointerlockChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerPointerlockErrorEventCallback\")) Module[\"registerPointerlockErrorEventCallback\"] = (() => abort(\"'registerPointerlockErrorEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"requestPointerLock\")) Module[\"requestPointerLock\"] = (() => abort(\"'requestPointerLock' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillVisibilityChangeEventData\")) Module[\"fillVisibilityChangeEventData\"] = (() => abort(\"'fillVisibilityChangeEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerVisibilityChangeEventCallback\")) Module[\"registerVisibilityChangeEventCallback\"] = (() => abort(\"'registerVisibilityChangeEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerTouchEventCallback\")) Module[\"registerTouchEventCallback\"] = (() => abort(\"'registerTouchEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillGamepadEventData\")) Module[\"fillGamepadEventData\"] = (() => abort(\"'fillGamepadEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerGamepadEventCallback\")) Module[\"registerGamepadEventCallback\"] = (() => abort(\"'registerGamepadEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerBeforeUnloadEventCallback\")) Module[\"registerBeforeUnloadEventCallback\"] = (() => abort(\"'registerBeforeUnloadEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"fillBatteryEventData\")) Module[\"fillBatteryEventData\"] = (() => abort(\"'fillBatteryEventData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"battery\")) Module[\"battery\"] = (() => abort(\"'battery' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerBatteryEventCallback\")) Module[\"registerBatteryEventCallback\"] = (() => abort(\"'registerBatteryEventCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setCanvasElementSize\")) Module[\"setCanvasElementSize\"] = (() => abort(\"'setCanvasElementSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getCanvasElementSize\")) Module[\"getCanvasElementSize\"] = (() => abort(\"'getCanvasElementSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"demangle\")) Module[\"demangle\"] = (() => abort(\"'demangle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"demangleAll\")) Module[\"demangleAll\"] = (() => abort(\"'demangleAll' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"jsStackTrace\")) Module[\"jsStackTrace\"] = (() => abort(\"'jsStackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = (() => abort(\"'stackTrace' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getEnvStrings\")) Module[\"getEnvStrings\"] = (() => abort(\"'getEnvStrings' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"checkWasiClock\")) Module[\"checkWasiClock\"] = (() => abort(\"'checkWasiClock' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64\")) Module[\"writeI53ToI64\"] = (() => abort(\"'writeI53ToI64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Clamped\")) Module[\"writeI53ToI64Clamped\"] = (() => abort(\"'writeI53ToI64Clamped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Signaling\")) Module[\"writeI53ToI64Signaling\"] = (() => abort(\"'writeI53ToI64Signaling' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Clamped\")) Module[\"writeI53ToU64Clamped\"] = (() => abort(\"'writeI53ToU64Clamped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Signaling\")) Module[\"writeI53ToU64Signaling\"] = (() => abort(\"'writeI53ToU64Signaling' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readI53FromI64\")) Module[\"readI53FromI64\"] = (() => abort(\"'readI53FromI64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readI53FromU64\")) Module[\"readI53FromU64\"] = (() => abort(\"'readI53FromU64' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"convertI32PairToI53\")) Module[\"convertI32PairToI53\"] = (() => abort(\"'convertI32PairToI53' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"convertU32PairToI53\")) Module[\"convertU32PairToI53\"] = (() => abort(\"'convertU32PairToI53' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setImmediateWrapped\")) Module[\"setImmediateWrapped\"] = (() => abort(\"'setImmediateWrapped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"clearImmediateWrapped\")) Module[\"clearImmediateWrapped\"] = (() => abort(\"'clearImmediateWrapped' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"polyfillSetImmediate\")) Module[\"polyfillSetImmediate\"] = (() => abort(\"'polyfillSetImmediate' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"uncaughtExceptionCount\")) Module[\"uncaughtExceptionCount\"] = (() => abort(\"'uncaughtExceptionCount' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"exceptionLast\")) Module[\"exceptionLast\"] = (() => abort(\"'exceptionLast' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"exceptionCaught\")) Module[\"exceptionCaught\"] = (() => abort(\"'exceptionCaught' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ExceptionInfo\")) Module[\"ExceptionInfo\"] = (() => abort(\"'ExceptionInfo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"CatchInfo\")) Module[\"CatchInfo\"] = (() => abort(\"'CatchInfo' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"exception_addRef\")) Module[\"exception_addRef\"] = (() => abort(\"'exception_addRef' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"exception_decRef\")) Module[\"exception_decRef\"] = (() => abort(\"'exception_decRef' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"Browser\")) Module[\"Browser\"] = (() => abort(\"'Browser' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"funcWrappers\")) Module[\"funcWrappers\"] = (() => abort(\"'funcWrappers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = (() => abort(\"'getFuncWrapper' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setMainLoop\")) Module[\"setMainLoop\"] = (() => abort(\"'setMainLoop' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"wget\")) Module[\"wget\"] = (() => abort(\"'wget' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"FS\")) Module[\"FS\"] = (() => abort(\"'FS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"MEMFS\")) Module[\"MEMFS\"] = (() => abort(\"'MEMFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"TTY\")) Module[\"TTY\"] = (() => abort(\"'TTY' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"PIPEFS\")) Module[\"PIPEFS\"] = (() => abort(\"'PIPEFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SOCKFS\")) Module[\"SOCKFS\"] = (() => abort(\"'SOCKFS' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"_setNetworkCallback\")) Module[\"_setNetworkCallback\"] = (() => abort(\"'_setNetworkCallback' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"tempFixedLengthArray\")) Module[\"tempFixedLengthArray\"] = (() => abort(\"'tempFixedLengthArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"miniTempWebGLFloatBuffers\")) Module[\"miniTempWebGLFloatBuffers\"] = (() => abort(\"'miniTempWebGLFloatBuffers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"heapObjectForWebGLType\")) Module[\"heapObjectForWebGLType\"] = (() => abort(\"'heapObjectForWebGLType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"heapAccessShiftForWebGLHeap\")) Module[\"heapAccessShiftForWebGLHeap\"] = (() => abort(\"'heapAccessShiftForWebGLHeap' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"GL\")) Module[\"GL\"] = (() => abort(\"'GL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet\")) Module[\"emscriptenWebGLGet\"] = (() => abort(\"'emscriptenWebGLGet' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"computeUnpackAlignedImageSize\")) Module[\"computeUnpackAlignedImageSize\"] = (() => abort(\"'computeUnpackAlignedImageSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData\")) Module[\"emscriptenWebGLGetTexPixelData\"] = (() => abort(\"'emscriptenWebGLGetTexPixelData' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform\")) Module[\"emscriptenWebGLGetUniform\"] = (() => abort(\"'emscriptenWebGLGetUniform' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"webglGetUniformLocation\")) Module[\"webglGetUniformLocation\"] = (() => abort(\"'webglGetUniformLocation' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"webglPrepareUniformLocationsBeforeFirstUse\")) Module[\"webglPrepareUniformLocationsBeforeFirstUse\"] = (() => abort(\"'webglPrepareUniformLocationsBeforeFirstUse' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"webglGetLeftBracePos\")) Module[\"webglGetLeftBracePos\"] = (() => abort(\"'webglGetLeftBracePos' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib\")) Module[\"emscriptenWebGLGetVertexAttrib\"] = (() => abort(\"'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"writeGLArray\")) Module[\"writeGLArray\"] = (() => abort(\"'writeGLArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"AL\")) Module[\"AL\"] = (() => abort(\"'AL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_unicode\")) Module[\"SDL_unicode\"] = (() => abort(\"'SDL_unicode' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_ttfContext\")) Module[\"SDL_ttfContext\"] = (() => abort(\"'SDL_ttfContext' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_audio\")) Module[\"SDL_audio\"] = (() => abort(\"'SDL_audio' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL\")) Module[\"SDL\"] = (() => abort(\"'SDL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_gfx\")) Module[\"SDL_gfx\"] = (() => abort(\"'SDL_gfx' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"GLUT\")) Module[\"GLUT\"] = (() => abort(\"'GLUT' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"EGL\")) Module[\"EGL\"] = (() => abort(\"'EGL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"GLFW_Window\")) Module[\"GLFW_Window\"] = (() => abort(\"'GLFW_Window' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"GLFW\")) Module[\"GLFW\"] = (() => abort(\"'GLFW' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"GLEW\")) Module[\"GLEW\"] = (() => abort(\"'GLEW' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"IDBStore\")) Module[\"IDBStore\"] = (() => abort(\"'IDBStore' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"runAndAbortIfError\")) Module[\"runAndAbortIfError\"] = (() => abort(\"'runAndAbortIfError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"InternalError\")) Module[\"InternalError\"] = (() => abort(\"'InternalError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"BindingError\")) Module[\"BindingError\"] = (() => abort(\"'BindingError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"UnboundTypeError\")) Module[\"UnboundTypeError\"] = (() => abort(\"'UnboundTypeError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"PureVirtualError\")) Module[\"PureVirtualError\"] = (() => abort(\"'PureVirtualError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"init_embind\")) Module[\"init_embind\"] = (() => abort(\"'init_embind' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"throwInternalError\")) Module[\"throwInternalError\"] = (() => abort(\"'throwInternalError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"throwBindingError\")) Module[\"throwBindingError\"] = (() => abort(\"'throwBindingError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"throwUnboundTypeError\")) Module[\"throwUnboundTypeError\"] = (() => abort(\"'throwUnboundTypeError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ensureOverloadTable\")) Module[\"ensureOverloadTable\"] = (() => abort(\"'ensureOverloadTable' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"exposePublicSymbol\")) Module[\"exposePublicSymbol\"] = (() => abort(\"'exposePublicSymbol' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"replacePublicSymbol\")) Module[\"replacePublicSymbol\"] = (() => abort(\"'replacePublicSymbol' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"extendError\")) Module[\"extendError\"] = (() => abort(\"'extendError' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"createNamedFunction\")) Module[\"createNamedFunction\"] = (() => abort(\"'createNamedFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registeredInstances\")) Module[\"registeredInstances\"] = (() => abort(\"'registeredInstances' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getBasestPointer\")) Module[\"getBasestPointer\"] = (() => abort(\"'getBasestPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerInheritedInstance\")) Module[\"registerInheritedInstance\"] = (() => abort(\"'registerInheritedInstance' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"unregisterInheritedInstance\")) Module[\"unregisterInheritedInstance\"] = (() => abort(\"'unregisterInheritedInstance' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getInheritedInstance\")) Module[\"getInheritedInstance\"] = (() => abort(\"'getInheritedInstance' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getInheritedInstanceCount\")) Module[\"getInheritedInstanceCount\"] = (() => abort(\"'getInheritedInstanceCount' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getLiveInheritedInstances\")) Module[\"getLiveInheritedInstances\"] = (() => abort(\"'getLiveInheritedInstances' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registeredTypes\")) Module[\"registeredTypes\"] = (() => abort(\"'registeredTypes' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"awaitingDependencies\")) Module[\"awaitingDependencies\"] = (() => abort(\"'awaitingDependencies' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"typeDependencies\")) Module[\"typeDependencies\"] = (() => abort(\"'typeDependencies' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registeredPointers\")) Module[\"registeredPointers\"] = (() => abort(\"'registeredPointers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"registerType\")) Module[\"registerType\"] = (() => abort(\"'registerType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"whenDependentTypesAreResolved\")) Module[\"whenDependentTypesAreResolved\"] = (() => abort(\"'whenDependentTypesAreResolved' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"embind_charCodes\")) Module[\"embind_charCodes\"] = (() => abort(\"'embind_charCodes' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"embind_init_charCodes\")) Module[\"embind_init_charCodes\"] = (() => abort(\"'embind_init_charCodes' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"readLatin1String\")) Module[\"readLatin1String\"] = (() => abort(\"'readLatin1String' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getTypeName\")) Module[\"getTypeName\"] = (() => abort(\"'getTypeName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"heap32VectorToArray\")) Module[\"heap32VectorToArray\"] = (() => abort(\"'heap32VectorToArray' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"requireRegisteredType\")) Module[\"requireRegisteredType\"] = (() => abort(\"'requireRegisteredType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getShiftFromSize\")) Module[\"getShiftFromSize\"] = (() => abort(\"'getShiftFromSize' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"integerReadValueFromPointer\")) Module[\"integerReadValueFromPointer\"] = (() => abort(\"'integerReadValueFromPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"enumReadValueFromPointer\")) Module[\"enumReadValueFromPointer\"] = (() => abort(\"'enumReadValueFromPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"floatReadValueFromPointer\")) Module[\"floatReadValueFromPointer\"] = (() => abort(\"'floatReadValueFromPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"simpleReadValueFromPointer\")) Module[\"simpleReadValueFromPointer\"] = (() => abort(\"'simpleReadValueFromPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"runDestructors\")) Module[\"runDestructors\"] = (() => abort(\"'runDestructors' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"new_\")) Module[\"new_\"] = (() => abort(\"'new_' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"craftInvokerFunction\")) Module[\"craftInvokerFunction\"] = (() => abort(\"'craftInvokerFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"embind__requireFunction\")) Module[\"embind__requireFunction\"] = (() => abort(\"'embind__requireFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"tupleRegistrations\")) Module[\"tupleRegistrations\"] = (() => abort(\"'tupleRegistrations' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"structRegistrations\")) Module[\"structRegistrations\"] = (() => abort(\"'structRegistrations' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"genericPointerToWireType\")) Module[\"genericPointerToWireType\"] = (() => abort(\"'genericPointerToWireType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"constNoSmartPtrRawPointerToWireType\")) Module[\"constNoSmartPtrRawPointerToWireType\"] = (() => abort(\"'constNoSmartPtrRawPointerToWireType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"nonConstNoSmartPtrRawPointerToWireType\")) Module[\"nonConstNoSmartPtrRawPointerToWireType\"] = (() => abort(\"'nonConstNoSmartPtrRawPointerToWireType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"init_RegisteredPointer\")) Module[\"init_RegisteredPointer\"] = (() => abort(\"'init_RegisteredPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer\")) Module[\"RegisteredPointer\"] = (() => abort(\"'RegisteredPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_getPointee\")) Module[\"RegisteredPointer_getPointee\"] = (() => abort(\"'RegisteredPointer_getPointee' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_destructor\")) Module[\"RegisteredPointer_destructor\"] = (() => abort(\"'RegisteredPointer_destructor' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_deleteObject\")) Module[\"RegisteredPointer_deleteObject\"] = (() => abort(\"'RegisteredPointer_deleteObject' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredPointer_fromWireType\")) Module[\"RegisteredPointer_fromWireType\"] = (() => abort(\"'RegisteredPointer_fromWireType' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"runDestructor\")) Module[\"runDestructor\"] = (() => abort(\"'runDestructor' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"releaseClassHandle\")) Module[\"releaseClassHandle\"] = (() => abort(\"'releaseClassHandle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"finalizationRegistry\")) Module[\"finalizationRegistry\"] = (() => abort(\"'finalizationRegistry' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"detachFinalizer_deps\")) Module[\"detachFinalizer_deps\"] = (() => abort(\"'detachFinalizer_deps' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"detachFinalizer\")) Module[\"detachFinalizer\"] = (() => abort(\"'detachFinalizer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"attachFinalizer\")) Module[\"attachFinalizer\"] = (() => abort(\"'attachFinalizer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"makeClassHandle\")) Module[\"makeClassHandle\"] = (() => abort(\"'makeClassHandle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"init_ClassHandle\")) Module[\"init_ClassHandle\"] = (() => abort(\"'init_ClassHandle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle\")) Module[\"ClassHandle\"] = (() => abort(\"'ClassHandle' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_isAliasOf\")) Module[\"ClassHandle_isAliasOf\"] = (() => abort(\"'ClassHandle_isAliasOf' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"throwInstanceAlreadyDeleted\")) Module[\"throwInstanceAlreadyDeleted\"] = (() => abort(\"'throwInstanceAlreadyDeleted' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_clone\")) Module[\"ClassHandle_clone\"] = (() => abort(\"'ClassHandle_clone' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_delete\")) Module[\"ClassHandle_delete\"] = (() => abort(\"'ClassHandle_delete' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"deletionQueue\")) Module[\"deletionQueue\"] = (() => abort(\"'deletionQueue' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_isDeleted\")) Module[\"ClassHandle_isDeleted\"] = (() => abort(\"'ClassHandle_isDeleted' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ClassHandle_deleteLater\")) Module[\"ClassHandle_deleteLater\"] = (() => abort(\"'ClassHandle_deleteLater' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"flushPendingDeletes\")) Module[\"flushPendingDeletes\"] = (() => abort(\"'flushPendingDeletes' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"delayFunction\")) Module[\"delayFunction\"] = (() => abort(\"'delayFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"setDelayFunction\")) Module[\"setDelayFunction\"] = (() => abort(\"'setDelayFunction' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"RegisteredClass\")) Module[\"RegisteredClass\"] = (() => abort(\"'RegisteredClass' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"shallowCopyInternalPointer\")) Module[\"shallowCopyInternalPointer\"] = (() => abort(\"'shallowCopyInternalPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"downcastPointer\")) Module[\"downcastPointer\"] = (() => abort(\"'downcastPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"upcastPointer\")) Module[\"upcastPointer\"] = (() => abort(\"'upcastPointer' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"validateThis\")) Module[\"validateThis\"] = (() => abort(\"'validateThis' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"char_0\")) Module[\"char_0\"] = (() => abort(\"'char_0' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"char_9\")) Module[\"char_9\"] = (() => abort(\"'char_9' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"makeLegalFunctionName\")) Module[\"makeLegalFunctionName\"] = (() => abort(\"'makeLegalFunctionName' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_handle_array\")) Module[\"emval_handle_array\"] = (() => abort(\"'emval_handle_array' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_free_list\")) Module[\"emval_free_list\"] = (() => abort(\"'emval_free_list' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_symbols\")) Module[\"emval_symbols\"] = (() => abort(\"'emval_symbols' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"init_emval\")) Module[\"init_emval\"] = (() => abort(\"'init_emval' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"count_emval_handles\")) Module[\"count_emval_handles\"] = (() => abort(\"'count_emval_handles' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"get_first_emval\")) Module[\"get_first_emval\"] = (() => abort(\"'get_first_emval' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"getStringOrSymbol\")) Module[\"getStringOrSymbol\"] = (() => abort(\"'getStringOrSymbol' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"Emval\")) Module[\"Emval\"] = (() => abort(\"'Emval' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_newers\")) Module[\"emval_newers\"] = (() => abort(\"'emval_newers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"craftEmvalAllocator\")) Module[\"craftEmvalAllocator\"] = (() => abort(\"'craftEmvalAllocator' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_get_global\")) Module[\"emval_get_global\"] = (() => abort(\"'emval_get_global' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_methodCallers\")) Module[\"emval_methodCallers\"] = (() => abort(\"'emval_methodCallers' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"emval_registeredMethods\")) Module[\"emval_registeredMethods\"] = (() => abort(\"'emval_registeredMethods' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"warnOnce\")) Module[\"warnOnce\"] = (() => abort(\"'warnOnce' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stackSave\")) Module[\"stackSave\"] = (() => abort(\"'stackSave' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stackRestore\")) Module[\"stackRestore\"] = (() => abort(\"'stackRestore' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stackAlloc\")) Module[\"stackAlloc\"] = (() => abort(\"'stackAlloc' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"AsciiToString\")) Module[\"AsciiToString\"] = (() => abort(\"'AsciiToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToAscii\")) Module[\"stringToAscii\"] = (() => abort(\"'stringToAscii' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF16ToString\")) Module[\"UTF16ToString\"] = (() => abort(\"'UTF16ToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF16\")) Module[\"stringToUTF16\"] = (() => abort(\"'stringToUTF16' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF16\")) Module[\"lengthBytesUTF16\"] = (() => abort(\"'lengthBytesUTF16' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF32ToString\")) Module[\"UTF32ToString\"] = (() => abort(\"'UTF32ToString' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF32\")) Module[\"stringToUTF32\"] = (() => abort(\"'stringToUTF32' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF32\")) Module[\"lengthBytesUTF32\"] = (() => abort(\"'lengthBytesUTF32' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8\")) Module[\"allocateUTF8\"] = (() => abort(\"'allocateUTF8' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nif (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8OnStack\")) Module[\"allocateUTF8OnStack\"] = (() => abort(\"'allocateUTF8OnStack' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\"));\n\nModule[\"writeStackCookie\"] = writeStackCookie;\n\nModule[\"checkStackCookie\"] = checkStackCookie;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NORMAL\")) Object.defineProperty(Module, \"ALLOC_NORMAL\", {\n configurable: true,\n get: function() {\n  abort(\"'ALLOC_NORMAL' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n }\n});\n\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_STACK\")) Object.defineProperty(Module, \"ALLOC_STACK\", {\n configurable: true,\n get: function() {\n  abort(\"'ALLOC_STACK' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n }\n});\n\nvar calledRun;\n\nfunction ExitStatus(status) {\n this.name = \"ExitStatus\";\n this.message = \"Program terminated with exit(\" + status + \")\";\n this.status = status;\n}\n\ndependenciesFulfilled = function runCaller() {\n if (!calledRun) run();\n if (!calledRun) dependenciesFulfilled = runCaller;\n};\n\nfunction stackCheckInit() {\n _emscripten_stack_init();\n writeStackCookie();\n}\n\nfunction run(args) {\n args = args || arguments_;\n if (runDependencies > 0) {\n  return;\n }\n stackCheckInit();\n preRun();\n if (runDependencies > 0) {\n  return;\n }\n function doRun() {\n  if (calledRun) return;\n  calledRun = true;\n  Module[\"calledRun\"] = true;\n  if (ABORT) return;\n  initRuntime();\n  readyPromiseResolve(Module);\n  if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n  assert(!Module[\"_main\"], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n  postRun();\n }\n if (Module[\"setStatus\"]) {\n  Module[\"setStatus\"](\"Running...\");\n  setTimeout(function() {\n   setTimeout(function() {\n    Module[\"setStatus\"](\"\");\n   }, 1);\n   doRun();\n  }, 1);\n } else {\n  doRun();\n }\n checkStackCookie();\n}\n\nModule[\"run\"] = run;\n\nfunction procExit(code) {\n EXITSTATUS = code;\n if (!keepRuntimeAlive()) {\n  if (Module[\"onExit\"]) Module[\"onExit\"](code);\n  ABORT = true;\n }\n quit_(code, new ExitStatus(code));\n}\n\nif (Module[\"preInit\"]) {\n if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [ Module[\"preInit\"] ];\n while (Module[\"preInit\"].length > 0) {\n  Module[\"preInit\"].pop()();\n }\n}\n\nrun();\n\n\n  return createMLSGenModule.ready\n}\n);\n})();\nif (true)\n  module.exports = createMLSGenModule;\nelse {}\n\n\n//# sourceURL=webpack://speakerCalibrator/./dist/mlsGen.js?");

/***/ }),

/***/ "./node_modules/chart.js/dist/chart.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/chart.js/dist/chart.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaults\": () => (/* reexport safe */ _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   \"Animation\": () => (/* binding */ Animation),\n/* harmony export */   \"Animations\": () => (/* binding */ Animations),\n/* harmony export */   \"ArcElement\": () => (/* binding */ ArcElement),\n/* harmony export */   \"BarController\": () => (/* binding */ BarController),\n/* harmony export */   \"BarElement\": () => (/* binding */ BarElement),\n/* harmony export */   \"BasePlatform\": () => (/* binding */ BasePlatform),\n/* harmony export */   \"BasicPlatform\": () => (/* binding */ BasicPlatform),\n/* harmony export */   \"BubbleController\": () => (/* binding */ BubbleController),\n/* harmony export */   \"CategoryScale\": () => (/* binding */ CategoryScale),\n/* harmony export */   \"Chart\": () => (/* binding */ Chart),\n/* harmony export */   \"DatasetController\": () => (/* binding */ DatasetController),\n/* harmony export */   \"Decimation\": () => (/* binding */ plugin_decimation),\n/* harmony export */   \"DomPlatform\": () => (/* binding */ DomPlatform),\n/* harmony export */   \"DoughnutController\": () => (/* binding */ DoughnutController),\n/* harmony export */   \"Element\": () => (/* binding */ Element),\n/* harmony export */   \"Filler\": () => (/* binding */ plugin_filler),\n/* harmony export */   \"Interaction\": () => (/* binding */ Interaction),\n/* harmony export */   \"Legend\": () => (/* binding */ plugin_legend),\n/* harmony export */   \"LineController\": () => (/* binding */ LineController),\n/* harmony export */   \"LineElement\": () => (/* binding */ LineElement),\n/* harmony export */   \"LinearScale\": () => (/* binding */ LinearScale),\n/* harmony export */   \"LogarithmicScale\": () => (/* binding */ LogarithmicScale),\n/* harmony export */   \"PieController\": () => (/* binding */ PieController),\n/* harmony export */   \"PointElement\": () => (/* binding */ PointElement),\n/* harmony export */   \"PolarAreaController\": () => (/* binding */ PolarAreaController),\n/* harmony export */   \"RadarController\": () => (/* binding */ RadarController),\n/* harmony export */   \"RadialLinearScale\": () => (/* binding */ RadialLinearScale),\n/* harmony export */   \"Scale\": () => (/* binding */ Scale),\n/* harmony export */   \"ScatterController\": () => (/* binding */ ScatterController),\n/* harmony export */   \"SubTitle\": () => (/* binding */ plugin_subtitle),\n/* harmony export */   \"Ticks\": () => (/* binding */ Ticks),\n/* harmony export */   \"TimeScale\": () => (/* binding */ TimeScale),\n/* harmony export */   \"TimeSeriesScale\": () => (/* binding */ TimeSeriesScale),\n/* harmony export */   \"Title\": () => (/* binding */ plugin_title),\n/* harmony export */   \"Tooltip\": () => (/* binding */ plugin_tooltip),\n/* harmony export */   \"_adapters\": () => (/* binding */ adapters),\n/* harmony export */   \"_detectPlatform\": () => (/* binding */ _detectPlatform),\n/* harmony export */   \"animator\": () => (/* binding */ animator),\n/* harmony export */   \"controllers\": () => (/* binding */ controllers),\n/* harmony export */   \"elements\": () => (/* binding */ elements),\n/* harmony export */   \"layouts\": () => (/* binding */ layouts),\n/* harmony export */   \"plugins\": () => (/* binding */ plugins),\n/* harmony export */   \"registerables\": () => (/* binding */ registerables),\n/* harmony export */   \"registry\": () => (/* binding */ registry),\n/* harmony export */   \"scales\": () => (/* binding */ scales)\n/* harmony export */ });\n/* harmony import */ var _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.segment.js */ \"./node_modules/chart.js/dist/chunks/helpers.segment.js\");\n/*!\n * Chart.js v3.7.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\n\n\n\nclass Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n    this._request = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.r.call(window, () => {\n      this._update();\n      this._request = null;\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n  _update(date = Date.now()) {\n    let remaining = 0;\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n      for (; i >= 0; --i) {\n        item = items[i];\n        if (item._active) {\n          if (item._total > anims.duration) {\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n      remaining += items.length;\n    });\n    this._lastDate = date;\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\nvar animator = new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  color(from, to, factor) {\n    const c0 = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.c)(from || transparent);\n    const c1 = c0.valid && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.c)(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\nclass Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n    to = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a)([cfg.to, to, currentValue, cfg.from]);\n    const from = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a)([cfg.from, currentValue, to]);\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.e[cfg.easing] || _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.e.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n  active() {\n    return this._active;\n  }\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a)([cfg.to, to, currentValue, cfg.from]);\n      this._from = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a)([cfg.from, currentValue, to]);\n    }\n  }\n  cancel() {\n    if (this._active) {\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n    this._active = from !== to && (loop || (elapsed < duration));\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n    this._target[prop] = this._fn(from, to, factor);\n  }\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set('animation', {\n  delay: undefined,\n  duration: 1000,\n  easing: 'easeOutQuart',\n  fn: undefined,\n  from: undefined,\n  loop: undefined,\n  to: undefined,\n  type: undefined,\n});\nconst animationOptions = Object.keys(_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.animation);\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe('animation', {\n  _fallback: false,\n  _indexable: false,\n  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n});\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set('animations', {\n  colors: {\n    type: 'color',\n    properties: colors\n  },\n  numbers: {\n    type: 'number',\n    properties: numbers\n  },\n});\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe('animations', {\n  _fallback: 'animation',\n});\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set('transitions', {\n  active: {\n    animation: {\n      duration: 400\n    }\n  },\n  resize: {\n    animation: {\n      duration: 0\n    }\n  },\n  show: {\n    animations: {\n      colors: {\n        from: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        duration: 0\n      },\n    }\n  },\n  hide: {\n    animations: {\n      colors: {\n        to: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        easing: 'linear',\n        fn: v => v | 0\n      },\n    }\n  }\n});\nclass Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n  configure(config) {\n    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(config)) {\n      return;\n    }\n    const animatedProps = this._properties;\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n      ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n      });\n    }\n    return animations;\n  }\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n      if (animation) {\n        if (cfg && animation.active()) {\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        target[prop] = value;\n        continue;\n      }\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n  update(target, values) {\n    if (this._properties.size === 0) {\n      Object.assign(target, values);\n      return;\n    }\n    const animations = this._createAnimations(target, values);\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\nfunction toClip(value) {\n  let t, r, b, l;\n  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n  if (value === null) {\n    return;\n  }\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(otherValue) && (singleMode || (value === 0 || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) === (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(otherValue)))) {\n      value += otherValue;\n    }\n  }\n  return value;\n}\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n  return adata;\n}\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n  return null;\n}\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {});\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n  }\n}\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n  return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\nfunction createDataContext(parent, index, element) {\n  return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\nfunction clearStacks(meta, items) {\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n  }\n}\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\nclass DatasetController {\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.initialize();\n  }\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n  }\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n    const xid = meta.xAxisID = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n  reset() {\n    this._update('reset');\n  }\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.u)(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n      this._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.u)(_data, this);\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.l)(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n  addElements() {\n    const meta = this._cachedMeta;\n    this._dataCheck();\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n    this._dataCheck();\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n    this._resyncElements(resetNewElements);\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n    }\n  }\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, xAxisKey), index),\n        y: yScale.parse((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        break;\n      }\n    }\n    if (sorted) {\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n  getMaxOverflow() {\n    return false;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n  update(mode) {}\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.elements[elementType]);\n    const context = () => this.getContext(index, active);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n    if (values.$shared) {\n      values.$shared = sharing;\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n    return values;\n  }\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n    if (count) {\n      this.parse(0, count);\n    }\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n  updateElements(element, start, count, mode) {}\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\nDatasetController.defaults = {};\nDatasetController.prototype.datasetElementType = null;\nDatasetController.prototype.dataElementType = null;\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      return;\n    }\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(prev)) {\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n  return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n  if (prev === null) {\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n  if (next === null) {\n    next = curr + curr - prev;\n  }\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n  item[vScale.axis] = barEnd;\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\nfunction parseValue(entry, item, vScale, i) {\n  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\nclass BarController extends DatasetController {\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, iAxisKey), i);\n      parsed.push(parseValue((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n  getMaxOverflow() {\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n  _getStacks(last, dataIndex) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const metasets = iScale.getMatchingVisibleMetas(this._type);\n    const stacked = iScale.options.stacked;\n    const ilen = metasets.length;\n    const stacks = [];\n    let i, item;\n    for (i = 0; i < ilen; ++i) {\n      item = metasets[i];\n      if (!item.controller.options.grouped) {\n        continue;\n      }\n      if (typeof dataIndex !== 'undefined') {\n        const val = item.controller.getParsed(dataIndex)[\n          item.controller._cachedMeta.vScale.axis\n        ];\n        if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(val) || isNaN(val)) {\n          continue;\n        }\n      }\n      if (stacked === false || stacks.indexOf(item.stack) === -1 ||\n\t\t\t\t(stacked === undefined && item.stack === undefined)) {\n        stacks.push(item.stack);\n      }\n      if (item.index === last) {\n        break;\n      }\n    }\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n    return stacks;\n  }\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1;\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      if (value !== 0 && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) !== (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n    const startValue = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      head = base;\n    }\n    size = head - base;\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      head = base + size;\n    }\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n}\nBarController.id = 'bar';\nBarController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'bar',\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: true,\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'base', 'width', 'height']\n    }\n  }\n};\nBarController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n      offset: true,\n      grid: {\n        offset: true\n      }\n    },\n    _value_: {\n      type: 'linear',\n      beginAtZero: true,\n    }\n  }\n};\n\nclass BubbleController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n    return {\n      label: meta.label,\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n  update(mode) {\n    const points = this._cachedMeta.data;\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n      if (includeOptions) {\n        properties.options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n      this.updateElement(point, i, properties, mode);\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(parsed && parsed._custom, radius);\n    return values;\n  }\n}\nBubbleController.id = 'bubble';\nBubbleController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'borderWidth', 'radius']\n    }\n  }\n};\nBubbleController.overrides = {\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        }\n      }\n    }\n  }\n};\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  if (circumference < _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n    const minX = calcMin(_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P, startX, endX);\n    const minY = calcMin(_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\nclass DoughnutController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n  linkScales() {}\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(data[i], key);\n      }\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n  _getRotation() {\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.rotation - 90);\n  }\n  _getCircumference() {\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.circumference);\n  }\n  _getRotationExtents() {\n    let min = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T;\n    let max = -_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T;\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.m)(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.n)(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n    meta.total = this.calculateTotal();\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T);\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    let startAngle = this._getRotation();\n    let i;\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n      this.updateElement(arc, i, properties, mode);\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n    return total;\n  }\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index], chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n    if (!arcs) {\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n    if (!arcs) {\n      return 0;\n    }\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n  getMaxOffset(arcs) {\n    let max = 0;\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n    return ringWeightOffset;\n  }\n  _getRingWeight(datasetIndex) {\n    return Math.max((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\nDoughnutController.id = 'doughnut';\nDoughnutController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: false\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n    },\n  },\n  cutout: '50%',\n  rotation: 0,\n  circumference: 360,\n  radius: '100%',\n  spacing: 0,\n  indexAxis: 'r',\n};\nDoughnutController.descriptors = {\n  _scriptable: (name) => name !== 'spacing',\n  _indexable: (name) => name !== 'spacing',\n};\nDoughnutController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(tooltipItem) {\n          let dataLabel = tooltipItem.label;\n          const value = ': ' + tooltipItem.formattedValue;\n          if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(dataLabel)) {\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n          return dataLabel;\n        }\n      }\n    }\n  }\n};\n\nclass LineController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n    this.updateElements(points, start, count, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\nLineController.id = 'line';\nLineController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  showLine: true,\n  spanGaps: false,\n};\nLineController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n    },\n    _value_: {\n      type: 'linear',\n    },\n  }\n};\nfunction getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n  const pointCount = points.length;\n  let start = 0;\n  let count = pointCount;\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n    if (minDefined) {\n      start = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(Math.min(\n        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.x)(_parsed, iScale.axis, min).lo,\n        animationsDisabled ? pointCount : (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.x)(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(Math.max(\n        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.x)(_parsed, iScale.axis, max).hi + 1,\n        animationsDisabled ? 0 : (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.x)(points, axis, iScale.getPixelForValue(max)).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n  return {start, count};\n}\nfunction scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n\nclass PolarAreaController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index].r, chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const dataset = this.getDataset();\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P;\n    let angle = datasetStartAngle;\n    let i;\n    const defaultAngle = 360 / this.countVisibleElements();\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;\n      angle = endAngle;\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  countVisibleElements() {\n    const dataset = this.getDataset();\n    const meta = this._cachedMeta;\n    let count = 0;\n    meta.data.forEach((element, index) => {\n      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n    return count;\n  }\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\nPolarAreaController.id = 'polarArea';\nPolarAreaController.defaults = {\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: true\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n    },\n  },\n  indexAxis: 'r',\n  startAngle: 0,\n};\nPolarAreaController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(context) {\n          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\n        }\n      }\n    }\n  },\n  scales: {\n    r: {\n      type: 'radialLinear',\n      angleLines: {\n        display: false\n      },\n      beginAtZero: true,\n      grid: {\n        circular: true\n      },\n      pointLabels: {\n        display: false\n      },\n      startAngle: 0\n    }\n  }\n};\n\nclass PieController extends DoughnutController {\n}\nPieController.id = 'pie';\nPieController.defaults = {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: '100%'\n};\n\nclass RadarController extends DatasetController {\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n    line.points = points;\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n      this.updateElement(line, undefined, properties, mode);\n    }\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const dataset = this.getDataset();\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\nRadarController.id = 'radar';\nRadarController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  indexAxis: 'r',\n  showLine: true,\n  elements: {\n    line: {\n      fill: 'start'\n    }\n  },\n};\nRadarController.overrides = {\n  aspectRatio: 1,\n  scales: {\n    r: {\n      type: 'radialLinear',\n    }\n  }\n};\n\nclass ScatterController extends LineController {\n}\nScatterController.id = 'scatter';\nScatterController.defaults = {\n  showLine: false,\n  fill: false\n};\nScatterController.overrides = {\n  interaction: {\n    mode: 'point'\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(item) {\n          return '(' + item.label + ', ' + item.formattedValue + ')';\n        }\n      }\n    }\n  },\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  }\n};\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPolarAreaController: PolarAreaController,\nPieController: PieController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\nfunction abstract() {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\nclass DateAdapter {\n  constructor(options) {\n    this.options = options || {};\n  }\n  formats() {\n    return abstract();\n  }\n  parse(value, format) {\n    return abstract();\n  }\n  format(timestamp, format) {\n    return abstract();\n  }\n  add(timestamp, amount, unit) {\n    return abstract();\n  }\n  diff(a, b, unit) {\n    return abstract();\n  }\n  startOf(timestamp, unit, weekday) {\n    return abstract();\n  }\n  endOf(timestamp, unit) {\n    return abstract();\n  }\n}\nDateAdapter.override = function(members) {\n  Object.assign(DateAdapter.prototype, members);\n};\nvar adapters = {\n  _date: DateAdapter\n};\n\nfunction getRelativePosition(e, chart) {\n  if ('native' in e) {\n    return {\n      x: e.x,\n      y: e.y\n    };\n  }\n  return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.y)(e, chart);\n}\nfunction evaluateAllVisibleItems(chart, handler) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  let index, data, element;\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    ({index, data} = metasets[i]);\n    for (let j = 0, jlen = data.length; j < jlen; ++j) {\n      element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A : _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.x;\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  return {lo: 0, hi: data.length - 1};\n}\nfunction optimizedEvaluateItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition) {\n  const items = [];\n  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.z)(position, chart.chartArea, chart._minPadding)) {\n    return items;\n  }\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(element, {x: position.x, y: position.y});\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  optimizedEvaluateItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.z)(center, chart.chartArea, chart._minPadding);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  optimizedEvaluateItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition) {\n  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.z)(position, chart.chartArea, chart._minPadding)) {\n    return [];\n  }\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition);\n}\nfunction getAxisItems(chart, e, options, useFinalPosition) {\n  const position = getRelativePosition(e, chart);\n  const items = [];\n  const axis = options.axis;\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n  evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      intersectsItem = true;\n    }\n  });\n  if (options.intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\nvar Interaction = {\n  modes: {\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'x';\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition)\n        : getNearestItems(chart, position, axis, false, useFinalPosition);\n      const elements = [];\n      if (!items.length) {\n        return [];\n      }\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n      return elements;\n    },\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition) :\n        getNearestItems(chart, position, axis, false, useFinalPosition);\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n      return items;\n    },\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      return getIntersectItems(chart, position, axis, useFinalPosition);\n    },\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);\n    },\n    x(chart, e, options, useFinalPosition) {\n      return getAxisItems(chart, e, {axis: 'x', intersect: options.intersect}, useFinalPosition);\n    },\n    y(chart, e, options, useFinalPosition) {\n      return getAxisItems(chart, e, {axis: 'y', intersect: options.intersect}, useFinalPosition);\n    }\n  }\n};\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(pos)) {\n    if (layout.size) {\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n    refit |= same && refitBoxes.length;\n    changed = changed || other;\n    if (!box.fullSize) {\n      refitBoxes.push(layout);\n    }\n  }\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n  chartArea.x = x;\n  chartArea.y = y;\n}\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set('layout', {\n  autoPadding: true,\n  padding: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }\n});\nvar layouts = {\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n    chart.boxes.push(item);\n  },\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n    const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n    handleMaxPadding(chartArea);\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n\nclass BasePlatform {\n  acquireContext(canvas, aspectRatio) {}\n  releaseContext(context) {\n    return false;\n  }\n  addEventListener(chart, type, listener) {}\n  removeEventListener(chart, type, listener) {}\n  getDevicePixelRatio() {\n    return 1;\n  }\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n  isAttached(canvas) {\n    return true;\n  }\n  updateConfig(config) {\n  }\n}\n\nclass BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n\nconst EXPANDO_KEY = '$chartjs';\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\nconst isNullOrEmpty = value => value === null || value === '';\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n  style.display = style.display || 'block';\n  style.boxSizing = style.boxSizing || 'border-box';\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.G)(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.G)(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n  return canvas;\n}\nconst eventListenerOptions = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J ? {passive: true} : false;\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.y)(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.F)(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.I)((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      listener();\n    }\n  }, window);\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n  return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.I)((event) => {\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart, (args) => {\n    const event = args[0];\n    return [event, event.offsetX, event.offsetY];\n  });\n  addListener(canvas, type, proxy);\n  return proxy;\n}\nclass DomPlatform extends BasePlatform {\n  acquireContext(canvas, aspectRatio) {\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n    if (context && context.canvas === canvas) {\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n    return null;\n  }\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n    canvas.width = canvas.width;\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n  addEventListener(chart, type, listener) {\n    this.removeEventListener(chart, type);\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n    if (!proxy) {\n      return;\n    }\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.E)(canvas, width, height, aspectRatio);\n  }\n  isAttached(canvas) {\n    const container = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.F)(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n\nfunction _detectPlatform(canvas) {\n  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.K)() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nclass Element {\n  constructor() {\n    this.x = undefined;\n    this.y = undefined;\n    this.active = false;\n    this.options = undefined;\n    this.$animations = undefined;\n  }\n  tooltipPosition(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  hasValue() {\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(this.x) && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(this.y);\n  }\n  getProps(props, final) {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      return this;\n    }\n    const ret = {};\n    props.forEach(prop => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n    });\n    return ret;\n  }\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\n\nconst formatters = {\n  values(value) {\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(value) ? value : '' + value;\n  },\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue;\n    if (ticks.length > 1) {\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n      delta = calculateDelta(tickValue, ticks);\n    }\n    const logDelta = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(Math.abs(delta));\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.o)(tickValue, locale, options);\n  },\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = tickValue / (Math.pow(10, Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(tickValue))));\n    if (remain === 1 || remain === 2 || remain === 5) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n};\nfunction calculateDelta(tickValue, ticks) {\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\nvar Ticks = {formatters};\n\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set('scale', {\n  display: true,\n  offset: false,\n  reverse: false,\n  beginAtZero: false,\n  bounds: 'ticks',\n  grace: 0,\n  grid: {\n    display: true,\n    lineWidth: 1,\n    drawBorder: true,\n    drawOnChartArea: true,\n    drawTicks: true,\n    tickLength: 8,\n    tickWidth: (_ctx, options) => options.lineWidth,\n    tickColor: (_ctx, options) => options.color,\n    offset: false,\n    borderDash: [],\n    borderDashOffset: 0.0,\n    borderWidth: 1\n  },\n  title: {\n    display: false,\n    text: '',\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  ticks: {\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: false,\n    textStrokeWidth: 0,\n    textStrokeColor: '',\n    padding: 3,\n    display: true,\n    autoSkip: true,\n    autoSkipPadding: 3,\n    labelOffset: 0,\n    callback: Ticks.formatters.values,\n    minor: {},\n    major: {},\n    align: 'center',\n    crossAlign: 'near',\n    showLabelBackdrop: false,\n    backdropColor: 'rgba(255, 255, 255, 0.75)',\n    backdropPadding: 2,\n  }\n});\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.route('scale.ticks', 'color', '', 'color');\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.route('scale.grid', 'color', '', 'borderColor');\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.route('scale.grid', 'borderColor', '', 'borderColor');\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.route('scale.title', 'color', '', 'color');\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe('scale', {\n  _fallback: false,\n  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',\n});\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe('scales', {\n  _fallback: 'scale',\n});\n_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe('scale.ticks', {\n  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n  _indexable: (name) => name !== 'backdropPadding',\n});\n\nfunction autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n  const factors = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorStart, 0);\n  const end = Math.min((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n  next = start;\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n  if (len < 2) {\n    return false;\n  }\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6;\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\nfunction garbageCollect(caches, length) {\n  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n  const font = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(options.font, fallback);\n  const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(options.padding);\n  const lines = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(options.text) ? options.text.length : 1;\n  return (lines * font.lineHeight) + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n  return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n    scale,\n    type: 'scale'\n  });\n}\nfunction createTickContext(parent, index, tick) {\n  return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\nfunction titleAlign(align, position, reverse) {\n  let ret = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.$)(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n  if (scale.isHorizontal()) {\n    titleX = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, left, right);\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, bottom, top);\n    rotation = position === 'left' ? -_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H : _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\nclass Scale extends Element {\n  constructor(cfg) {\n    super();\n    this.id = cfg.id;\n    this.type = cfg.type;\n    this.options = undefined;\n    this.ctx = cfg.ctx;\n    this.chart = cfg.chart;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.maxWidth = undefined;\n    this.maxHeight = undefined;\n    this.paddingTop = undefined;\n    this.paddingBottom = undefined;\n    this.paddingLeft = undefined;\n    this.paddingRight = undefined;\n    this.axis = undefined;\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    this.ticks = [];\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    this._startPixel = undefined;\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n  init(options) {\n    this.options = options.setContext(this.getContext());\n    this.axis = options.axis;\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n  parse(raw, index) {\n    return raw;\n  }\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(_userMin, _suggestedMin),\n      max: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(_userMax, _suggestedMax),\n      minDefined: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMin),\n      maxDefined: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMax)\n    };\n  }\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n    return {\n      min: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(min, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(max, min)),\n      max: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(max, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(min, max))\n    };\n  }\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n  getTicks() {\n    return this.ticks;\n  }\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n  beforeUpdate() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options.beforeUpdate, [this]);\n  }\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n    this.beforeUpdate();\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Q)(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n    this.beforeBuildTicks();\n    this.ticks = this.buildTicks() || [];\n    this.afterBuildTicks();\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n    this.configure();\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation();\n    this.afterCalculateLabelRotation();\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n    }\n    if (samplingEnabled) {\n      this._convertTicksToLabels(this.ticks);\n    }\n    this.beforeFit();\n    this.fit();\n    this.afterFit();\n    this.afterUpdate();\n  }\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n  afterUpdate() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options.afterUpdate, [this]);\n  }\n  beforeSetDimensions() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = 0;\n      this.bottom = this.height;\n    }\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options.afterSetDimensions, [this]);\n  }\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options[name], [this]);\n  }\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n  beforeTickToLabelConversion() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options.beforeTickToLabelConversion, [this]);\n  }\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options.afterTickToLabelConversion, [this]);\n  }\n  beforeCalculateLabelRotation() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = this.ticks.length;\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n    const maxWidth = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.R)(Math.min(\n        Math.asin((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options.afterCalculateLabelRotation, [this]);\n  }\n  beforeFit() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options.beforeFit, [this]);\n  }\n  fit() {\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight;\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n        if (isHorizontal) {\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n    this._handleMargins();\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n  afterFit() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options.afterFit, [this]);\n  }\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  isFullSize() {\n    return this.options.fullSize;\n  }\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n    this.generateTickLabels(ticks);\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n    this.afterTickToLabelConversion();\n  }\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n    }\n    return labelSizes;\n  }\n  _computeLabelSizes(ticks, length) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n    for (i = 0; i < length; ++i) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(label) && !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n        width = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.S)(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j];\n          if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(nestedLabel) && !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(nestedLabel)) {\n            width = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.S)(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n  getLabelForValue(value) {\n    return value;\n  }\n  getPixelForValue(value, index) {\n    return NaN;\n  }\n  getValueForPixel(pixel) {}\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n    const pixel = this._startPixel + decimal * this._length;\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.U)(this._alignToPixels ? (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(this.chart, pixel, 0) : pixel);\n  }\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n  getBaseValue() {\n    const {min, max} = this;\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n  getContext(index) {\n    const ticks = this.ticks || [];\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n    const rot = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n  _isVisible() {\n    const display = this.options.display;\n    if (display !== 'auto') {\n      return !!display;\n    }\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n    const limit = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const optsAtIndex = grid.setContext(this.getContext(i));\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = grid.borderDash || [];\n      const borderDashOffset = optsAtIndex.borderDashOffset;\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n      lineValue = getPixelForGridLine(this, i, offset);\n      if (lineValue === undefined) {\n        continue;\n      }\n      alignedLineValue = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(chart, lineValue, lineWidth);\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n    return items;\n  }\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      if (isHorizontal) {\n        x = pixel;\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n      let backdrop;\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n        let top = y + textOffset - labelPadding.top;\n        let left = x - labelPadding.left;\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        }\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        }\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n          color: optsAtIndex.backdropColor,\n        };\n      }\n      items.push({\n        rotation,\n        label,\n        font,\n        color,\n        strokeColor,\n        strokeWidth,\n        textOffset,\n        textAlign,\n        textBaseline,\n        translation: [x, y],\n        backdrop,\n      });\n    }\n    return items;\n  }\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n    let align = 'center';\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    }\n    return align;\n  }\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n    let textAlign;\n    let x;\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n    return {textAlign, x};\n  }\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n    const chart = this.chart;\n    const position = this.options.position;\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n  drawBorder() {\n    const {chart, ctx, options: {grid}} = this;\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n    if (this.isHorizontal()) {\n      x1 = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.borderWidth;\n    ctx.strokeStyle = borderOpts.borderColor;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n    if (!optionTicks.display) {\n      return;\n    }\n    const ctx = this.ctx;\n    const area = this._computeLabelArea();\n    if (area) {\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.W)(ctx, area);\n    }\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    let i, ilen;\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      const item = items[i];\n      const tickFont = item.font;\n      const label = item.label;\n      if (item.backdrop) {\n        ctx.fillStyle = item.backdrop.color;\n        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n      }\n      let y = item.textOffset;\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(ctx, label, 0, y, tickFont, item);\n    }\n    if (area) {\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx);\n    }\n  }\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n    if (!title.display) {\n      return;\n    }\n    const font = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(title.font);\n    const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n    if (position === 'bottom' || position === 'center' || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n      offset += padding.bottom;\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(opts.grid && opts.grid.z, -1);\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: gz + 1,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(opts.font);\n  }\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n\nclass TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n    if (isIChartComponent(proto)) {\n      parentScope = this.register(proto);\n    }\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n    if (id in items) {\n      return scope;\n    }\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.override(item.id, item.overrides);\n    }\n    return scope;\n  }\n  get(id) {\n    return this.items[id];\n  }\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n    if (id in items) {\n      delete items[id];\n    }\n    if (scope && id in _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d[scope]) {\n      delete _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d[scope][id];\n      if (this.override) {\n        delete _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a1[id];\n      }\n    }\n  }\n}\nfunction registerDefaults(item, scope, parentScope) {\n  const itemDefaults = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a2)(Object.create(null), [\n    parentScope ? _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.get(parentScope) : {},\n    _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.get(scope),\n    item.defaults\n  ]);\n  _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set(scope, itemDefaults);\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n  if (item.descriptors) {\n    _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe(scope, item.descriptors);\n  }\n}\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  add(...args) {\n    this._each('register', args);\n  }\n  remove(...args) {\n    this._each('unregister', args);\n  }\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(arg, item => {\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n  _exec(method, registry, component) {\n    const camelMethod = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a3)(method);\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(component['before' + camelMethod], [], component);\n    registry[method](component);\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(component['after' + camelMethod], [], component);\n  }\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    return this.plugins;\n  }\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n}\nvar registry = new Registry();\n\nclass PluginService {\n  constructor() {\n    this._init = [];\n  }\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invalidate() {\n    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n    const descriptors = this._cache = this._createDescriptors(chart);\n    this._notifyStateChanges(chart);\n    return descriptors;\n  }\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\nfunction allPlugins(config) {\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n    }\n  }\n  return plugins;\n}\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\nfunction createDescriptors(chart, plugins, options, all) {\n  const result = [];\n  const context = chart.getContext();\n  for (let i = 0; i < plugins.length; i++) {\n    const plugin = plugins[i];\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, plugin, opts, context)\n    });\n  }\n  return result;\n}\nfunction pluginOpts(config, plugin, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  return config.createResolver(scopes, context, [''], {scriptable: false, indexable: false, allKeys: true});\n}\n\nfunction getIndexAxis(type, options) {\n  const datasetDefaults = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\nfunction determineAxis(id, scaleOptions) {\n  if (id === 'x' || id === 'y') {\n    return id;\n  }\n  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a1[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const firstIDs = Object.create(null);\n  const scales = Object.create(null);\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    firstIDs[axis] = firstIDs[axis] || id;\n    scales[id] = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a9)(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a1[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a9)(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a9)(scale, [_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.scales[scale.type], _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.scale]);\n  });\n  return scales;\n}\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n  options.plugins = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n  initOptions(config);\n  return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\nconst addIfFound = (set, obj, key) => {\n  const opts = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\nclass Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n  get platform() {\n    return this._config.platform;\n  }\n  get type() {\n    return this._config.type;\n  }\n  set type(type) {\n    this._config.type = type;\n  }\n  get data() {\n    return this._config.data;\n  }\n  set data(data) {\n    this._config.data = initData(data);\n  }\n  get options() {\n    return this._config.options;\n  }\n  set options(options) {\n    this._config.options = options;\n  }\n  get plugins() {\n    return this._config.plugins;\n  }\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n    const scopes = new Set();\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a1[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d, key));\n      keys.forEach(key => addIfFound(scopes, _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a4, key));\n    });\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n  chartOptionScopes() {\n    const {options, type} = this;\n    return [\n      options,\n      _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a1[type] || {},\n      _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {},\n      {type},\n      _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d,\n      _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a4\n    ];\n  }\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a5)(context) ? context() : context;\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a6)(resolver, context, subResolver);\n    }\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(context)\n      ? (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a6)(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a7)(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\nconst hasFunction = value => (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(value)\n  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a5)(value[key]), false);\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a8)(proxy);\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a5)(value) || hasFunction(value)))\n      || (indexable && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvar version = \"3.7.1\";\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  chart.notifyPlugins('afterRender');\n  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(animationOptions && animationOptions.onComplete, [context], chart);\n}\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(animationOptions && animationOptions.onProgress, [context], chart);\n}\nfunction getCanvas(item) {\n  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.K)() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    item = item[0];\n  }\n  if (item && item.canvas) {\n    item = item.canvas;\n  }\n  return item;\n}\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\nclass Chart {\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas can be reused.'\n      );\n    }\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n    this.id = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aa)();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ab)(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n    instances[this.id] = this;\n    if (!context || !canvas) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (maintainAspectRatio && _aspectRatio) {\n      return _aspectRatio;\n    }\n    return height ? width / height : null;\n  }\n  get data() {\n    return this.config.data;\n  }\n  set data(data) {\n    this.config.data = data;\n  }\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this.config.options = options;\n  }\n  _initialize() {\n    this.notifyPlugins('beforeInit');\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ac)(this, this.options.devicePixelRatio);\n    }\n    this.bindEvents();\n    this.notifyPlugins('afterInit');\n    return this;\n  }\n  clear() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ad)(this.canvas, this.ctx);\n    return this;\n  }\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ac)(this, newRatio, true)) {\n      return;\n    }\n    this.notifyPlugins('resize', {size: newSize});\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(options.onResize, [this, newSize], this);\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        this.render();\n      }\n    }\n  }\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(scaleOptions.type, item.dtype);\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n      scale.init(scaleOptions, options);\n    });\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n    this._removeUnreferencedMetasets();\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type];\n        Object.assign(ControllerClass.prototype, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n    this._updateMetasets();\n    return newControllers;\n  }\n  _resetElements() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n  update(mode) {\n    const config = this.config;\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n    this._plugins.invalidate();\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    const newControllers = this.buildOrUpdateControllers();\n    this.notifyPlugins('beforeElementsUpdate');\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n    if (!animsDisabled) {\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n    this._updateDatasets(mode);\n    this.notifyPlugins('afterUpdate', {mode});\n    this._layers.sort(compare2Level('z', '_idx'));\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n    this.render();\n  }\n  _updateScales() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ae)(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ae)(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n    layouts.update(this, this.width, this.height, minPadding);\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n    this._layers = [];\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        return;\n      }\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n    this.notifyPlugins('afterLayout');\n  }\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a5)(mode) ? mode({datasetIndex: i}) : mode);\n    }\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n    meta.controller._update(mode);\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      this._resize(width, height);\n      this._resizeBeforeDraw = null;\n    }\n    this.clear();\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this._drawDatasets();\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this.notifyPlugins('afterDraw');\n  }\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = this.chartArea;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n    if (useClip) {\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.W)(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n    meta.controller.draw();\n    if (useClip) {\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx);\n    }\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n    return [];\n  }\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n    return meta;\n  }\n  getContext() {\n    return this.$context || (this.$context = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(null, {chart: this, type: 'chart'}));\n  }\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n    const meta = this.getDatasetMeta(datasetIndex);\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n    this._stop();\n    this.config.clearCache();\n    if (canvas) {\n      this.unbindEvents();\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ad)(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n    this.notifyPlugins('destroy');\n    delete instances[this.id];\n    this.notifyPlugins('afterDestroy');\n  }\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(this.options.events, (type) => _add(type, listener));\n  }\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n    let detached;\n    const attached = () => {\n      _remove('attach', attached);\n      this.attached = true;\n      this.resize();\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n    detached = () => {\n      this.attached = false;\n      _remove('resize', listener);\n      this._stop();\n      this._resize(0, 0);\n      _add('attach', attached);\n    };\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n  unbindEvents() {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.af)(active, lastActive);\n    if (changed) {\n      this._active = active;\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.z)(e, this.chartArea, this._minPadding)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n    if (changed || args.changed) {\n      this.render();\n    }\n    return this;\n  }\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ag)(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n    if (inChartArea) {\n      this._lastEvent = null;\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(options.onHover, [e, active, this], this);\n      if (isClick) {\n        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(options.onClick, [e, active, this], this);\n      }\n    }\n    const changed = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.af)(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n    this._lastEvent = lastEvent;\n    return changed;\n  }\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\nconst invalidatePlugins = () => (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(Chart.instances, (chart) => chart._plugins.invalidate());\nconst enumerable = true;\nObject.defineProperties(Chart, {\n  defaults: {\n    enumerable,\n    value: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d\n  },\n  instances: {\n    enumerable,\n    value: instances\n  },\n  overrides: {\n    enumerable,\n    value: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a1\n  },\n  registry: {\n    enumerable,\n    value: registry\n  },\n  version: {\n    enumerable,\n    value: version\n  },\n  getChart: {\n    enumerable,\n    value: getChart\n  },\n  register: {\n    enumerable,\n    value: (...items) => {\n      registry.add(...items);\n      invalidatePlugins();\n    }\n  },\n  unregister: {\n    enumerable,\n    value: (...items) => {\n      registry.remove(...items);\n      invalidatePlugins();\n    }\n  }\n});\n\nfunction clipArc(ctx, element, endAngle) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H, startAngle - _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\nfunction toRadiusCorners(value) {\n  return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ai)(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(o.innerStart, 0, innerLimit),\n    innerEnd: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(o.innerEnd, 0, innerLimit),\n  };\n}\nfunction rThetaToXY(r, theta, x, y) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\nfunction pathArc(ctx, element, offset, spacing, end) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n  let spacingOffset = 0;\n  const alpha = end - start;\n  if (spacing) {\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n  const beta = Math.max(0.001, alpha * outerRadius - offset / _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n  if (outerEnd > 0) {\n    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H);\n  }\n  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n  ctx.lineTo(p4.x, p4.y);\n  if (innerEnd > 0) {\n    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H, innerEndAdjustedAngle + Math.PI);\n  }\n  ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);\n  if (innerStart > 0) {\n    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H);\n  }\n  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n  ctx.lineTo(p8.x, p8.y);\n  if (outerStart > 0) {\n    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H, outerStartAdjustedAngle);\n  }\n  ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, startAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + circumference % _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T;\n      if (circumference % _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T === 0) {\n        endAngle += _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T;\n      }\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle);\n  ctx.fill();\n  return endAngle;\n}\nfunction drawFullCircleBorders(ctx, element, inner) {\n  const {x, y, startAngle, pixelMargin, fullCircles} = element;\n  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n  const innerRadius = element.innerRadius + pixelMargin;\n  let i;\n  if (inner) {\n    clipArc(ctx, element, startAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T);\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, innerRadius, startAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T, startAngle, true);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle, startAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n}\nfunction drawBorder(ctx, element, offset, spacing, endAngle) {\n  const {options} = element;\n  const {borderWidth, borderJoinStyle} = options;\n  const inner = options.borderAlign === 'inner';\n  if (!borderWidth) {\n    return;\n  }\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n  if (element.fullCircles) {\n    drawFullCircleBorders(ctx, element, inner);\n  }\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n  pathArc(ctx, element, offset, spacing, endAngle);\n  ctx.stroke();\n}\nclass ArcElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(chartX, chartY, useFinalPosition) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = this.options.spacing / 2;\n    const _circumference = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(circumference, endAngle - startAngle);\n    const betweenAngles = _circumference >= _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle);\n    const withinRadius = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ah)(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n    return (betweenAngles && withinRadius);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference',\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n  tooltipPosition(useFinalPosition) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n  draw(ctx) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 2;\n    const spacing = (options.spacing || 0) / 2;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T ? Math.floor(circumference / _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T) : 0;\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n    ctx.save();\n    let radiusOffset = 0;\n    if (offset) {\n      radiusOffset = offset / 2;\n      const halfAngle = (this.startAngle + this.endAngle) / 2;\n      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n      if (this.circumference >= _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P) {\n        radiusOffset = offset;\n      }\n    }\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    const endAngle = drawArc(ctx, this, radiusOffset, spacing);\n    drawBorder(ctx, this, radiusOffset, spacing, endAngle);\n    ctx.restore();\n  }\n}\nArcElement.id = 'arc';\nArcElement.defaults = {\n  borderAlign: 'center',\n  borderColor: '#fff',\n  borderJoinStyle: undefined,\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: undefined,\n};\nArcElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor'\n};\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ap;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aq;\n  }\n  return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n    if (point.skip) {\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    prev = point;\n  }\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n  return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n    if (point.skip) {\n      continue;\n    }\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      ctx.lineTo(x, y);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    lastY = y;\n  }\n  drawX();\n}\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.am;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.an;\n  }\n  return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ao;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\nclass LineElement extends Element {\n  constructor(cfg) {\n    super();\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aj)(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n  get points() {\n    return this._points;\n  }\n  get segments() {\n    return this._segments || (this._segments = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ak)(this, this.options.segment));\n  }\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.al)(this, {property, start: value, end: value});\n    if (!segments.length) {\n      return;\n    }\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n    start = start || 0;\n    count = count || (this.points.length - start);\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n    if (points.length && options.borderWidth) {\n      ctx.save();\n      draw(ctx, this, start, count);\n      ctx.restore();\n    }\n    if (this.animated) {\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\nLineElement.id = 'line';\nLineElement.defaults = {\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderWidth: 3,\n  capBezierPoints: true,\n  cubicInterpolationMode: 'default',\n  fill: false,\n  spanGaps: false,\n  stepped: false,\n  tension: 0,\n};\nLineElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\nLineElement.descriptors = {\n  _scriptable: true,\n  _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n};\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\nclass PointElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange$1(this, mouseX, 'x', useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange$1(this, mouseY, 'y', useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  size(options) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n  draw(ctx, area) {\n    const options = this.options;\n    if (this.skip || options.radius < 0.1 || !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.z)(this, area, this.size(options) / 2)) {\n      return;\n    }\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ar)(ctx, options, this.x, this.y);\n  }\n  getRange() {\n    const options = this.options || {};\n    return options.radius + options.hitRadius;\n  }\n}\nPointElement.id = 'point';\nPointElement.defaults = {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: 'circle',\n  radius: 3,\n  rotation: 0\n};\nPointElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\n  let left, right, top, bottom, half;\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n  return {left, top, right, bottom};\n}\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.at)(value);\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n  const enableBorder = enableBorderRadius || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(value);\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n  return bounds\n\t\t&& (skipX || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ah)(x, bounds.left, bounds.right))\n\t\t&& (skipY || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ah)(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\nclass BarElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.as : addNormalRectPath;\n    ctx.save();\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n    ctx.restore();\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\nBarElement.id = 'bar';\nBarElement.defaults = {\n  borderSkipped: 'start',\n  borderWidth: 0,\n  borderRadius: 0,\n  inflateAmount: 'auto',\n  pointStyle: undefined\n};\nBarElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nLineElement: LineElement,\nPointElement: PointElement,\nBarElement: BarElement\n});\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  const samples = options.samples || availableWidth;\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n  const decimated = [];\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n  decimated[sampledIndex++] = data[a];\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n    maxArea = area = -1;\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n  decimated[sampledIndex++] = data[endIndex];\n  return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      const lastIndex = i - 1;\n      if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(minIndex) && !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(maxIndex)) {\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n      if (i > 0 && lastIndex !== startIndex) {\n        decimated.push(data[lastIndex]);\n      }\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n  return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {value: data});\n  }\n}\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n  let start = 0;\n  let count;\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n  if (minDefined) {\n    start = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.x)(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.x)(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n  return {start, count};\n}\nvar plugin_decimation = {\n  id: 'decimation',\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      cleanDecimatedData(chart);\n      return;\n    }\n    const availableWidth = chart.width;\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a)([indexAxis, chart.options.indexAxis]) === 'y') {\n        return;\n      }\n      if (meta.type !== 'line') {\n        return;\n      }\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        return;\n      }\n      if (chart.options.parsing) {\n        return;\n      }\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(_data)) {\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n      dataset._decimated = decimated;\n    });\n  },\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(fillOption && fillOption.target, fillOption);\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n  if (fill === false || fill === null) {\n    return false;\n  }\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\nfunction decodeFill(line, index, count) {\n  const fill = parseFillOption(line);\n  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n  let target = parseFloat(fill);\n  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(target) && Math.floor(target) === target) {\n    if (fill[0] === '-' || fill[0] === '+') {\n      target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n      return false;\n    }\n    return target;\n  }\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  let target = null;\n  let horizontal;\n  if (fill === 'start') {\n    target = scale.bottom;\n  } else if (fill === 'end') {\n    target = scale.top;\n  } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n    target = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    target = scale.getBasePixel();\n  }\n  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(target)) {\n    horizontal = scale.isHorizontal();\n    return {\n      x: horizontal ? target : null,\n      y: horizontal ? null : target\n    };\n  }\n  return null;\n}\nclass simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const target = [];\n  const start = options.reverse ? scale.max : scale.min;\n  const end = options.reverse ? scale.min : scale.max;\n  let i, center, value;\n  if (fill === 'start') {\n    value = start;\n  } else if (fill === 'end') {\n    value = end;\n  } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  if (options.grid.circular) {\n    center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n  for (i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\nfunction findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\nfunction pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\nfunction buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ah)(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\nfunction getTarget(source) {\n  const {chart, fill, line} = source;\n  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n  if (fill === 'stack') {\n    return buildStackLine(source);\n  }\n  if (fill === 'shape') {\n    return true;\n  }\n  const boundary = computeBoundary(source);\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n  return createBoundaryLine(boundary, line);\n}\nfunction createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(boundary)) {\n    _loop = true;\n    points = boundary;\n  } else {\n    points = pointsFromSegments(boundary, line);\n  }\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\nfunction resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n  if (!propagate) {\n    return fill;\n  }\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n      return fill;\n    }\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n    if (target.visible) {\n      return fill;\n    }\n    visited.push(fill);\n    fill = target.fill;\n  }\n  return false;\n}\nfunction _clip(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\nfunction getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n  if (property === 'angle') {\n    start = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aw)(start);\n    end = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aw)(end);\n  }\n  return {property, start, end};\n}\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\nfunction _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = findSegmentEnd(start, end, points);\n    const bounds = getBounds(property, points[start], points[end], segment.loop);\n    if (!target.segments) {\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n    const targetSegments = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.al)(target, bounds);\n    for (const tgt of targetSegments) {\n      const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.av)(segment, points, subBounds);\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\nfunction _fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n    clipBounds(ctx, scale, notShape && getBounds(property, start, end));\n    ctx.beginPath();\n    const lineLoop = !!line.pathSegment(ctx, src);\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n    ctx.restore();\n  }\n}\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n  ctx.save();\n  if (property === 'x' && below !== above) {\n    _clip(ctx, target, area.top);\n    _fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    _clip(ctx, target, area.bottom);\n  }\n  _fill(ctx, {line, target, color: below, scale, property});\n  ctx.restore();\n}\nfunction drawfill(ctx, source, area) {\n  const target = getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.W)(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx);\n  }\n}\nvar plugin_filler = {\n  id: 'filler',\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n      meta.$filler = source;\n      sources.push(source);\n    }\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n      source.fill = resolveTarget(sources, i, options.propagate);\n    }\n  },\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n      source.line.updateControlPoints(area, source.axis);\n      if (draw) {\n        drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (source) {\n        drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n    if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n    drawfill(chart.ctx, source, chart.chartArea);\n  },\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = Math.min(boxWidth, fontSize);\n  }\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n  constructor(config) {\n    super();\n    this._added = false;\n    this.legendHitBoxes = [];\n    this._hoveredItem = null;\n    this.doughnutMode = false;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(labelOpts.generateLabels, [this.chart], this) || [];\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n    this.legendItems = legendItems;\n  }\n  fit() {\n    const {options, ctx} = this;\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n    const labelOpts = options.labels;\n    const labelFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n    let width, height;\n    ctx.font = labelFont.string;\n    if (this.isHorizontal()) {\n      width = this.maxWidth;\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight;\n      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    }\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n    return totalHeight;\n  }\n  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n    let left = 0;\n    let col = 0;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight});\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight});\n    return totalWidth;\n  }\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ax)(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.W)(ctx, this);\n      this._draw();\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Y)(ctx);\n    }\n  }\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.color;\n    const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ax)(opts.rtl, this.left, this.width);\n    const labelFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(labelOpts.font);\n    const {color: fontColor, padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n    this.drawTitle();\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n      ctx.save();\n      const lineWidth = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineWidth, 1);\n      ctx.fillStyle = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.strokeStyle, defaultColor);\n      ctx.setLineDash((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDash, []));\n      if (labelOpts.usePointStyle) {\n        const drawOptions = {\n          radius: boxWidth * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ar)(ctx, drawOptions, centerX, centerY);\n      } else {\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(legendItem.borderRadius);\n        ctx.beginPath();\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.as)(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n      ctx.restore();\n    };\n    const fillText = function(x, y, legendItem) {\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ay)(this.ctx, opts.textDirection);\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor || fontColor;\n      ctx.fillStyle = legendItem.fontColor || fontColor;\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n      rtlHelper.setWidth(this.width);\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n      const realX = rtlHelper.x(x);\n      drawLegendBox(realX, y, legendItem);\n      x = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.az)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n      fillText(rtlHelper.x(x), y, legendItem);\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aA)(this.ctx, opts.textDirection);\n  }\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(titleOpts.font);\n    const titlePadding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(titleOpts.padding);\n    if (!titleOpts.display) {\n      return;\n    }\n    const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ax)(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n    let left = this.left;\n    let maxWidth = this.width;\n    if (this.isHorizontal()) {\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.align, left, this.right - maxWidth);\n    } else {\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n    const x = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(position, left, left + maxWidth);\n    ctx.textAlign = rtlHelper.textAlign((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.$)(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(ctx, titleOpts.text, x, y, titleFont);\n  }\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(titleOpts.font);\n    const titlePadding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ah)(x, this.left, this.right)\n      && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ah)(y, this.top, this.bottom)) {\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n        if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ah)(x, hitBox.left, hitBox.left + hitBox.width)\n          && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ah)(y, hitBox.top, hitBox.top + hitBox.height)) {\n          return this.legendItems[i];\n        }\n      }\n    }\n    return null;\n  }\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n    if (e.type === 'mousemove') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(opts.onLeave, [e, previous, this], this);\n      }\n      this._hoveredItem = hoveredItem;\n      if (hoveredItem && !sameItem) {\n        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\nfunction isListened(type, opts) {\n  if (type === 'mousemove' && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\nvar plugin_legend = {\n  id: 'legend',\n  _element: Legend,\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(style.borderWidth);\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: 0,\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n\nclass Title extends Element {\n  constructor(config) {\n    super();\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n    this.left = 0;\n    this.top = 0;\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n    const lineCount = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(opts.text) ? opts.text.length : 1;\n    this._padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(opts.padding);\n    const textSize = lineCount * (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(opts.font).lineHeight + this._padding.height;\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    if (this.isHorizontal()) {\n      titleX = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, bottom, top);\n        rotation = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(align, top, bottom);\n        rotation = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    if (!opts.display) {\n      return;\n    }\n    const fontOpts = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.$)(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\nvar plugin_title = {\n  id: 'title',\n  _element: Title,\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n  id: 'subtitle',\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst positioners = {\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aC)(eventPosition, center);\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n    return {\n      x,\n      y\n    };\n  }\n};\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(toPush)) {\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n  return base;\n}\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(options.bodyFont);\n  const titleFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(options.titleFont);\n  const footerFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n  const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(options.padding);\n  let height = padding.height;\n  let width = 0;\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n  ctx.save();\n  ctx.font = titleFont.string;\n  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(tooltip.title, maxLineWidth);\n  ctx.font = bodyFont.string;\n  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(body, (bodyItem) => {\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(bodyItem.before, maxLineWidth);\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(bodyItem.lines, maxLineWidth);\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(bodyItem.after, maxLineWidth);\n  });\n  widthPadding = 0;\n  ctx.font = footerFont.string;\n  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(tooltip.footer, maxLineWidth);\n  ctx.restore();\n  width += padding.width;\n  return {width, height};\n}\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n  return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(cornerRadius);\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n  return {\n    x: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(x, 0, chart.width - size.width),\n    y: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(y, 0, chart.height - size.height)\n  };\n}\nfunction getAlignedX(tooltip, align, options) {\n  const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(options.padding);\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\nclass Tooltip extends Element {\n  constructor(config) {\n    super();\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart || config._chart;\n    this._chart = this.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n    if (cached) {\n      return cached;\n    }\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n  getTitle(context, options) {\n    const {callbacks} = options;\n    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);\n    const title = callbacks.title.apply(this, [context]);\n    const afterTitle = callbacks.afterTitle.apply(this, [context]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n    return lines;\n  }\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\n  }\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\n      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\n      bodyItems.push(bodyItem);\n    });\n    return bodyItems;\n  }\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\n  }\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);\n    const footer = callbacks.footer.apply(this, [tooltipItems]);\n    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n    return lines;\n  }\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(scoped.labelColor.call(this, context));\n      labelPointStyles.push(scoped.labelPointStyle.call(this, context));\n      labelTextColors.push(scoped.labelTextColor.call(this, context));\n    });\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n    if (length) {\n      const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ax)(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.titleAlign, options);\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n      titleFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(options.titleFont);\n      titleSpacing = options.titleSpacing;\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing;\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing;\n        }\n      }\n    }\n  }\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColors = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2,\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ar)(ctx, drawOptions, centerX, centerY);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.fillStyle = labelColors.backgroundColor;\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ar)(ctx, drawOptions, centerX, centerY);\n    } else {\n      ctx.lineWidth = labelColors.borderWidth || 1;\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.setLineDash(labelColors.borderDash || []);\n      ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n      const borderRadius = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(labelColors.borderRadius);\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.as)(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.beginPath();\n        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.as)(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n    const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ax)(options.rtl, this.x, this.width);\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n    ctx.fillStyle = options.bodyColor;\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(this.beforeBody, fillLineOfText);\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(bodyItem.before, fillLineOfText);\n      lines = bodyItem.lines;\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(bodyItem.after, fillLineOfText);\n    }\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing;\n  }\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n    if (length) {\n      const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ax)(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n      footerFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(options.footerFont);\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(options.cornerRadius);\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n    ctx.fill();\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n    if (!opacity) {\n      return;\n    }\n    this._updateAnimationTarget(options);\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n    const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(options.padding);\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      this.drawBackground(pt, ctx, tooltipSize, options);\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ay)(ctx, options.textDirection);\n      pt.y += padding.top;\n      this.drawTitle(pt, ctx, options);\n      this.drawBody(pt, ctx, options);\n      this.drawFooter(pt, ctx, options);\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aA)(ctx, options.textDirection);\n      ctx.restore();\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.af)(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n    const positionChanged = this._positionChanged(active, e);\n    const changed = replay || !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.af)(active, lastActive) || positionChanged;\n    if (changed) {\n      this._active = active;\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n        this.update(true, replay);\n      }\n    }\n    return changed;\n  }\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n    if (options.reverse) {\n      active.reverse();\n    }\n    return active;\n  }\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n    const args = {\n      tooltip\n    };\n    if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\n      return;\n    }\n    if (tooltip) {\n      tooltip.draw(chart.ctx);\n    }\n    chart.notifyPlugins('afterTooltipDraw', args);\n  },\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        args.changed = true;\n      }\n    }\n  },\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: {\n      beforeTitle: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aB,\n      title(tooltipItems) {\n        if (tooltipItems.length > 0) {\n          const item = tooltipItems[0];\n          const labels = item.chart.data.labels;\n          const labelCount = labels ? labels.length : 0;\n          if (this && this.options && this.options.mode === 'dataset') {\n            return item.dataset.label || '';\n          } else if (item.label) {\n            return item.label;\n          } else if (labelCount > 0 && item.dataIndex < labelCount) {\n            return labels[item.dataIndex];\n          }\n        }\n        return '';\n      },\n      afterTitle: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aB,\n      beforeBody: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aB,\n      beforeLabel: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aB,\n      label(tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n          label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n          label += value;\n        }\n        return label;\n      },\n      labelColor(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          borderColor: options.borderColor,\n          backgroundColor: options.backgroundColor,\n          borderWidth: options.borderWidth,\n          borderDash: options.borderDash,\n          borderDashOffset: options.borderDashOffset,\n          borderRadius: 0,\n        };\n      },\n      labelTextColor() {\n        return this.options.bodyColor;\n      },\n      labelPointStyle(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          pointStyle: options.pointStyle,\n          rotation: options.rotation,\n        };\n      },\n      afterLabel: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aB,\n      afterBody: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aB,\n      beforeFooter: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aB,\n      footer: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aB,\n      afterFooter: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aB\n    }\n  },\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n  additionalOptionScopes: ['interaction']\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nDecimation: plugin_decimation,\nFiller: plugin_filler,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\nconst validIndex = (index, max) => index === null ? null : (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(Math.round(index), 0, max);\nclass CategoryScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n  parse(raw, index) {\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n      return labels[value];\n    }\n    return value;\n  }\n  configure() {\n    super.configure();\n    if (!this.isHorizontal()) {\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n  getBasePixel() {\n    return this.bottom;\n  }\n}\nCategoryScale.id = 'category';\nCategoryScale.defaults = {\n  ticks: {\n    callback: CategoryScale.prototype.getLabelForValue\n  }\n};\n\nfunction generateTicks$1(generationOptions, dataRange) {\n  const ticks = [];\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(min);\n  const maxDefined = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(max);\n  const countDefined = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aE)((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    spacing = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aE)(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(precision)) {\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n  if (minDefined && maxDefined && step && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aF)((max - min) / step, spacing / 1000)) {\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    numSpaces = (niceMax - niceMin) / spacing;\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aG)(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n  const decimalPlaces = Math.max(\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aH)(spacing),\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aH)(niceMin)\n  );\n  factor = Math.pow(10, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n      if (niceMin < min) {\n        j++;\n      }\n      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aG)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n  for (; j < numSpaces; ++j) {\n    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\n  }\n  if (maxDefined && includeBounds && niceMax !== max) {\n    if (ticks.length && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aG)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n  return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n    return +raw;\n  }\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    if (beginAtZero) {\n      const minSign = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(min);\n      const maxSign = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(max);\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n    if (min === max) {\n      let offset = 1;\n      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n        offset = Math.abs(max * 0.05);\n      }\n      setMax(max + offset);\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n    return maxTicks;\n  }\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n    if (opts.bounds === 'ticks') {\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aD)(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n    super.configure();\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n  getLabelForValue(value) {\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n\nclass LinearScale extends LinearScaleBase {\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? min : 0;\n    this.max = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? max : 1;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\nLinearScale.id = 'linear';\nLinearScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.numeric\n  }\n};\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(tickVal))));\n  return remain === 1;\n}\nfunction generateTicks(generationOptions, dataRange) {\n  const endExp = Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(dataRange.max));\n  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n  const ticks = [];\n  let tickVal = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(generationOptions.min, Math.pow(10, Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(dataRange.min))));\n  let exp = Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(tickVal));\n  let significand = Math.floor(tickVal / Math.pow(10, exp));\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  do {\n    ticks.push({value: tickVal, major: isMajor(tickVal)});\n    ++significand;\n    if (significand === 10) {\n      significand = 1;\n      ++exp;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n  } while (exp < endExp || (exp === endExp && significand < endSignificand));\n  const lastTick = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(generationOptions.max, tickVal);\n  ticks.push({value: lastTick, major: isMajor(tickVal)});\n  return ticks;\n}\nclass LogarithmicScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(value) && value > 0 ? value : null;\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? Math.max(0, min) : null;\n    this.max = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? Math.max(0, max) : null;\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n    this.handleTickRangeOptions();\n  }\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    const exp = (v, m) => Math.pow(10, Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(v)) + m);\n    if (min === max) {\n      if (min <= 0) {\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(exp(min, -1));\n        setMax(exp(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(exp(max, -1));\n    }\n    if (max <= 0) {\n      setMax(exp(min, +1));\n    }\n    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\n      setMin(exp(min, -1));\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n    if (opts.bounds === 'ticks') {\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aD)(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n  }\n  configure() {\n    const start = this.min;\n    super.configure();\n    this._startValue = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(start);\n    this._valueRange = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(this.max) - (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(start);\n  }\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(value) - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\nLogarithmicScale.id = 'logarithmic';\nLogarithmicScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.logarithmic,\n    major: {\n      enabled: true\n    }\n  }\n};\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n  if (tickOpts.display && opts.display) {\n    const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(tickOpts.backdropPadding);\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(tickOpts.font && tickOpts.font.size, _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.font.size) + padding.height;\n  }\n  return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n  label = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label : [label];\n  return {\n    w: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aI)(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\nfunction fitWithPointLabels(scale) {\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n    const angleRadians = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aw)(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.R)(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const extra = getTickBackdropHeight(opts) / 2;\n  const outerDistance = scale.drawingArea;\n  const additionalAngle = opts.pointLabels.centerPointLabels ? _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\n    const angle = Math.round((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.R)((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aw)(pointLabelPosition.angle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H)));\n    const size = labelSizes[i];\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    items.push({\n      x: pointLabelPosition.x,\n      y,\n      textAlign,\n      left,\n      top: y,\n      right: left + size.w,\n      bottom: y + size.h\n    });\n  }\n  return items;\n}\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n  return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    const plFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(optsAtIndex.font);\n    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\n    const {backdropColor} = optsAtIndex;\n    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(backdropColor)) {\n      const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(optsAtIndex.backdropPadding);\n      ctx.fillStyle = backdropColor;\n      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);\n    }\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T);\n  } else {\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n  const {color, lineWidth} = gridLineOpts;\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(gridLineOpts.borderDash);\n  ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n  return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\nclass RadialLinearScale extends LinearScaleBase {\n  constructor(cfg) {\n    super(cfg);\n    this.xCenter = undefined;\n    this.yCenter = undefined;\n    this.drawingArea = undefined;\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n  setDimensions() {\n    const padding = this._padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n    this.min = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : 0;\n    this.max = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : 0;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n  fit() {\n    const opts = this.options;\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n  getIndexAngle(index) {\n    const angleMultiplier = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aw)(index * angleMultiplier + (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(startAngle));\n  }\n  getDistanceFromCenterForValue(value) {\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n      return NaN;\n    }\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n  getValueForDistanceFromCenter(distance) {\n    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(distance)) {\n      return NaN;\n    }\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid} = opts;\n    const labelCount = this._pointLabels.length;\n    let i, offset, position;\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const optsAtIndex = grid.setContext(this.getContext(index - 1));\n          drawRadiusLine(this, optsAtIndex, offset, labelCount);\n        }\n      });\n    }\n    if (angleLines.display) {\n      ctx.save();\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n        if (!lineWidth || !color) {\n          continue;\n        }\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n      ctx.restore();\n    }\n  }\n  drawBorder() {}\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    if (!tickOpts.display) {\n      return;\n    }\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    this.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n        const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n      });\n    });\n    ctx.restore();\n  }\n  drawTitle() {}\n}\nRadialLinearScale.id = 'radialLinear';\nRadialLinearScale.defaults = {\n  display: true,\n  animate: true,\n  position: 'chartArea',\n  angleLines: {\n    display: true,\n    lineWidth: 1,\n    borderDash: [],\n    borderDashOffset: 0.0\n  },\n  grid: {\n    circular: false\n  },\n  startAngle: 0,\n  ticks: {\n    showLabelBackdrop: true,\n    callback: Ticks.formatters.numeric\n  },\n  pointLabels: {\n    backdropColor: undefined,\n    backdropPadding: 2,\n    display: true,\n    font: {\n      size: 10\n    },\n    callback(label) {\n      return label;\n    },\n    padding: 5,\n    centerPointLabels: false\n  }\n};\nRadialLinearScale.defaultRoutes = {\n  'angleLines.color': 'borderColor',\n  'pointLabels.color': 'color',\n  'ticks.color': 'color'\n};\nRadialLinearScale.descriptors = {\n  angleLines: {\n    _fallback: 'grid'\n  }\n};\n\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\nconst UNITS = (Object.keys(INTERVALS));\nfunction sorter(a, b) {\n  return a - b;\n}\nfunction parse(scale, input) {\n  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(input)) {\n    return null;\n  }\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n  if (value === null) {\n    return null;\n  }\n  if (round) {\n    value = round === 'week' && ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n  return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aK)(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n  constructor(props) {\n    super(props);\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n    this._unit = 'day';\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n  init(scaleOpts, opts) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a9)(time.displayFormats, adapter.formats());\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n    super.init(scaleOpts);\n    this._normalized = opts.normalized;\n  }\n  parse(raw, index) {\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n    if (!minDefined || !maxDefined) {\n      _applyBounds(this._getLabelBounds());\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n    min = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n    const min = this.min;\n    const max = this.max;\n    const ticks = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aJ)(timestamps, min, max);\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n    if (options.reverse) {\n      ticks.reverse();\n    }\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n  initOffsets(timestamps) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(start, 0, limit);\n    end = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(end, 0, limit);\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(timeOpts.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    const formatter = options.ticks.callback;\n    return formatter ? (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(formatter, [label, index, ticks], this) : label;\n  }\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const metas = this.getMatchingVisibleMetas();\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n    return (this._cache.data = this.normalize(timestamps));\n  }\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n  normalize(values) {\n    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort(sorter));\n  }\n}\nTimeScale.id = 'time';\nTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  ticks: {\n    source: 'auto',\n    major: {\n      enabled: false\n    }\n  }\n};\n\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.x)(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.x)(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this._table = [];\n    this._minPos = undefined;\n    this._tableRange = undefined;\n  }\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n    if (items.length < 2) {\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n    return timestamps;\n  }\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\nTimeSeriesScale.id = 'timeseries';\nTimeSeriesScale.defaults = TimeScale.defaults;\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n  controllers,\n  elements,\n  plugins,\n  scales,\n];\n\n\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/chart.js/dist/chart.esm.js?");

/***/ }),

/***/ "./node_modules/chart.js/dist/chunks/helpers.segment.js":
/*!**************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.segment.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$\": () => (/* binding */ _toLeftRightCenter),\n/* harmony export */   \"A\": () => (/* binding */ _rlookupByKey),\n/* harmony export */   \"B\": () => (/* binding */ getAngleFromPoint),\n/* harmony export */   \"C\": () => (/* binding */ toPadding),\n/* harmony export */   \"D\": () => (/* binding */ each),\n/* harmony export */   \"E\": () => (/* binding */ getMaximumSize),\n/* harmony export */   \"F\": () => (/* binding */ _getParentNode),\n/* harmony export */   \"G\": () => (/* binding */ readUsedSize),\n/* harmony export */   \"H\": () => (/* binding */ HALF_PI),\n/* harmony export */   \"I\": () => (/* binding */ throttled),\n/* harmony export */   \"J\": () => (/* binding */ supportsEventListenerOptions),\n/* harmony export */   \"K\": () => (/* binding */ _isDomSupported),\n/* harmony export */   \"L\": () => (/* binding */ log10),\n/* harmony export */   \"M\": () => (/* binding */ _factorize),\n/* harmony export */   \"N\": () => (/* binding */ finiteOrDefault),\n/* harmony export */   \"O\": () => (/* binding */ callback),\n/* harmony export */   \"P\": () => (/* binding */ PI),\n/* harmony export */   \"Q\": () => (/* binding */ _addGrace),\n/* harmony export */   \"R\": () => (/* binding */ toDegrees),\n/* harmony export */   \"S\": () => (/* binding */ _measureText),\n/* harmony export */   \"T\": () => (/* binding */ TAU),\n/* harmony export */   \"U\": () => (/* binding */ _int16Range),\n/* harmony export */   \"V\": () => (/* binding */ _alignPixel),\n/* harmony export */   \"W\": () => (/* binding */ clipArea),\n/* harmony export */   \"X\": () => (/* binding */ renderText),\n/* harmony export */   \"Y\": () => (/* binding */ unclipArea),\n/* harmony export */   \"Z\": () => (/* binding */ toFont),\n/* harmony export */   \"_\": () => (/* binding */ _arrayUnique),\n/* harmony export */   \"a\": () => (/* binding */ resolve),\n/* harmony export */   \"a$\": () => (/* binding */ _angleDiff),\n/* harmony export */   \"a0\": () => (/* binding */ _alignStartEnd),\n/* harmony export */   \"a1\": () => (/* binding */ overrides),\n/* harmony export */   \"a2\": () => (/* binding */ merge),\n/* harmony export */   \"a3\": () => (/* binding */ _capitalize),\n/* harmony export */   \"a4\": () => (/* binding */ descriptors),\n/* harmony export */   \"a5\": () => (/* binding */ isFunction),\n/* harmony export */   \"a6\": () => (/* binding */ _attachContext),\n/* harmony export */   \"a7\": () => (/* binding */ _createResolver),\n/* harmony export */   \"a8\": () => (/* binding */ _descriptors),\n/* harmony export */   \"a9\": () => (/* binding */ mergeIf),\n/* harmony export */   \"aA\": () => (/* binding */ restoreTextDirection),\n/* harmony export */   \"aB\": () => (/* binding */ noop),\n/* harmony export */   \"aC\": () => (/* binding */ distanceBetweenPoints),\n/* harmony export */   \"aD\": () => (/* binding */ _setMinAndMaxByKey),\n/* harmony export */   \"aE\": () => (/* binding */ niceNum),\n/* harmony export */   \"aF\": () => (/* binding */ almostWhole),\n/* harmony export */   \"aG\": () => (/* binding */ almostEquals),\n/* harmony export */   \"aH\": () => (/* binding */ _decimalPlaces),\n/* harmony export */   \"aI\": () => (/* binding */ _longestText),\n/* harmony export */   \"aJ\": () => (/* binding */ _filterBetween),\n/* harmony export */   \"aK\": () => (/* binding */ _lookup),\n/* harmony export */   \"aL\": () => (/* binding */ getHoverColor),\n/* harmony export */   \"aM\": () => (/* binding */ clone$1),\n/* harmony export */   \"aN\": () => (/* binding */ _merger),\n/* harmony export */   \"aO\": () => (/* binding */ _mergerIf),\n/* harmony export */   \"aP\": () => (/* binding */ _deprecated),\n/* harmony export */   \"aQ\": () => (/* binding */ toFontString),\n/* harmony export */   \"aR\": () => (/* binding */ splineCurve),\n/* harmony export */   \"aS\": () => (/* binding */ splineCurveMonotone),\n/* harmony export */   \"aT\": () => (/* binding */ getStyle),\n/* harmony export */   \"aU\": () => (/* binding */ fontString),\n/* harmony export */   \"aV\": () => (/* binding */ toLineHeight),\n/* harmony export */   \"aW\": () => (/* binding */ PITAU),\n/* harmony export */   \"aX\": () => (/* binding */ INFINITY),\n/* harmony export */   \"aY\": () => (/* binding */ RAD_PER_DEG),\n/* harmony export */   \"aZ\": () => (/* binding */ QUARTER_PI),\n/* harmony export */   \"a_\": () => (/* binding */ TWO_THIRDS_PI),\n/* harmony export */   \"aa\": () => (/* binding */ uid),\n/* harmony export */   \"ab\": () => (/* binding */ debounce),\n/* harmony export */   \"ac\": () => (/* binding */ retinaScale),\n/* harmony export */   \"ad\": () => (/* binding */ clearCanvas),\n/* harmony export */   \"ae\": () => (/* binding */ setsEqual),\n/* harmony export */   \"af\": () => (/* binding */ _elementsEqual),\n/* harmony export */   \"ag\": () => (/* binding */ _isClickEvent),\n/* harmony export */   \"ah\": () => (/* binding */ _isBetween),\n/* harmony export */   \"ai\": () => (/* binding */ _readValueToProps),\n/* harmony export */   \"aj\": () => (/* binding */ _updateBezierControlPoints),\n/* harmony export */   \"ak\": () => (/* binding */ _computeSegments),\n/* harmony export */   \"al\": () => (/* binding */ _boundSegments),\n/* harmony export */   \"am\": () => (/* binding */ _steppedInterpolation),\n/* harmony export */   \"an\": () => (/* binding */ _bezierInterpolation),\n/* harmony export */   \"ao\": () => (/* binding */ _pointInLine),\n/* harmony export */   \"ap\": () => (/* binding */ _steppedLineTo),\n/* harmony export */   \"aq\": () => (/* binding */ _bezierCurveTo),\n/* harmony export */   \"ar\": () => (/* binding */ drawPoint),\n/* harmony export */   \"as\": () => (/* binding */ addRoundedRectPath),\n/* harmony export */   \"at\": () => (/* binding */ toTRBL),\n/* harmony export */   \"au\": () => (/* binding */ toTRBLCorners),\n/* harmony export */   \"av\": () => (/* binding */ _boundSegment),\n/* harmony export */   \"aw\": () => (/* binding */ _normalizeAngle),\n/* harmony export */   \"ax\": () => (/* binding */ getRtlAdapter),\n/* harmony export */   \"ay\": () => (/* binding */ overrideTextDirection),\n/* harmony export */   \"az\": () => (/* binding */ _textX),\n/* harmony export */   \"b\": () => (/* binding */ isArray),\n/* harmony export */   \"c\": () => (/* binding */ color),\n/* harmony export */   \"d\": () => (/* binding */ defaults),\n/* harmony export */   \"e\": () => (/* binding */ effects),\n/* harmony export */   \"f\": () => (/* binding */ resolveObjectKey),\n/* harmony export */   \"g\": () => (/* binding */ isNumberFinite),\n/* harmony export */   \"h\": () => (/* binding */ createContext),\n/* harmony export */   \"i\": () => (/* binding */ isObject),\n/* harmony export */   \"j\": () => (/* binding */ defined),\n/* harmony export */   \"k\": () => (/* binding */ isNullOrUndef),\n/* harmony export */   \"l\": () => (/* binding */ listenArrayEvents),\n/* harmony export */   \"m\": () => (/* binding */ toPercentage),\n/* harmony export */   \"n\": () => (/* binding */ toDimension),\n/* harmony export */   \"o\": () => (/* binding */ formatNumber),\n/* harmony export */   \"p\": () => (/* binding */ _angleBetween),\n/* harmony export */   \"q\": () => (/* binding */ isNumber),\n/* harmony export */   \"r\": () => (/* binding */ requestAnimFrame),\n/* harmony export */   \"s\": () => (/* binding */ sign),\n/* harmony export */   \"t\": () => (/* binding */ toRadians),\n/* harmony export */   \"u\": () => (/* binding */ unlistenArrayEvents),\n/* harmony export */   \"v\": () => (/* binding */ valueOrDefault),\n/* harmony export */   \"w\": () => (/* binding */ _limitValue),\n/* harmony export */   \"x\": () => (/* binding */ _lookupByKey),\n/* harmony export */   \"y\": () => (/* binding */ getRelativePosition),\n/* harmony export */   \"z\": () => (/* binding */ _isPointInArea)\n/* harmony export */ });\n/*!\n * Chart.js v3.7.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\nconst requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\nfunction throttled(fn, thisArg, updateFn) {\n  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));\n  let ticking = false;\n  let args = [];\n  return function(...rest) {\n    args = updateArgs(rest);\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, args);\n      });\n    }\n  };\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function(...args) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\nconst _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\nconst _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\nconst _textX = (align, left, right, rtl) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\nfunction noop() {}\nconst uid = (function() {\n  let id = 0;\n  return function() {\n    return id++;\n  };\n}());\nfunction isNullOrUndef(value) {\n  return value === null || typeof value === 'undefined';\n}\nfunction isArray(value) {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\nfunction isObject(value) {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\nconst isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\nfunction finiteOrDefault(value, defaultValue) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\nfunction valueOrDefault(value, defaultValue) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : value / dimension;\nconst toDimension = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\nfunction callback(fn, args, thisArg) {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n  let i, len, keys;\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\nfunction _elementsEqual(a0, a1) {\n  let i, ilen, v0, v1;\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction clone$1(source) {\n  if (isArray(source)) {\n    return source.map(clone$1);\n  }\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone$1(source[keys[k]]);\n    }\n    return target;\n  }\n  return source;\n}\nfunction isValidKey(key) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\nfunction _merger(key, target, source, options) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone$1(sval);\n  }\n}\nfunction merge(target, source, options) {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n  if (!isObject(target)) {\n    return target;\n  }\n  options = options || {};\n  const merger = options.merger || _merger;\n  for (let i = 0; i < ilen; ++i) {\n    source = sources[i];\n    if (!isObject(source)) {\n      continue;\n    }\n    const keys = Object.keys(source);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, source, options);\n    }\n  }\n  return target;\n}\nfunction mergeIf(target, source) {\n  return merge(target, source, {merger: _mergerIf});\n}\nfunction _mergerIf(key, target, source) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone$1(sval);\n  }\n}\nfunction _deprecated(scope, value, previous, current) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\nconst emptyString = '';\nconst dot = '.';\nfunction indexOfDotOrLength(key, start) {\n  const idx = key.indexOf(dot, start);\n  return idx === -1 ? key.length : idx;\n}\nfunction resolveObjectKey(obj, key) {\n  if (key === emptyString) {\n    return obj;\n  }\n  let pos = 0;\n  let idx = indexOfDotOrLength(key, pos);\n  while (obj && idx > pos) {\n    obj = obj[key.substr(pos, idx - pos)];\n    pos = idx + 1;\n    idx = indexOfDotOrLength(key, pos);\n  }\n  return obj;\n}\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value) => typeof value !== 'undefined';\nconst isFunction = (value) => typeof value === 'function';\nconst setsEqual = (a, b) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n  return true;\n};\nfunction _isClickEvent(e) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction niceNum(range) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\nfunction _factorize(value) {\n  const result = [];\n  const sqrt = Math.sqrt(value);\n  let i;\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) {\n    result.push(sqrt);\n  }\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostEquals(x, y, epsilon) {\n  return Math.abs(x - y) < epsilon;\n}\nfunction almostWhole(x, epsilon) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\nfunction _setMinAndMaxByKey(array, target, property) {\n  let i, ilen, value;\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\nfunction toRadians(degrees) {\n  return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n  return radians * (180 / PI);\n}\nfunction _decimalPlaces(x) {\n  if (!isNumberFinite(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n  if (angle < (-0.5 * PI)) {\n    angle += TAU;\n  }\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\nfunction _angleDiff(a, b) {\n  return (a - b + PITAU) % TAU - PI;\n}\nfunction _normalizeAngle(a) {\n  return (a % TAU + TAU) % TAU;\n}\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\nfunction _limitValue(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction _int16Range(value) {\n  return _limitValue(value, -32768, 32767);\n}\nfunction _isBetween(value, start, end, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nconst atEdge = (t) => t === 0 || t === 1;\nconst elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\nconst effects = {\n  linear: t => t,\n  easeInQuad: t => t * t,\n  easeOutQuad: t => -t * (t - 2),\n  easeInOutQuad: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n  easeInCubic: t => t * t * t,\n  easeOutCubic: t => (t -= 1) * t * t + 1,\n  easeInOutCubic: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n  easeInQuart: t => t * t * t * t,\n  easeOutQuart: t => -((t -= 1) * t * t * t - 1),\n  easeInOutQuart: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n  easeInQuint: t => t * t * t * t * t,\n  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\n  easeInOutQuint: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n  easeInSine: t => -Math.cos(t * HALF_PI) + 1,\n  easeOutSine: t => Math.sin(t * HALF_PI),\n  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\n  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n  easeInOutExpo: t => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\n  easeInOutCirc: t => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n  easeInOutElastic(t) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n  easeInBack(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n  easeOutBack(t) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n  easeInOutBack(t) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\n  easeOutBounce(t) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n  easeInOutBounce: t => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n};\n\n/*!\n * @kurkle/color v0.1.9\n * https://github.com/kurkle/color#readme\n * (c) 2020 Jukka Kurkela\n * Released under the MIT License\n */\nconst map = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = '0123456789ABCDEF';\nconst h1 = (b) => hex[b & 0xF];\nconst h2 = (b) => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = (b) => (((b & 0xF0) >> 4) === (b & 0xF));\nfunction isShort(v) {\n\treturn eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\n}\nfunction hexParse(str) {\n\tvar len = str.length;\n\tvar ret;\n\tif (str[0] === '#') {\n\t\tif (len === 4 || len === 5) {\n\t\t\tret = {\n\t\t\t\tr: 255 & map[str[1]] * 17,\n\t\t\t\tg: 255 & map[str[2]] * 17,\n\t\t\t\tb: 255 & map[str[3]] * 17,\n\t\t\t\ta: len === 5 ? map[str[4]] * 17 : 255\n\t\t\t};\n\t\t} else if (len === 7 || len === 9) {\n\t\t\tret = {\n\t\t\t\tr: map[str[1]] << 4 | map[str[2]],\n\t\t\t\tg: map[str[3]] << 4 | map[str[4]],\n\t\t\t\tb: map[str[5]] << 4 | map[str[6]],\n\t\t\t\ta: len === 9 ? (map[str[7]] << 4 | map[str[8]]) : 255\n\t\t\t};\n\t\t}\n\t}\n\treturn ret;\n}\nfunction hexString(v) {\n\tvar f = isShort(v) ? h1 : h2;\n\treturn v\n\t\t? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '')\n\t\t: v;\n}\nfunction round(v) {\n\treturn v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n\treturn lim(round(v * 2.55), 0, 255);\n}\nfunction n2b(v) {\n\treturn lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n\treturn lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n\treturn lim(round(v * 100), 0, 100);\n}\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n\tconst m = RGB_RE.exec(str);\n\tlet a = 255;\n\tlet r, g, b;\n\tif (!m) {\n\t\treturn;\n\t}\n\tif (m[7] !== r) {\n\t\tconst v = +m[7];\n\t\ta = 255 & (m[8] ? p2b(v) : v * 255);\n\t}\n\tr = +m[1];\n\tg = +m[3];\n\tb = +m[5];\n\tr = 255 & (m[2] ? p2b(r) : r);\n\tg = 255 & (m[4] ? p2b(g) : g);\n\tb = 255 & (m[6] ? p2b(b) : b);\n\treturn {\n\t\tr: r,\n\t\tg: g,\n\t\tb: b,\n\t\ta: a\n\t};\n}\nfunction rgbString(v) {\n\treturn v && (\n\t\tv.a < 255\n\t\t\t? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n\t\t\t: `rgb(${v.r}, ${v.g}, ${v.b})`\n\t);\n}\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n\tconst a = s * Math.min(l, 1 - l);\n\tconst f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n\treturn [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n\tconst f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n\treturn [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n\tconst rgb = hsl2rgbn(h, 1, 0.5);\n\tlet i;\n\tif (w + b > 1) {\n\t\ti = 1 / (w + b);\n\t\tw *= i;\n\t\tb *= i;\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\trgb[i] *= 1 - w - b;\n\t\trgb[i] += w;\n\t}\n\treturn rgb;\n}\nfunction rgb2hsl(v) {\n\tconst range = 255;\n\tconst r = v.r / range;\n\tconst g = v.g / range;\n\tconst b = v.b / range;\n\tconst max = Math.max(r, g, b);\n\tconst min = Math.min(r, g, b);\n\tconst l = (max + min) / 2;\n\tlet h, s, d;\n\tif (max !== min) {\n\t\td = max - min;\n\t\ts = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\t\th = max === r\n\t\t\t? ((g - b) / d) + (g < b ? 6 : 0)\n\t\t\t: max === g\n\t\t\t\t? (b - r) / d + 2\n\t\t\t\t: (r - g) / d + 4;\n\t\th = h * 60 + 0.5;\n\t}\n\treturn [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n\treturn (\n\t\tArray.isArray(a)\n\t\t\t? f(a[0], a[1], a[2])\n\t\t\t: f(a, b, c)\n\t).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n\treturn calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n\treturn calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n\treturn calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n\treturn (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n\tconst m = HUE_RE.exec(str);\n\tlet a = 255;\n\tlet v;\n\tif (!m) {\n\t\treturn;\n\t}\n\tif (m[5] !== v) {\n\t\ta = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n\t}\n\tconst h = hue(+m[2]);\n\tconst p1 = +m[3] / 100;\n\tconst p2 = +m[4] / 100;\n\tif (m[1] === 'hwb') {\n\t\tv = hwb2rgb(h, p1, p2);\n\t} else if (m[1] === 'hsv') {\n\t\tv = hsv2rgb(h, p1, p2);\n\t} else {\n\t\tv = hsl2rgb(h, p1, p2);\n\t}\n\treturn {\n\t\tr: v[0],\n\t\tg: v[1],\n\t\tb: v[2],\n\t\ta: a\n\t};\n}\nfunction rotate(v, deg) {\n\tvar h = rgb2hsl(v);\n\th[0] = hue(h[0] + deg);\n\th = hsl2rgb(h);\n\tv.r = h[0];\n\tv.g = h[1];\n\tv.b = h[2];\n}\nfunction hslString(v) {\n\tif (!v) {\n\t\treturn;\n\t}\n\tconst a = rgb2hsl(v);\n\tconst h = a[0];\n\tconst s = n2p(a[1]);\n\tconst l = n2p(a[2]);\n\treturn v.a < 255\n\t\t? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n\t\t: `hsl(${h}, ${s}%, ${l}%)`;\n}\nconst map$1 = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n\tconst unpacked = {};\n\tconst keys = Object.keys(names);\n\tconst tkeys = Object.keys(map$1);\n\tlet i, j, k, ok, nk;\n\tfor (i = 0; i < keys.length; i++) {\n\t\tok = nk = keys[i];\n\t\tfor (j = 0; j < tkeys.length; j++) {\n\t\t\tk = tkeys[j];\n\t\t\tnk = nk.replace(k, map$1[k]);\n\t\t}\n\t\tk = parseInt(names[ok], 16);\n\t\tunpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n\t}\n\treturn unpacked;\n}\nlet names$1;\nfunction nameParse(str) {\n\tif (!names$1) {\n\t\tnames$1 = unpack();\n\t\tnames$1.transparent = [0, 0, 0, 0];\n\t}\n\tconst a = names$1[str.toLowerCase()];\n\treturn a && {\n\t\tr: a[0],\n\t\tg: a[1],\n\t\tb: a[2],\n\t\ta: a.length === 4 ? a[3] : 255\n\t};\n}\nfunction modHSL(v, i, ratio) {\n\tif (v) {\n\t\tlet tmp = rgb2hsl(v);\n\t\ttmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n\t\ttmp = hsl2rgb(tmp);\n\t\tv.r = tmp[0];\n\t\tv.g = tmp[1];\n\t\tv.b = tmp[2];\n\t}\n}\nfunction clone(v, proto) {\n\treturn v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n\tvar v = {r: 0, g: 0, b: 0, a: 255};\n\tif (Array.isArray(input)) {\n\t\tif (input.length >= 3) {\n\t\t\tv = {r: input[0], g: input[1], b: input[2], a: 255};\n\t\t\tif (input.length > 3) {\n\t\t\t\tv.a = n2b(input[3]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tv = clone(input, {r: 0, g: 0, b: 0, a: 1});\n\t\tv.a = n2b(v.a);\n\t}\n\treturn v;\n}\nfunction functionParse(str) {\n\tif (str.charAt(0) === 'r') {\n\t\treturn rgbParse(str);\n\t}\n\treturn hueParse(str);\n}\nclass Color {\n\tconstructor(input) {\n\t\tif (input instanceof Color) {\n\t\t\treturn input;\n\t\t}\n\t\tconst type = typeof input;\n\t\tlet v;\n\t\tif (type === 'object') {\n\t\t\tv = fromObject(input);\n\t\t} else if (type === 'string') {\n\t\t\tv = hexParse(input) || nameParse(input) || functionParse(input);\n\t\t}\n\t\tthis._rgb = v;\n\t\tthis._valid = !!v;\n\t}\n\tget valid() {\n\t\treturn this._valid;\n\t}\n\tget rgb() {\n\t\tvar v = clone(this._rgb);\n\t\tif (v) {\n\t\t\tv.a = b2n(v.a);\n\t\t}\n\t\treturn v;\n\t}\n\tset rgb(obj) {\n\t\tthis._rgb = fromObject(obj);\n\t}\n\trgbString() {\n\t\treturn this._valid ? rgbString(this._rgb) : this._rgb;\n\t}\n\thexString() {\n\t\treturn this._valid ? hexString(this._rgb) : this._rgb;\n\t}\n\thslString() {\n\t\treturn this._valid ? hslString(this._rgb) : this._rgb;\n\t}\n\tmix(color, weight) {\n\t\tconst me = this;\n\t\tif (color) {\n\t\t\tconst c1 = me.rgb;\n\t\t\tconst c2 = color.rgb;\n\t\t\tlet w2;\n\t\t\tconst p = weight === w2 ? 0.5 : weight;\n\t\t\tconst w = 2 * p - 1;\n\t\t\tconst a = c1.a - c2.a;\n\t\t\tconst w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\t\tw2 = 1 - w1;\n\t\t\tc1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n\t\t\tc1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n\t\t\tc1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n\t\t\tc1.a = p * c1.a + (1 - p) * c2.a;\n\t\t\tme.rgb = c1;\n\t\t}\n\t\treturn me;\n\t}\n\tclone() {\n\t\treturn new Color(this.rgb);\n\t}\n\talpha(a) {\n\t\tthis._rgb.a = n2b(a);\n\t\treturn this;\n\t}\n\tclearer(ratio) {\n\t\tconst rgb = this._rgb;\n\t\trgb.a *= 1 - ratio;\n\t\treturn this;\n\t}\n\tgreyscale() {\n\t\tconst rgb = this._rgb;\n\t\tconst val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n\t\trgb.r = rgb.g = rgb.b = val;\n\t\treturn this;\n\t}\n\topaquer(ratio) {\n\t\tconst rgb = this._rgb;\n\t\trgb.a *= 1 + ratio;\n\t\treturn this;\n\t}\n\tnegate() {\n\t\tconst v = this._rgb;\n\t\tv.r = 255 - v.r;\n\t\tv.g = 255 - v.g;\n\t\tv.b = 255 - v.b;\n\t\treturn this;\n\t}\n\tlighten(ratio) {\n\t\tmodHSL(this._rgb, 2, ratio);\n\t\treturn this;\n\t}\n\tdarken(ratio) {\n\t\tmodHSL(this._rgb, 2, -ratio);\n\t\treturn this;\n\t}\n\tsaturate(ratio) {\n\t\tmodHSL(this._rgb, 1, ratio);\n\t\treturn this;\n\t}\n\tdesaturate(ratio) {\n\t\tmodHSL(this._rgb, 1, -ratio);\n\t\treturn this;\n\t}\n\trotate(deg) {\n\t\trotate(this._rgb, deg);\n\t\treturn this;\n\t}\n}\nfunction index_esm(input) {\n\treturn new Color(input);\n}\n\nconst isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;\nfunction color(value) {\n  return isPatternOrGradient(value) ? value : index_esm(value);\n}\nfunction getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope$1(root, scope), values);\n  }\n  return merge(getScope$1(root, ''), scope);\n}\nclass Defaults {\n  constructor(_descriptors) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n    this.describe(_descriptors);\n  }\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n  get(scope) {\n    return getScope$1(this, scope);\n  }\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope$1(this, scope);\n    const targetScopeObject = getScope$1(this, targetScope);\n    const privateName = '_' + name;\n    Object.defineProperties(scopeObject, {\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n}\nvar defaults = new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n});\n\nfunction toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n  ctx.save();\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i, j, jlen, thing, nestedThing;\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n  ctx.restore();\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clearCanvas(canvas, ctx) {\n  ctx = ctx || canvas.getContext('2d');\n  ctx.save();\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n  let type, xOffset, yOffset, size, cornerRadius;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n  ctx.beginPath();\n  switch (style) {\n  default:\n    ctx.arc(x, y, radius, 0, TAU);\n    ctx.closePath();\n    break;\n  case 'triangle':\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    ctx.closePath();\n    break;\n  case 'rectRounded':\n    cornerRadius = radius * 0.516;\n    size = radius - cornerRadius;\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n    ctx.closePath();\n    break;\n  case 'rect':\n    if (!rotation) {\n      size = Math.SQRT1_2 * radius;\n      ctx.rect(x - size, y - size, 2 * size, 2 * size);\n      break;\n    }\n    rad += QUARTER_PI;\n  case 'rectRot':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    ctx.closePath();\n    break;\n  case 'crossRot':\n    rad += QUARTER_PI;\n  case 'cross':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'star':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    rad += QUARTER_PI;\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'line':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    break;\n  case 'dash':\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n    break;\n  }\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\nfunction _isPointInArea(point, area, margin) {\n  margin = margin || 0.5;\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\nfunction clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\nfunction unclipArea(ctx) {\n  ctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\nfunction renderText(ctx, text, x, y, font, opts = {}) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i, line;\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n    y += font.lineHeight;\n  }\n  ctx.restore();\n}\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\nfunction addRoundedRectPath(ctx, rect) {\n  const {x, y, w, h, radius} = rect;\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n  ctx.lineTo(x + w, y + radius.topRight);\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n  ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\nfunction toLineHeight(value, size) {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n  value = +matches[2];\n  switch (matches[3]) {\n  case 'px':\n    return value;\n  case '%':\n    value /= 100;\n    break;\n  }\n  return size * value;\n}\nconst numberOrZero = v => +v || 0;\nfunction _readValueToProps(value, props) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\nfunction toTRBL(value) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\nfunction toTRBLCorners(value) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\nfunction toPadding(value) {\n  const obj = toTRBL(value);\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n  return obj;\n}\nfunction toFont(options, fallback) {\n  options = options || {};\n  fallback = fallback || defaults.font;\n  let size = valueOrDefault(options.size, fallback.size);\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = '';\n  }\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n  font.string = toFontString(font);\n  return font;\n}\nfunction resolve(inputs, context, index, info) {\n  let cacheable = true;\n  let i, ilen, value;\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\nfunction _addGrace(minmax, grace, beginAtZero) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\nfunction createContext(parentContext, context) {\n  return Object.assign(Object.create(parentContext), context);\n}\n\nfunction _lookup(table, value, cmp) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid;\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return {lo, hi};\n}\nconst _lookupByKey = (table, key, value) =>\n  _lookup(table, value, index => table[index][key] < value);\nconst _rlookupByKey = (table, key, value) =>\n  _lookup(table, value, index => table[index][key] >= value);\nfunction _filterBetween(values, min, max) {\n  let start = 0;\n  let end = values.length;\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\nfunction listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n        return res;\n      }\n    });\n  });\n}\nfunction unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n  if (listeners.length > 0) {\n    return;\n  }\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n  delete array._chartjs;\n}\nfunction _arrayUnique(items) {\n  const set = new Set();\n  let i, ilen;\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    set.add(items[i]);\n  }\n  if (set.size === ilen) {\n    return items;\n  }\n  return Array.from(set);\n}\n\nfunction _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\n  if (!defined(fallback)) {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: rootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete target._keys;\n      delete scopes[0][prop];\n      return true;\n    },\n    get(target, prop) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n    has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n    set(target, prop, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value;\n      delete target._keys;\n      return true;\n    }\n  });\n}\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  const cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete proxy[prop];\n      return true;\n    },\n    get(target, prop, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n    set(target, prop, value) {\n      proxy[prop] = value;\n      delete target[prop];\n      return true;\n    }\n  });\n}\nfunction _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n  const value = resolve();\n  target[prop] = value;\n  return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop];\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\nfunction _resolveScriptable(prop, value, target, receiver) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  value = value(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  if (defined(_context.index) && isIndexable(prop)) {\n    value = value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n        return fallback;\n      }\n    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n      return null;\n    }\n  }\n  return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (defined(fallback) && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    return value;\n  }\n  return target;\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  let value;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (defined(value)) {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\nfunction _resolve(key, scopes) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (defined(value)) {\n      return value;\n    }\n  }\n}\nfunction getKeysFromAllScopes(target) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n  const set = new Set();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n  const fa = t * s01;\n  const fb = t * s12;\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\nfunction monotoneAdjust(points, deltaK, mK) {\n  const pointsLen = points.length;\n  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\nfunction splineCurveMonotone(points, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK = Array(pointsLen).fill(0);\n  const mK = Array(pointsLen);\n  let i, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n      : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n  monotoneAdjust(points, deltaK, mK);\n  monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n  return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n  let i, ilen, point, controlPoints;\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n\nfunction _isDomSupported() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\nfunction _getParentNode(domNode) {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = parent.host;\n  }\n  return parent;\n}\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n  let valueInPixels;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n    if (styleValue.indexOf('%') !== -1) {\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n  return valueInPixels;\n}\nconst getComputedStyle = (element) => window.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n  return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles, style, suffix) {\n  const result = {};\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\nconst useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\nfunction getCanvasPosition(evt, canvas) {\n  const e = evt.native || evt;\n  const touches = e.touches;\n  const source = touches && touches.length ? touches[0] : e;\n  const {offsetX, offsetY} = source;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\nfunction getRelativePosition(evt, chart) {\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(evt, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\nfunction getContainerSize(canvas, width, height) {\n  let maxWidth, maxHeight;\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect();\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\nconst round1 = v => Math.round(v * 10) / 10;\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    height = round1(width / 2);\n  }\n  return {\n    width,\n    height\n  };\n}\nfunction retinaScale(chart, forceRatio, forceStyle) {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n  chart.height = deviceHeight / pixelRatio;\n  chart.width = deviceWidth / pixelRatio;\n  const canvas = chart.canvas;\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\nconst supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() {\n        passiveSupported = true;\n        return false;\n      }\n    };\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n  }\n  return passiveSupported;\n}());\nfunction readUsedSize(element, property) {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n\nfunction _pointInLine(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\nfunction _steppedInterpolation(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n    : mode === 'after' ? t < 1 ? p1.y : p2.y\n    : t > 0 ? p2.y : p1.y\n  };\n}\nfunction _bezierInterpolation(p1, p2, t, mode) {\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\nfunction formatNumber(num, locale, options) {\n  return getNumberFormat(locale, options).format(num);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\nconst getLeftToRightAdapter = function() {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) {\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) {\n      return x;\n    },\n  };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n  let style, original;\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n    style.setProperty('direction', direction, 'important');\n    ctx.prevTextDirection = original;\n  }\n}\nfunction restoreTextDirection(ctx, original) {\n  if (original !== undefined) {\n    delete ctx.prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  let {start, end, loop} = segment;\n  let i, ilen;\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\nfunction _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n    if (point.skip) {\n      continue;\n    }\n    value = normalize(point[property]);\n    if (value === prevValue) {\n      continue;\n    }\n    inside = between(value, startBound, endBound);\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n  return result;\n}\nfunction _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n  if (loop && !spanGaps) {\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n  while (start < count && points[start].skip) {\n    start++;\n  }\n  start %= count;\n  if (loop) {\n    end += start;\n  }\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n  end %= count;\n  return {start, end};\n}\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n  return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n  if (!count) {\n    return [];\n  }\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n  return result;\n}\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\nfunction styleChanged(style, prevStyle) {\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\n\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/chart.js/dist/chunks/helpers.segment.js?");

/***/ }),

/***/ "./node_modules/dijkstrajs/dijkstra.js":
/*!*********************************************!*\
  !*** ./node_modules/dijkstrajs/dijkstra.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\nvar dijkstra = {\n  single_source_shortest_paths: function(graph, s, d) {\n    // Predecessor map for each node that has been encountered.\n    // node ID => predecessor node ID\n    var predecessors = {};\n\n    // Costs of shortest paths from s to all nodes encountered.\n    // node ID => cost\n    var costs = {};\n    costs[s] = 0;\n\n    // Costs of shortest paths from s to all nodes encountered; differs from\n    // `costs` in that it provides easy access to the node that currently has\n    // the known shortest path from s.\n    // XXX: Do we actually need both `costs` and `open`?\n    var open = dijkstra.PriorityQueue.make();\n    open.push(s, 0);\n\n    var closest,\n        u, v,\n        cost_of_s_to_u,\n        adjacent_nodes,\n        cost_of_e,\n        cost_of_s_to_u_plus_cost_of_e,\n        cost_of_s_to_v,\n        first_visit;\n    while (!open.empty()) {\n      // In the nodes remaining in graph that have a known cost from s,\n      // find the node, u, that currently has the shortest path from s.\n      closest = open.pop();\n      u = closest.value;\n      cost_of_s_to_u = closest.cost;\n\n      // Get nodes adjacent to u...\n      adjacent_nodes = graph[u] || {};\n\n      // ...and explore the edges that connect u to those nodes, updating\n      // the cost of the shortest paths to any or all of those nodes as\n      // necessary. v is the node across the current edge from u.\n      for (v in adjacent_nodes) {\n        if (adjacent_nodes.hasOwnProperty(v)) {\n          // Get the cost of the edge running from u to v.\n          cost_of_e = adjacent_nodes[v];\n\n          // Cost of s to u plus the cost of u to v across e--this is *a*\n          // cost from s to v that may or may not be less than the current\n          // known cost to v.\n          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n          // If we haven't visited v yet OR if the current known cost from s to\n          // v is greater than the new cost we just found (cost of s to u plus\n          // cost of u to v across e), update v's cost in the cost list and\n          // update v's predecessor in the predecessor list (it's now u).\n          cost_of_s_to_v = costs[v];\n          first_visit = (typeof costs[v] === 'undefined');\n          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n            costs[v] = cost_of_s_to_u_plus_cost_of_e;\n            open.push(v, cost_of_s_to_u_plus_cost_of_e);\n            predecessors[v] = u;\n          }\n        }\n      }\n    }\n\n    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {\n      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n      throw new Error(msg);\n    }\n\n    return predecessors;\n  },\n\n  extract_shortest_path_from_predecessor_list: function(predecessors, d) {\n    var nodes = [];\n    var u = d;\n    var predecessor;\n    while (u) {\n      nodes.push(u);\n      predecessor = predecessors[u];\n      u = predecessors[u];\n    }\n    nodes.reverse();\n    return nodes;\n  },\n\n  find_path: function(graph, s, d) {\n    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n    return dijkstra.extract_shortest_path_from_predecessor_list(\n      predecessors, d);\n  },\n\n  /**\n   * A very naive priority queue implementation.\n   */\n  PriorityQueue: {\n    make: function (opts) {\n      var T = dijkstra.PriorityQueue,\n          t = {},\n          key;\n      opts = opts || {};\n      for (key in T) {\n        if (T.hasOwnProperty(key)) {\n          t[key] = T[key];\n        }\n      }\n      t.queue = [];\n      t.sorter = opts.sorter || T.default_sorter;\n      return t;\n    },\n\n    default_sorter: function (a, b) {\n      return a.cost - b.cost;\n    },\n\n    /**\n     * Add a new item to the queue and ensure the highest priority element\n     * is at the front of the queue.\n     */\n    push: function (value, cost) {\n      var item = {value: value, cost: cost};\n      this.queue.push(item);\n      this.queue.sort(this.sorter);\n    },\n\n    /**\n     * Return the highest priority element in the queue.\n     */\n    pop: function () {\n      return this.queue.shift();\n    },\n\n    empty: function () {\n      return this.queue.length === 0;\n    }\n  }\n};\n\n\n// node.js module exports\nif (true) {\n  module.exports = dijkstra;\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/dijkstrajs/dijkstra.js?");

/***/ }),

/***/ "./node_modules/encode-utf8/index.js":
/*!*******************************************!*\
  !*** ./node_modules/encode-utf8/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function encodeUtf8 (input) {\n  var result = []\n  var size = input.length\n\n  for (var index = 0; index < size; index++) {\n    var point = input.charCodeAt(index)\n\n    if (point >= 0xD800 && point <= 0xDBFF && size > index + 1) {\n      var second = input.charCodeAt(index + 1)\n\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        point = (point - 0xD800) * 0x400 + second - 0xDC00 + 0x10000\n        index += 1\n      }\n    }\n\n    // US-ASCII\n    if (point < 0x80) {\n      result.push(point)\n      continue\n    }\n\n    // 2-byte UTF-8\n    if (point < 0x800) {\n      result.push((point >> 6) | 192)\n      result.push((point & 63) | 128)\n      continue\n    }\n\n    // 3-byte UTF-8\n    if (point < 0xD800 || (point >= 0xE000 && point < 0x10000)) {\n      result.push((point >> 12) | 224)\n      result.push(((point >> 6) & 63) | 128)\n      result.push((point & 63) | 128)\n      continue\n    }\n\n    // 4-byte UTF-8\n    if (point >= 0x10000 && point <= 0x10FFFF) {\n      result.push((point >> 18) | 240)\n      result.push(((point >> 12) & 63) | 128)\n      result.push(((point >> 6) & 63) | 128)\n      result.push((point & 63) | 128)\n      continue\n    }\n\n    // Invalid character\n    result.push(0xEF, 0xBF, 0xBD)\n  }\n\n  return new Uint8Array(result).buffer\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/encode-utf8/index.js?");

/***/ }),

/***/ "./node_modules/peerjs/dist/peerjs.min.js":
/*!************************************************!*\
  !*** ./node_modules/peerjs/dist/peerjs.min.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("parcelRequire=function(e,r,t,n){var i,o=\"function\"==typeof parcelRequire&&parcelRequire,u=undefined;function f(t,n){if(!r[t]){if(!e[t]){var i=\"function\"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if( true&&\"string\"==typeof t)return __webpack_require__(\"./node_modules/peerjs/dist sync recursive\")(t);var c=new Error(\"Cannot find module '\"+t+\"'\");throw c.code=\"MODULE_NOT_FOUND\",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]); true?module.exports=l:0}if(parcelRequire=f,i)throw i;return f}({\"EgBh\":[function(require,module,exports) {\nvar e={};e.useBlobBuilder=function(){try{return new Blob([]),!1}catch(e){return!0}}(),e.useArrayBufferView=!e.useBlobBuilder&&function(){try{return 0===new Blob([new Uint8Array([])]).size}catch(e){return!0}}(),module.exports.binaryFeatures=e;var r=module.exports.BlobBuilder;function t(){this._pieces=[],this._parts=[]}\"undefined\"!=typeof window&&(r=module.exports.BlobBuilder=window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder||window.BlobBuilder),t.prototype.append=function(e){\"number\"==typeof e?this._pieces.push(e):(this.flush(),this._parts.push(e))},t.prototype.flush=function(){if(this._pieces.length>0){var r=new Uint8Array(this._pieces);e.useArrayBufferView||(r=r.buffer),this._parts.push(r),this._pieces=[]}},t.prototype.getBuffer=function(){if(this.flush(),e.useBlobBuilder){for(var t=new r,i=0,u=this._parts.length;i<u;i++)t.append(this._parts[i]);return t.getBlob()}return new Blob(this._parts)},module.exports.BufferBuilder=t;\n},{}],\"kdPp\":[function(require,module,exports) {\nvar t=require(\"./bufferbuilder\").BufferBuilder,e=require(\"./bufferbuilder\").binaryFeatures,i={unpack:function(t){return new r(t).unpack()},pack:function(t){var e=new n;return e.pack(t),e.getBuffer()}};function r(t){this.index=0,this.dataBuffer=t,this.dataView=new Uint8Array(this.dataBuffer),this.length=this.dataBuffer.byteLength}function n(){this.bufferBuilder=new t}function u(t){var e=t.charCodeAt(0);return e<=2047?\"00\":e<=65535?\"000\":e<=2097151?\"0000\":e<=67108863?\"00000\":\"000000\"}function a(t){return t.length>600?new Blob([t]).size:t.replace(/[^\\u0000-\\u007F]/g,u).length}module.exports=i,r.prototype.unpack=function(){var t,e=this.unpack_uint8();if(e<128)return e;if((224^e)<32)return(224^e)-32;if((t=160^e)<=15)return this.unpack_raw(t);if((t=176^e)<=15)return this.unpack_string(t);if((t=144^e)<=15)return this.unpack_array(t);if((t=128^e)<=15)return this.unpack_map(t);switch(e){case 192:return null;case 193:return;case 194:return!1;case 195:return!0;case 202:return this.unpack_float();case 203:return this.unpack_double();case 204:return this.unpack_uint8();case 205:return this.unpack_uint16();case 206:return this.unpack_uint32();case 207:return this.unpack_uint64();case 208:return this.unpack_int8();case 209:return this.unpack_int16();case 210:return this.unpack_int32();case 211:return this.unpack_int64();case 212:case 213:case 214:case 215:return;case 216:return t=this.unpack_uint16(),this.unpack_string(t);case 217:return t=this.unpack_uint32(),this.unpack_string(t);case 218:return t=this.unpack_uint16(),this.unpack_raw(t);case 219:return t=this.unpack_uint32(),this.unpack_raw(t);case 220:return t=this.unpack_uint16(),this.unpack_array(t);case 221:return t=this.unpack_uint32(),this.unpack_array(t);case 222:return t=this.unpack_uint16(),this.unpack_map(t);case 223:return t=this.unpack_uint32(),this.unpack_map(t)}},r.prototype.unpack_uint8=function(){var t=255&this.dataView[this.index];return this.index++,t},r.prototype.unpack_uint16=function(){var t=this.read(2),e=256*(255&t[0])+(255&t[1]);return this.index+=2,e},r.prototype.unpack_uint32=function(){var t=this.read(4),e=256*(256*(256*t[0]+t[1])+t[2])+t[3];return this.index+=4,e},r.prototype.unpack_uint64=function(){var t=this.read(8),e=256*(256*(256*(256*(256*(256*(256*t[0]+t[1])+t[2])+t[3])+t[4])+t[5])+t[6])+t[7];return this.index+=8,e},r.prototype.unpack_int8=function(){var t=this.unpack_uint8();return t<128?t:t-256},r.prototype.unpack_int16=function(){var t=this.unpack_uint16();return t<32768?t:t-65536},r.prototype.unpack_int32=function(){var t=this.unpack_uint32();return t<Math.pow(2,31)?t:t-Math.pow(2,32)},r.prototype.unpack_int64=function(){var t=this.unpack_uint64();return t<Math.pow(2,63)?t:t-Math.pow(2,64)},r.prototype.unpack_raw=function(t){if(this.length<this.index+t)throw new Error(\"BinaryPackFailure: index is out of range \"+this.index+\" \"+t+\" \"+this.length);var e=this.dataBuffer.slice(this.index,this.index+t);return this.index+=t,e},r.prototype.unpack_string=function(t){for(var e,i,r=this.read(t),n=0,u=\"\";n<t;)(e=r[n])<128?(u+=String.fromCharCode(e),n++):(192^e)<32?(i=(192^e)<<6|63&r[n+1],u+=String.fromCharCode(i),n+=2):(i=(15&e)<<12|(63&r[n+1])<<6|63&r[n+2],u+=String.fromCharCode(i),n+=3);return this.index+=t,u},r.prototype.unpack_array=function(t){for(var e=new Array(t),i=0;i<t;i++)e[i]=this.unpack();return e},r.prototype.unpack_map=function(t){for(var e={},i=0;i<t;i++){var r=this.unpack(),n=this.unpack();e[r]=n}return e},r.prototype.unpack_float=function(){var t=this.unpack_uint32(),e=(t>>23&255)-127;return(0===t>>31?1:-1)*(8388607&t|8388608)*Math.pow(2,e-23)},r.prototype.unpack_double=function(){var t=this.unpack_uint32(),e=this.unpack_uint32(),i=(t>>20&2047)-1023;return(0===t>>31?1:-1)*((1048575&t|1048576)*Math.pow(2,i-20)+e*Math.pow(2,i-52))},r.prototype.read=function(t){var e=this.index;if(e+t<=this.length)return this.dataView.subarray(e,e+t);throw new Error(\"BinaryPackFailure: read index out of range\")},n.prototype.getBuffer=function(){return this.bufferBuilder.getBuffer()},n.prototype.pack=function(t){var i=typeof t;if(\"string\"===i)this.pack_string(t);else if(\"number\"===i)Math.floor(t)===t?this.pack_integer(t):this.pack_double(t);else if(\"boolean\"===i)!0===t?this.bufferBuilder.append(195):!1===t&&this.bufferBuilder.append(194);else if(\"undefined\"===i)this.bufferBuilder.append(192);else{if(\"object\"!==i)throw new Error('Type \"'+i+'\" not yet supported');if(null===t)this.bufferBuilder.append(192);else{var r=t.constructor;if(r==Array)this.pack_array(t);else if(r==Blob||r==File||t instanceof Blob||t instanceof File)this.pack_bin(t);else if(r==ArrayBuffer)e.useArrayBufferView?this.pack_bin(new Uint8Array(t)):this.pack_bin(t);else if(\"BYTES_PER_ELEMENT\"in t)e.useArrayBufferView?this.pack_bin(new Uint8Array(t.buffer)):this.pack_bin(t.buffer);else if(r==Object||r.toString().startsWith(\"class\"))this.pack_object(t);else if(r==Date)this.pack_string(t.toString());else{if(\"function\"!=typeof t.toBinaryPack)throw new Error('Type \"'+r.toString()+'\" not yet supported');this.bufferBuilder.append(t.toBinaryPack())}}}this.bufferBuilder.flush()},n.prototype.pack_bin=function(t){var e=t.length||t.byteLength||t.size;if(e<=15)this.pack_uint8(160+e);else if(e<=65535)this.bufferBuilder.append(218),this.pack_uint16(e);else{if(!(e<=4294967295))throw new Error(\"Invalid length\");this.bufferBuilder.append(219),this.pack_uint32(e)}this.bufferBuilder.append(t)},n.prototype.pack_string=function(t){var e=a(t);if(e<=15)this.pack_uint8(176+e);else if(e<=65535)this.bufferBuilder.append(216),this.pack_uint16(e);else{if(!(e<=4294967295))throw new Error(\"Invalid length\");this.bufferBuilder.append(217),this.pack_uint32(e)}this.bufferBuilder.append(t)},n.prototype.pack_array=function(t){var e=t.length;if(e<=15)this.pack_uint8(144+e);else if(e<=65535)this.bufferBuilder.append(220),this.pack_uint16(e);else{if(!(e<=4294967295))throw new Error(\"Invalid length\");this.bufferBuilder.append(221),this.pack_uint32(e)}for(var i=0;i<e;i++)this.pack(t[i])},n.prototype.pack_integer=function(t){if(t>=-32&&t<=127)this.bufferBuilder.append(255&t);else if(t>=0&&t<=255)this.bufferBuilder.append(204),this.pack_uint8(t);else if(t>=-128&&t<=127)this.bufferBuilder.append(208),this.pack_int8(t);else if(t>=0&&t<=65535)this.bufferBuilder.append(205),this.pack_uint16(t);else if(t>=-32768&&t<=32767)this.bufferBuilder.append(209),this.pack_int16(t);else if(t>=0&&t<=4294967295)this.bufferBuilder.append(206),this.pack_uint32(t);else if(t>=-2147483648&&t<=2147483647)this.bufferBuilder.append(210),this.pack_int32(t);else if(t>=-0x8000000000000000&&t<=0x8000000000000000)this.bufferBuilder.append(211),this.pack_int64(t);else{if(!(t>=0&&t<=0x10000000000000000))throw new Error(\"Invalid integer\");this.bufferBuilder.append(207),this.pack_uint64(t)}},n.prototype.pack_double=function(t){var e=0;t<0&&(e=1,t=-t);var i=Math.floor(Math.log(t)/Math.LN2),r=t/Math.pow(2,i)-1,n=Math.floor(r*Math.pow(2,52)),u=Math.pow(2,32),a=e<<31|i+1023<<20|n/u&1048575,p=n%u;this.bufferBuilder.append(203),this.pack_int32(a),this.pack_int32(p)},n.prototype.pack_object=function(t){var e=Object.keys(t).length;if(e<=15)this.pack_uint8(128+e);else if(e<=65535)this.bufferBuilder.append(222),this.pack_uint16(e);else{if(!(e<=4294967295))throw new Error(\"Invalid length\");this.bufferBuilder.append(223),this.pack_uint32(e)}for(var i in t)t.hasOwnProperty(i)&&(this.pack(i),this.pack(t[i]))},n.prototype.pack_uint8=function(t){this.bufferBuilder.append(t)},n.prototype.pack_uint16=function(t){this.bufferBuilder.append(t>>8),this.bufferBuilder.append(255&t)},n.prototype.pack_uint32=function(t){var e=4294967295&t;this.bufferBuilder.append((4278190080&e)>>>24),this.bufferBuilder.append((16711680&e)>>>16),this.bufferBuilder.append((65280&e)>>>8),this.bufferBuilder.append(255&e)},n.prototype.pack_uint64=function(t){var e=t/Math.pow(2,32),i=t%Math.pow(2,32);this.bufferBuilder.append((4278190080&e)>>>24),this.bufferBuilder.append((16711680&e)>>>16),this.bufferBuilder.append((65280&e)>>>8),this.bufferBuilder.append(255&e),this.bufferBuilder.append((4278190080&i)>>>24),this.bufferBuilder.append((16711680&i)>>>16),this.bufferBuilder.append((65280&i)>>>8),this.bufferBuilder.append(255&i)},n.prototype.pack_int8=function(t){this.bufferBuilder.append(255&t)},n.prototype.pack_int16=function(t){this.bufferBuilder.append((65280&t)>>8),this.bufferBuilder.append(255&t)},n.prototype.pack_int32=function(t){this.bufferBuilder.append(t>>>24&255),this.bufferBuilder.append((16711680&t)>>>16),this.bufferBuilder.append((65280&t)>>>8),this.bufferBuilder.append(255&t)},n.prototype.pack_int64=function(t){var e=Math.floor(t/Math.pow(2,32)),i=t%Math.pow(2,32);this.bufferBuilder.append((4278190080&e)>>>24),this.bufferBuilder.append((16711680&e)>>>16),this.bufferBuilder.append((65280&e)>>>8),this.bufferBuilder.append(255&e),this.bufferBuilder.append((4278190080&i)>>>24),this.bufferBuilder.append((16711680&i)>>>16),this.bufferBuilder.append((65280&i)>>>8),this.bufferBuilder.append(255&i)};\n},{\"./bufferbuilder\":\"EgBh\"}],\"iSxC\":[function(require,module,exports) {\n\"use strict\";function e(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function t(e){return(t=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.extractVersion=o,exports.wrapPeerConnectionEvent=i,exports.disableLog=s,exports.disableWarnings=a,exports.log=p,exports.deprecated=u,exports.detectBrowser=c,exports.compactObject=f,exports.walkStats=l,exports.filterStats=v;var n=!0,r=!0;function o(e,t,n){var r=e.match(t);return r&&r.length>=n&&parseInt(r[n],10)}function i(e,t,n){if(e.RTCPeerConnection){var r=e.RTCPeerConnection.prototype,o=r.addEventListener;r.addEventListener=function(e,r){if(e!==t)return o.apply(this,arguments);var i=function(e){var t=n(e);t&&(r.handleEvent?r.handleEvent(t):r(t))};return this._eventMap=this._eventMap||{},this._eventMap[t]||(this._eventMap[t]=new Map),this._eventMap[t].set(r,i),o.apply(this,[e,i])};var i=r.removeEventListener;r.removeEventListener=function(e,n){if(e!==t||!this._eventMap||!this._eventMap[t])return i.apply(this,arguments);if(!this._eventMap[t].has(n))return i.apply(this,arguments);var r=this._eventMap[t].get(n);return this._eventMap[t].delete(n),0===this._eventMap[t].size&&delete this._eventMap[t],0===Object.keys(this._eventMap).length&&delete this._eventMap,i.apply(this,[e,r])},Object.defineProperty(r,\"on\"+t,{get:function(){return this[\"_on\"+t]},set:function(e){this[\"_on\"+t]&&(this.removeEventListener(t,this[\"_on\"+t]),delete this[\"_on\"+t]),e&&this.addEventListener(t,this[\"_on\"+t]=e)},enumerable:!0,configurable:!0})}}function s(e){return\"boolean\"!=typeof e?new Error(\"Argument type: \"+t(e)+\". Please use a boolean.\"):(n=e,e?\"adapter.js logging disabled\":\"adapter.js logging enabled\")}function a(e){return\"boolean\"!=typeof e?new Error(\"Argument type: \"+t(e)+\". Please use a boolean.\"):(r=!e,\"adapter.js deprecation warnings \"+(e?\"disabled\":\"enabled\"))}function p(){if(\"object\"===(\"undefined\"==typeof window?\"undefined\":t(window))){if(n)return;\"undefined\"!=typeof console&&\"function\"==typeof console.log&&console.log.apply(console,arguments)}}function u(e,t){r&&console.warn(e+\" is deprecated, please use \"+t+\" instead.\")}function c(e){var t={browser:null,version:null};if(void 0===e||!e.navigator)return t.browser=\"Not a browser.\",t;var{navigator:n}=e;if(n.mozGetUserMedia)t.browser=\"firefox\",t.version=o(n.userAgent,/Firefox\\/(\\d+)\\./,1);else if(n.webkitGetUserMedia||!1===e.isSecureContext&&e.webkitRTCPeerConnection&&!e.RTCIceGatherer)t.browser=\"chrome\",t.version=o(n.userAgent,/Chrom(e|ium)\\/(\\d+)\\./,2);else if(n.mediaDevices&&n.userAgent.match(/Edge\\/(\\d+).(\\d+)$/))t.browser=\"edge\",t.version=o(n.userAgent,/Edge\\/(\\d+).(\\d+)$/,2);else{if(!e.RTCPeerConnection||!n.userAgent.match(/AppleWebKit\\/(\\d+)\\./))return t.browser=\"Not a supported browser.\",t;t.browser=\"safari\",t.version=o(n.userAgent,/AppleWebKit\\/(\\d+)\\./,1),t.supportsUnifiedPlan=e.RTCRtpTransceiver&&\"currentDirection\"in e.RTCRtpTransceiver.prototype}return t}function d(e){return\"[object Object]\"===Object.prototype.toString.call(e)}function f(t){return d(t)?Object.keys(t).reduce(function(n,r){var o=d(t[r]),i=o?f(t[r]):t[r],s=o&&!Object.keys(i).length;return void 0===i||s?n:Object.assign(n,e({},r,i))},{}):t}function l(e,t,n){t&&!n.has(t.id)&&(n.set(t.id,t),Object.keys(t).forEach(function(r){r.endsWith(\"Id\")?l(e,e.get(t[r]),n):r.endsWith(\"Ids\")&&t[r].forEach(function(t){l(e,e.get(t),n)})}))}function v(e,t,n){var r=n?\"outbound-rtp\":\"inbound-rtp\",o=new Map;if(null===t)return o;var i=[];return e.forEach(function(e){\"track\"===e.type&&e.trackIdentifier===t.id&&i.push(e)}),i.forEach(function(t){e.forEach(function(n){n.type===r&&n.trackId===t.id&&l(e,n,o)})}),o}\n},{}],\"s6SN\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetUserMedia=i;var e=t(require(\"../utils.js\"));function r(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return r=function(){return e},e}function t(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=r();if(t&&t.has(e))return t.get(e);var o={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=n?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(o,i,a):o[i]=e[i]}return o.default=e,t&&t.set(e,o),o}function o(e){return(o=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}var n=e.log;function i(e,r){var t=e&&e.navigator;if(t.mediaDevices){var i=function(e){if(\"object\"!==o(e)||e.mandatory||e.optional)return e;var r={};return Object.keys(e).forEach(function(t){if(\"require\"!==t&&\"advanced\"!==t&&\"mediaSource\"!==t){var n=\"object\"===o(e[t])?e[t]:{ideal:e[t]};void 0!==n.exact&&\"number\"==typeof n.exact&&(n.min=n.max=n.exact);var i=function(e,r){return e?e+r.charAt(0).toUpperCase()+r.slice(1):\"deviceId\"===r?\"sourceId\":r};if(void 0!==n.ideal){r.optional=r.optional||[];var a={};\"number\"==typeof n.ideal?(a[i(\"min\",t)]=n.ideal,r.optional.push(a),(a={})[i(\"max\",t)]=n.ideal,r.optional.push(a)):(a[i(\"\",t)]=n.ideal,r.optional.push(a))}void 0!==n.exact&&\"number\"!=typeof n.exact?(r.mandatory=r.mandatory||{},r.mandatory[i(\"\",t)]=n.exact):[\"min\",\"max\"].forEach(function(e){void 0!==n[e]&&(r.mandatory=r.mandatory||{},r.mandatory[i(e,t)]=n[e])})}}),e.advanced&&(r.optional=(r.optional||[]).concat(e.advanced)),r},a=function(e,a){if(r.version>=61)return a(e);if((e=JSON.parse(JSON.stringify(e)))&&\"object\"===o(e.audio)){var c=function(e,r,t){r in e&&!(t in e)&&(e[t]=e[r],delete e[r])};c((e=JSON.parse(JSON.stringify(e))).audio,\"autoGainControl\",\"googAutoGainControl\"),c(e.audio,\"noiseSuppression\",\"googNoiseSuppression\"),e.audio=i(e.audio)}if(e&&\"object\"===o(e.video)){var d=e.video.facingMode;d=d&&(\"object\"===o(d)?d:{ideal:d});var u,s=r.version<66;if(d&&(\"user\"===d.exact||\"environment\"===d.exact||\"user\"===d.ideal||\"environment\"===d.ideal)&&(!t.mediaDevices.getSupportedConstraints||!t.mediaDevices.getSupportedConstraints().facingMode||s))if(delete e.video.facingMode,\"environment\"===d.exact||\"environment\"===d.ideal?u=[\"back\",\"rear\"]:\"user\"!==d.exact&&\"user\"!==d.ideal||(u=[\"front\"]),u)return t.mediaDevices.enumerateDevices().then(function(r){var t=(r=r.filter(function(e){return\"videoinput\"===e.kind})).find(function(e){return u.some(function(r){return e.label.toLowerCase().includes(r)})});return!t&&r.length&&u.includes(\"back\")&&(t=r[r.length-1]),t&&(e.video.deviceId=d.exact?{exact:t.deviceId}:{ideal:t.deviceId}),e.video=i(e.video),n(\"chrome: \"+JSON.stringify(e)),a(e)});e.video=i(e.video)}return n(\"chrome: \"+JSON.stringify(e)),a(e)},c=function(e){return r.version>=64?e:{name:{PermissionDeniedError:\"NotAllowedError\",PermissionDismissedError:\"NotAllowedError\",InvalidStateError:\"NotAllowedError\",DevicesNotFoundError:\"NotFoundError\",ConstraintNotSatisfiedError:\"OverconstrainedError\",TrackStartError:\"NotReadableError\",MediaDeviceFailedDueToShutdown:\"NotAllowedError\",MediaDeviceKillSwitchOn:\"NotAllowedError\",TabCaptureError:\"AbortError\",ScreenCaptureError:\"AbortError\",DeviceCaptureError:\"AbortError\"}[e.name]||e.name,message:e.message,constraint:e.constraint||e.constraintName,toString:function(){return this.name+(this.message&&\": \")+this.message}}};if(t.getUserMedia=function(e,r,o){a(e,function(e){t.webkitGetUserMedia(e,r,function(e){o&&o(c(e))})})}.bind(t),t.mediaDevices.getUserMedia){var d=t.mediaDevices.getUserMedia.bind(t.mediaDevices);t.mediaDevices.getUserMedia=function(e){return a(e,function(e){return d(e).then(function(r){if(e.audio&&!r.getAudioTracks().length||e.video&&!r.getVideoTracks().length)throw r.getTracks().forEach(function(e){e.stop()}),new DOMException(\"\",\"NotFoundError\");return r},function(e){return Promise.reject(c(e))})})}}}}\n},{\"../utils.js\":\"iSxC\"}],\"VHa8\":[function(require,module,exports) {\n\"use strict\";function e(e,i){e.navigator.mediaDevices&&\"getDisplayMedia\"in e.navigator.mediaDevices||e.navigator.mediaDevices&&(\"function\"==typeof i?e.navigator.mediaDevices.getDisplayMedia=function(a){return i(a).then(function(i){var t=a.video&&a.video.width,o=a.video&&a.video.height,d=a.video&&a.video.frameRate;return a.video={mandatory:{chromeMediaSource:\"desktop\",chromeMediaSourceId:i,maxFrameRate:d||3}},t&&(a.video.mandatory.maxWidth=t),o&&(a.video.mandatory.maxHeight=o),e.navigator.mediaDevices.getUserMedia(a)})}:console.error(\"shimGetDisplayMedia: getSourceId argument is not a function\"))}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetDisplayMedia=e;\n},{}],\"uI5X\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimMediaStream=a,exports.shimOnTrack=c,exports.shimGetSendersWithDtmf=p,exports.shimGetStats=d,exports.shimSenderReceiverGetStats=h,exports.shimAddTrackRemoveTrackWithNative=f,exports.shimAddTrackRemoveTrack=m,exports.shimPeerConnection=u,exports.fixNegotiationNeeded=l,Object.defineProperty(exports,\"shimGetUserMedia\",{enumerable:!0,get:function(){return t.shimGetUserMedia}}),Object.defineProperty(exports,\"shimGetDisplayMedia\",{enumerable:!0,get:function(){return r.shimGetDisplayMedia}});var e=i(require(\"../utils.js\")),t=require(\"./getusermedia\"),r=require(\"./getdisplaymedia\");function n(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return n=function(){return e},e}function i(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=n();if(t&&t.has(e))return t.get(e);var r={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if(Object.prototype.hasOwnProperty.call(e,o)){var s=i?Object.getOwnPropertyDescriptor(e,o):null;s&&(s.get||s.set)?Object.defineProperty(r,o,s):r[o]=e[o]}return r.default=e,t&&t.set(e,r),r}function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e){return(s=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function a(e){e.MediaStream=e.MediaStream||e.webkitMediaStream}function c(t){if(\"object\"!==s(t)||!t.RTCPeerConnection||\"ontrack\"in t.RTCPeerConnection.prototype)e.wrapPeerConnectionEvent(t,\"track\",function(e){return e.transceiver||Object.defineProperty(e,\"transceiver\",{value:{receiver:e.receiver}}),e});else{Object.defineProperty(t.RTCPeerConnection.prototype,\"ontrack\",{get:function(){return this._ontrack},set:function(e){this._ontrack&&this.removeEventListener(\"track\",this._ontrack),this.addEventListener(\"track\",this._ontrack=e)},enumerable:!0,configurable:!0});var r=t.RTCPeerConnection.prototype.setRemoteDescription;t.RTCPeerConnection.prototype.setRemoteDescription=function(){var e=this;return this._ontrackpoly||(this._ontrackpoly=function(r){r.stream.addEventListener(\"addtrack\",function(n){var i;i=t.RTCPeerConnection.prototype.getReceivers?e.getReceivers().find(function(e){return e.track&&e.track.id===n.track.id}):{track:n.track};var o=new Event(\"track\");o.track=n.track,o.receiver=i,o.transceiver={receiver:i},o.streams=[r.stream],e.dispatchEvent(o)}),r.stream.getTracks().forEach(function(n){var i;i=t.RTCPeerConnection.prototype.getReceivers?e.getReceivers().find(function(e){return e.track&&e.track.id===n.id}):{track:n};var o=new Event(\"track\");o.track=n,o.receiver=i,o.transceiver={receiver:i},o.streams=[r.stream],e.dispatchEvent(o)})},this.addEventListener(\"addstream\",this._ontrackpoly)),r.apply(this,arguments)}}}function p(e){if(\"object\"===s(e)&&e.RTCPeerConnection&&!(\"getSenders\"in e.RTCPeerConnection.prototype)&&\"createDTMFSender\"in e.RTCPeerConnection.prototype){var t=function(e,t){return{track:t,get dtmf(){return void 0===this._dtmf&&(\"audio\"===t.kind?this._dtmf=e.createDTMFSender(t):this._dtmf=null),this._dtmf},_pc:e}};if(!e.RTCPeerConnection.prototype.getSenders){e.RTCPeerConnection.prototype.getSenders=function(){return this._senders=this._senders||[],this._senders.slice()};var r=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addTrack=function(e,n){var i=r.apply(this,arguments);return i||(i=t(this,e),this._senders.push(i)),i};var n=e.RTCPeerConnection.prototype.removeTrack;e.RTCPeerConnection.prototype.removeTrack=function(e){n.apply(this,arguments);var t=this._senders.indexOf(e);-1!==t&&this._senders.splice(t,1)}}var i=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(e){var r=this;this._senders=this._senders||[],i.apply(this,[e]),e.getTracks().forEach(function(e){r._senders.push(t(r,e))})};var o=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){var t=this;this._senders=this._senders||[],o.apply(this,[e]),e.getTracks().forEach(function(e){var r=t._senders.find(function(t){return t.track===e});r&&t._senders.splice(t._senders.indexOf(r),1)})}}else if(\"object\"===s(e)&&e.RTCPeerConnection&&\"getSenders\"in e.RTCPeerConnection.prototype&&\"createDTMFSender\"in e.RTCPeerConnection.prototype&&e.RTCRtpSender&&!(\"dtmf\"in e.RTCRtpSender.prototype)){var a=e.RTCPeerConnection.prototype.getSenders;e.RTCPeerConnection.prototype.getSenders=function(){var e=this,t=a.apply(this,[]);return t.forEach(function(t){return t._pc=e}),t},Object.defineProperty(e.RTCRtpSender.prototype,\"dtmf\",{get:function(){return void 0===this._dtmf&&(\"audio\"===this.track.kind?this._dtmf=this._pc.createDTMFSender(this.track):this._dtmf=null),this._dtmf}})}}function d(e){if(e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(){var e=this,[r,n,i]=arguments;if(arguments.length>0&&\"function\"==typeof r)return t.apply(this,arguments);if(0===t.length&&(0===arguments.length||\"function\"!=typeof r))return t.apply(this,[]);var o=function(e){var t={};return e.result().forEach(function(e){var r={id:e.id,timestamp:e.timestamp,type:{localcandidate:\"local-candidate\",remotecandidate:\"remote-candidate\"}[e.type]||e.type};e.names().forEach(function(t){r[t]=e.stat(t)}),t[r.id]=r}),t},s=function(e){return new Map(Object.keys(e).map(function(t){return[t,e[t]]}))};if(arguments.length>=2){return t.apply(this,[function(e){n(s(o(e)))},r])}return new Promise(function(r,n){t.apply(e,[function(e){r(s(o(e)))},n])}).then(n,i)}}}function h(t){if(\"object\"===s(t)&&t.RTCPeerConnection&&t.RTCRtpSender&&t.RTCRtpReceiver){if(!(\"getStats\"in t.RTCRtpSender.prototype)){var r=t.RTCPeerConnection.prototype.getSenders;r&&(t.RTCPeerConnection.prototype.getSenders=function(){var e=this,t=r.apply(this,[]);return t.forEach(function(t){return t._pc=e}),t});var n=t.RTCPeerConnection.prototype.addTrack;n&&(t.RTCPeerConnection.prototype.addTrack=function(){var e=n.apply(this,arguments);return e._pc=this,e}),t.RTCRtpSender.prototype.getStats=function(){var t=this;return this._pc.getStats().then(function(r){return e.filterStats(r,t.track,!0)})}}if(!(\"getStats\"in t.RTCRtpReceiver.prototype)){var i=t.RTCPeerConnection.prototype.getReceivers;i&&(t.RTCPeerConnection.prototype.getReceivers=function(){var e=this,t=i.apply(this,[]);return t.forEach(function(t){return t._pc=e}),t}),e.wrapPeerConnectionEvent(t,\"track\",function(e){return e.receiver._pc=e.srcElement,e}),t.RTCRtpReceiver.prototype.getStats=function(){var t=this;return this._pc.getStats().then(function(r){return e.filterStats(r,t.track,!1)})}}if(\"getStats\"in t.RTCRtpSender.prototype&&\"getStats\"in t.RTCRtpReceiver.prototype){var o=t.RTCPeerConnection.prototype.getStats;t.RTCPeerConnection.prototype.getStats=function(){if(arguments.length>0&&arguments[0]instanceof t.MediaStreamTrack){var e,r,n,i=arguments[0];return this.getSenders().forEach(function(t){t.track===i&&(e?n=!0:e=t)}),this.getReceivers().forEach(function(e){return e.track===i&&(r?n=!0:r=e),e.track===i}),n||e&&r?Promise.reject(new DOMException(\"There are more than one sender or receiver for the track.\",\"InvalidAccessError\")):e?e.getStats():r?r.getStats():Promise.reject(new DOMException(\"There is no sender or receiver for the track.\",\"InvalidAccessError\"))}return o.apply(this,arguments)}}}}function f(e){e.RTCPeerConnection.prototype.getLocalStreams=function(){var e=this;return this._shimmedLocalStreams=this._shimmedLocalStreams||{},Object.keys(this._shimmedLocalStreams).map(function(t){return e._shimmedLocalStreams[t][0]})};var t=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addTrack=function(e,r){if(!r)return t.apply(this,arguments);this._shimmedLocalStreams=this._shimmedLocalStreams||{};var n=t.apply(this,arguments);return this._shimmedLocalStreams[r.id]?-1===this._shimmedLocalStreams[r.id].indexOf(n)&&this._shimmedLocalStreams[r.id].push(n):this._shimmedLocalStreams[r.id]=[r,n],n};var r=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(e){var t=this;this._shimmedLocalStreams=this._shimmedLocalStreams||{},e.getTracks().forEach(function(e){if(t.getSenders().find(function(t){return t.track===e}))throw new DOMException(\"Track already exists.\",\"InvalidAccessError\")});var n=this.getSenders();r.apply(this,arguments);var i=this.getSenders().filter(function(e){return-1===n.indexOf(e)});this._shimmedLocalStreams[e.id]=[e].concat(i)};var n=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},delete this._shimmedLocalStreams[e.id],n.apply(this,arguments)};var i=e.RTCPeerConnection.prototype.removeTrack;e.RTCPeerConnection.prototype.removeTrack=function(e){var t=this;return this._shimmedLocalStreams=this._shimmedLocalStreams||{},e&&Object.keys(this._shimmedLocalStreams).forEach(function(r){var n=t._shimmedLocalStreams[r].indexOf(e);-1!==n&&t._shimmedLocalStreams[r].splice(n,1),1===t._shimmedLocalStreams[r].length&&delete t._shimmedLocalStreams[r]}),i.apply(this,arguments)}}function m(e,t){if(e.RTCPeerConnection){if(e.RTCPeerConnection.prototype.addTrack&&t.version>=65)return f(e);var r=e.RTCPeerConnection.prototype.getLocalStreams;e.RTCPeerConnection.prototype.getLocalStreams=function(){var e=this,t=r.apply(this);return this._reverseStreams=this._reverseStreams||{},t.map(function(t){return e._reverseStreams[t.id]})};var n=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(t){var r=this;if(this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},t.getTracks().forEach(function(e){if(r.getSenders().find(function(t){return t.track===e}))throw new DOMException(\"Track already exists.\",\"InvalidAccessError\")}),!this._reverseStreams[t.id]){var i=new e.MediaStream(t.getTracks());this._streams[t.id]=i,this._reverseStreams[i.id]=t,t=i}n.apply(this,[t])};var i=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},i.apply(this,[this._streams[e.id]||e]),delete this._reverseStreams[this._streams[e.id]?this._streams[e.id].id:e.id],delete this._streams[e.id]},e.RTCPeerConnection.prototype.addTrack=function(t,r){var n=this;if(\"closed\"===this.signalingState)throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\",\"InvalidStateError\");var i=[].slice.call(arguments,1);if(1!==i.length||!i[0].getTracks().find(function(e){return e===t}))throw new DOMException(\"The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.\",\"NotSupportedError\");if(this.getSenders().find(function(e){return e.track===t}))throw new DOMException(\"Track already exists.\",\"InvalidAccessError\");this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{};var o=this._streams[r.id];if(o)o.addTrack(t),Promise.resolve().then(function(){n.dispatchEvent(new Event(\"negotiationneeded\"))});else{var s=new e.MediaStream([t]);this._streams[r.id]=s,this._reverseStreams[s.id]=r,this.addStream(s)}return this.getSenders().find(function(e){return e.track===t})},[\"createOffer\",\"createAnswer\"].forEach(function(t){var r=e.RTCPeerConnection.prototype[t],n=o({},t,function(){var e=this,t=arguments;return arguments.length&&\"function\"==typeof arguments[0]?r.apply(this,[function(r){var n=c(e,r);t[0].apply(null,[n])},function(e){t[1]&&t[1].apply(null,e)},arguments[2]]):r.apply(this,arguments).then(function(t){return c(e,t)})});e.RTCPeerConnection.prototype[t]=n[t]});var s=e.RTCPeerConnection.prototype.setLocalDescription;e.RTCPeerConnection.prototype.setLocalDescription=function(){return arguments.length&&arguments[0].type?(arguments[0]=(e=this,t=arguments[0],r=t.sdp,Object.keys(e._reverseStreams||[]).forEach(function(t){var n=e._reverseStreams[t],i=e._streams[n.id];r=r.replace(new RegExp(n.id,\"g\"),i.id)}),new RTCSessionDescription({type:t.type,sdp:r})),s.apply(this,arguments)):s.apply(this,arguments);var e,t,r};var a=Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype,\"localDescription\");Object.defineProperty(e.RTCPeerConnection.prototype,\"localDescription\",{get:function(){var e=a.get.apply(this);return\"\"===e.type?e:c(this,e)}}),e.RTCPeerConnection.prototype.removeTrack=function(e){var t,r=this;if(\"closed\"===this.signalingState)throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\",\"InvalidStateError\");if(!e._pc)throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\",\"TypeError\");if(!(e._pc===this))throw new DOMException(\"Sender was not created by this connection.\",\"InvalidAccessError\");this._streams=this._streams||{},Object.keys(this._streams).forEach(function(n){r._streams[n].getTracks().find(function(t){return e.track===t})&&(t=r._streams[n])}),t&&(1===t.getTracks().length?this.removeStream(this._reverseStreams[t.id]):t.removeTrack(e.track),this.dispatchEvent(new Event(\"negotiationneeded\")))}}function c(e,t){var r=t.sdp;return Object.keys(e._reverseStreams||[]).forEach(function(t){var n=e._reverseStreams[t],i=e._streams[n.id];r=r.replace(new RegExp(i.id,\"g\"),n.id)}),new RTCSessionDescription({type:t.type,sdp:r})}}function u(e,t){!e.RTCPeerConnection&&e.webkitRTCPeerConnection&&(e.RTCPeerConnection=e.webkitRTCPeerConnection),e.RTCPeerConnection&&t.version<53&&[\"setLocalDescription\",\"setRemoteDescription\",\"addIceCandidate\"].forEach(function(t){var r=e.RTCPeerConnection.prototype[t],n=o({},t,function(){return arguments[0]=new(\"addIceCandidate\"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),r.apply(this,arguments)});e.RTCPeerConnection.prototype[t]=n[t]})}function l(t,r){e.wrapPeerConnectionEvent(t,\"negotiationneeded\",function(e){var t=e.target;if(!(r.version<72||t.getConfiguration&&\"plan-b\"===t.getConfiguration().sdpSemantics)||\"stable\"===t.signalingState)return e})}\n},{\"../utils.js\":\"iSxC\",\"./getusermedia\":\"s6SN\",\"./getdisplaymedia\":\"VHa8\"}],\"NZ1C\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.filterIceServers=n;var r=t(require(\"../utils\"));function e(){if(\"function\"!=typeof WeakMap)return null;var r=new WeakMap;return e=function(){return r},r}function t(r){if(r&&r.__esModule)return r;if(null===r||\"object\"!=typeof r&&\"function\"!=typeof r)return{default:r};var t=e();if(t&&t.has(r))return t.get(r);var n={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in r)if(Object.prototype.hasOwnProperty.call(r,i)){var f=u?Object.getOwnPropertyDescriptor(r,i):null;f&&(f.get||f.set)?Object.defineProperty(n,i,f):n[i]=r[i]}return n.default=r,t&&t.set(r,n),n}function n(e,t){var n=!1;return(e=JSON.parse(JSON.stringify(e))).filter(function(e){if(e&&(e.urls||e.url)){var t=e.urls||e.url;e.url&&!e.urls&&r.deprecated(\"RTCIceServer.url\",\"RTCIceServer.urls\");var u=\"string\"==typeof t;return u&&(t=[t]),t=t.filter(function(r){if(0===r.indexOf(\"stun:\"))return!1;var e=r.startsWith(\"turn\")&&!r.startsWith(\"turn:[\")&&r.includes(\"transport=udp\");return e&&!n?(n=!0,!0):e&&!n}),delete e.url,e.urls=u?t[0]:t,!!t.length}})}\n},{\"../utils\":\"iSxC\"}],\"YHvh\":[function(require,module,exports) {\n\"use strict\";var r={generateIdentifier:function(){return Math.random().toString(36).substr(2,10)}};r.localCName=r.generateIdentifier(),r.splitLines=function(r){return r.trim().split(\"\\n\").map(function(r){return r.trim()})},r.splitSections=function(r){return r.split(\"\\nm=\").map(function(r,e){return(e>0?\"m=\"+r:r).trim()+\"\\r\\n\"})},r.getDescription=function(e){var t=r.splitSections(e);return t&&t[0]},r.getMediaSections=function(e){var t=r.splitSections(e);return t.shift(),t},r.matchPrefix=function(e,t){return r.splitLines(e).filter(function(r){return 0===r.indexOf(t)})},r.parseCandidate=function(r){for(var e,t={foundation:(e=0===r.indexOf(\"a=candidate:\")?r.substring(12).split(\" \"):r.substring(10).split(\" \"))[0],component:parseInt(e[1],10),protocol:e[2].toLowerCase(),priority:parseInt(e[3],10),ip:e[4],address:e[4],port:parseInt(e[5],10),type:e[7]},a=8;a<e.length;a+=2)switch(e[a]){case\"raddr\":t.relatedAddress=e[a+1];break;case\"rport\":t.relatedPort=parseInt(e[a+1],10);break;case\"tcptype\":t.tcpType=e[a+1];break;case\"ufrag\":t.ufrag=e[a+1],t.usernameFragment=e[a+1];break;default:t[e[a]]=e[a+1]}return t},r.writeCandidate=function(r){var e=[];e.push(r.foundation),e.push(r.component),e.push(r.protocol.toUpperCase()),e.push(r.priority),e.push(r.address||r.ip),e.push(r.port);var t=r.type;return e.push(\"typ\"),e.push(t),\"host\"!==t&&r.relatedAddress&&r.relatedPort&&(e.push(\"raddr\"),e.push(r.relatedAddress),e.push(\"rport\"),e.push(r.relatedPort)),r.tcpType&&\"tcp\"===r.protocol.toLowerCase()&&(e.push(\"tcptype\"),e.push(r.tcpType)),(r.usernameFragment||r.ufrag)&&(e.push(\"ufrag\"),e.push(r.usernameFragment||r.ufrag)),\"candidate:\"+e.join(\" \")},r.parseIceOptions=function(r){return r.substr(14).split(\" \")},r.parseRtpMap=function(r){var e=r.substr(9).split(\" \"),t={payloadType:parseInt(e.shift(),10)};return e=e[0].split(\"/\"),t.name=e[0],t.clockRate=parseInt(e[1],10),t.channels=3===e.length?parseInt(e[2],10):1,t.numChannels=t.channels,t},r.writeRtpMap=function(r){var e=r.payloadType;void 0!==r.preferredPayloadType&&(e=r.preferredPayloadType);var t=r.channels||r.numChannels||1;return\"a=rtpmap:\"+e+\" \"+r.name+\"/\"+r.clockRate+(1!==t?\"/\"+t:\"\")+\"\\r\\n\"},r.parseExtmap=function(r){var e=r.substr(9).split(\" \");return{id:parseInt(e[0],10),direction:e[0].indexOf(\"/\")>0?e[0].split(\"/\")[1]:\"sendrecv\",uri:e[1]}},r.writeExtmap=function(r){return\"a=extmap:\"+(r.id||r.preferredId)+(r.direction&&\"sendrecv\"!==r.direction?\"/\"+r.direction:\"\")+\" \"+r.uri+\"\\r\\n\"},r.parseFmtp=function(r){for(var e,t={},a=r.substr(r.indexOf(\" \")+1).split(\";\"),n=0;n<a.length;n++)t[(e=a[n].trim().split(\"=\"))[0].trim()]=e[1];return t},r.writeFmtp=function(r){var e=\"\",t=r.payloadType;if(void 0!==r.preferredPayloadType&&(t=r.preferredPayloadType),r.parameters&&Object.keys(r.parameters).length){var a=[];Object.keys(r.parameters).forEach(function(e){r.parameters[e]?a.push(e+\"=\"+r.parameters[e]):a.push(e)}),e+=\"a=fmtp:\"+t+\" \"+a.join(\";\")+\"\\r\\n\"}return e},r.parseRtcpFb=function(r){var e=r.substr(r.indexOf(\" \")+1).split(\" \");return{type:e.shift(),parameter:e.join(\" \")}},r.writeRtcpFb=function(r){var e=\"\",t=r.payloadType;return void 0!==r.preferredPayloadType&&(t=r.preferredPayloadType),r.rtcpFeedback&&r.rtcpFeedback.length&&r.rtcpFeedback.forEach(function(r){e+=\"a=rtcp-fb:\"+t+\" \"+r.type+(r.parameter&&r.parameter.length?\" \"+r.parameter:\"\")+\"\\r\\n\"}),e},r.parseSsrcMedia=function(r){var e=r.indexOf(\" \"),t={ssrc:parseInt(r.substr(7,e-7),10)},a=r.indexOf(\":\",e);return a>-1?(t.attribute=r.substr(e+1,a-e-1),t.value=r.substr(a+1)):t.attribute=r.substr(e+1),t},r.parseSsrcGroup=function(r){var e=r.substr(13).split(\" \");return{semantics:e.shift(),ssrcs:e.map(function(r){return parseInt(r,10)})}},r.getMid=function(e){var t=r.matchPrefix(e,\"a=mid:\")[0];if(t)return t.substr(6)},r.parseFingerprint=function(r){var e=r.substr(14).split(\" \");return{algorithm:e[0].toLowerCase(),value:e[1]}},r.getDtlsParameters=function(e,t){return{role:\"auto\",fingerprints:r.matchPrefix(e+t,\"a=fingerprint:\").map(r.parseFingerprint)}},r.writeDtlsParameters=function(r,e){var t=\"a=setup:\"+e+\"\\r\\n\";return r.fingerprints.forEach(function(r){t+=\"a=fingerprint:\"+r.algorithm+\" \"+r.value+\"\\r\\n\"}),t},r.parseCryptoLine=function(r){var e=r.substr(9).split(\" \");return{tag:parseInt(e[0],10),cryptoSuite:e[1],keyParams:e[2],sessionParams:e.slice(3)}},r.writeCryptoLine=function(e){return\"a=crypto:\"+e.tag+\" \"+e.cryptoSuite+\" \"+(\"object\"==typeof e.keyParams?r.writeCryptoKeyParams(e.keyParams):e.keyParams)+(e.sessionParams?\" \"+e.sessionParams.join(\" \"):\"\")+\"\\r\\n\"},r.parseCryptoKeyParams=function(r){if(0!==r.indexOf(\"inline:\"))return null;var e=r.substr(7).split(\"|\");return{keyMethod:\"inline\",keySalt:e[0],lifeTime:e[1],mkiValue:e[2]?e[2].split(\":\")[0]:void 0,mkiLength:e[2]?e[2].split(\":\")[1]:void 0}},r.writeCryptoKeyParams=function(r){return r.keyMethod+\":\"+r.keySalt+(r.lifeTime?\"|\"+r.lifeTime:\"\")+(r.mkiValue&&r.mkiLength?\"|\"+r.mkiValue+\":\"+r.mkiLength:\"\")},r.getCryptoParameters=function(e,t){return r.matchPrefix(e+t,\"a=crypto:\").map(r.parseCryptoLine)},r.getIceParameters=function(e,t){var a=r.matchPrefix(e+t,\"a=ice-ufrag:\")[0],n=r.matchPrefix(e+t,\"a=ice-pwd:\")[0];return a&&n?{usernameFragment:a.substr(12),password:n.substr(10)}:null},r.writeIceParameters=function(r){return\"a=ice-ufrag:\"+r.usernameFragment+\"\\r\\na=ice-pwd:\"+r.password+\"\\r\\n\"},r.parseRtpParameters=function(e){for(var t={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},a=r.splitLines(e)[0].split(\" \"),n=3;n<a.length;n++){var s=a[n],i=r.matchPrefix(e,\"a=rtpmap:\"+s+\" \")[0];if(i){var p=r.parseRtpMap(i),c=r.matchPrefix(e,\"a=fmtp:\"+s+\" \");switch(p.parameters=c.length?r.parseFmtp(c[0]):{},p.rtcpFeedback=r.matchPrefix(e,\"a=rtcp-fb:\"+s+\" \").map(r.parseRtcpFb),t.codecs.push(p),p.name.toUpperCase()){case\"RED\":case\"ULPFEC\":t.fecMechanisms.push(p.name.toUpperCase())}}}return r.matchPrefix(e,\"a=extmap:\").forEach(function(e){t.headerExtensions.push(r.parseExtmap(e))}),t},r.writeRtpDescription=function(e,t){var a=\"\";a+=\"m=\"+e+\" \",a+=t.codecs.length>0?\"9\":\"0\",a+=\" UDP/TLS/RTP/SAVPF \",a+=t.codecs.map(function(r){return void 0!==r.preferredPayloadType?r.preferredPayloadType:r.payloadType}).join(\" \")+\"\\r\\n\",a+=\"c=IN IP4 0.0.0.0\\r\\n\",a+=\"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\",t.codecs.forEach(function(e){a+=r.writeRtpMap(e),a+=r.writeFmtp(e),a+=r.writeRtcpFb(e)});var n=0;return t.codecs.forEach(function(r){r.maxptime>n&&(n=r.maxptime)}),n>0&&(a+=\"a=maxptime:\"+n+\"\\r\\n\"),a+=\"a=rtcp-mux\\r\\n\",t.headerExtensions&&t.headerExtensions.forEach(function(e){a+=r.writeExtmap(e)}),a},r.parseRtpEncodingParameters=function(e){var t,a=[],n=r.parseRtpParameters(e),s=-1!==n.fecMechanisms.indexOf(\"RED\"),i=-1!==n.fecMechanisms.indexOf(\"ULPFEC\"),p=r.matchPrefix(e,\"a=ssrc:\").map(function(e){return r.parseSsrcMedia(e)}).filter(function(r){return\"cname\"===r.attribute}),c=p.length>0&&p[0].ssrc,o=r.matchPrefix(e,\"a=ssrc-group:FID\").map(function(r){return r.substr(17).split(\" \").map(function(r){return parseInt(r,10)})});o.length>0&&o[0].length>1&&o[0][0]===c&&(t=o[0][1]),n.codecs.forEach(function(r){if(\"RTX\"===r.name.toUpperCase()&&r.parameters.apt){var e={ssrc:c,codecPayloadType:parseInt(r.parameters.apt,10)};c&&t&&(e.rtx={ssrc:t}),a.push(e),s&&((e=JSON.parse(JSON.stringify(e))).fec={ssrc:c,mechanism:i?\"red+ulpfec\":\"red\"},a.push(e))}}),0===a.length&&c&&a.push({ssrc:c});var u=r.matchPrefix(e,\"b=\");return u.length&&(u=0===u[0].indexOf(\"b=TIAS:\")?parseInt(u[0].substr(7),10):0===u[0].indexOf(\"b=AS:\")?1e3*parseInt(u[0].substr(5),10)*.95-16e3:void 0,a.forEach(function(r){r.maxBitrate=u})),a},r.parseRtcpParameters=function(e){var t={},a=r.matchPrefix(e,\"a=ssrc:\").map(function(e){return r.parseSsrcMedia(e)}).filter(function(r){return\"cname\"===r.attribute})[0];a&&(t.cname=a.value,t.ssrc=a.ssrc);var n=r.matchPrefix(e,\"a=rtcp-rsize\");t.reducedSize=n.length>0,t.compound=0===n.length;var s=r.matchPrefix(e,\"a=rtcp-mux\");return t.mux=s.length>0,t},r.parseMsid=function(e){var t,a=r.matchPrefix(e,\"a=msid:\");if(1===a.length)return{stream:(t=a[0].substr(7).split(\" \"))[0],track:t[1]};var n=r.matchPrefix(e,\"a=ssrc:\").map(function(e){return r.parseSsrcMedia(e)}).filter(function(r){return\"msid\"===r.attribute});return n.length>0?{stream:(t=n[0].value.split(\" \"))[0],track:t[1]}:void 0},r.parseSctpDescription=function(e){var t,a=r.parseMLine(e),n=r.matchPrefix(e,\"a=max-message-size:\");n.length>0&&(t=parseInt(n[0].substr(19),10)),isNaN(t)&&(t=65536);var s=r.matchPrefix(e,\"a=sctp-port:\");if(s.length>0)return{port:parseInt(s[0].substr(12),10),protocol:a.fmt,maxMessageSize:t};if(r.matchPrefix(e,\"a=sctpmap:\").length>0){var i=r.matchPrefix(e,\"a=sctpmap:\")[0].substr(10).split(\" \");return{port:parseInt(i[0],10),protocol:i[1],maxMessageSize:t}}},r.writeSctpDescription=function(r,e){var t=[];return t=\"DTLS/SCTP\"!==r.protocol?[\"m=\"+r.kind+\" 9 \"+r.protocol+\" \"+e.protocol+\"\\r\\n\",\"c=IN IP4 0.0.0.0\\r\\n\",\"a=sctp-port:\"+e.port+\"\\r\\n\"]:[\"m=\"+r.kind+\" 9 \"+r.protocol+\" \"+e.port+\"\\r\\n\",\"c=IN IP4 0.0.0.0\\r\\n\",\"a=sctpmap:\"+e.port+\" \"+e.protocol+\" 65535\\r\\n\"],void 0!==e.maxMessageSize&&t.push(\"a=max-message-size:\"+e.maxMessageSize+\"\\r\\n\"),t.join(\"\")},r.generateSessionId=function(){return Math.random().toString().substr(2,21)},r.writeSessionBoilerplate=function(e,t,a){var n=void 0!==t?t:2;return\"v=0\\r\\no=\"+(a||\"thisisadapterortc\")+\" \"+(e||r.generateSessionId())+\" \"+n+\" IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\n\"},r.writeMediaSection=function(e,t,a,n){var s=r.writeRtpDescription(e.kind,t);if(s+=r.writeIceParameters(e.iceGatherer.getLocalParameters()),s+=r.writeDtlsParameters(e.dtlsTransport.getLocalParameters(),\"offer\"===a?\"actpass\":\"active\"),s+=\"a=mid:\"+e.mid+\"\\r\\n\",e.direction?s+=\"a=\"+e.direction+\"\\r\\n\":e.rtpSender&&e.rtpReceiver?s+=\"a=sendrecv\\r\\n\":e.rtpSender?s+=\"a=sendonly\\r\\n\":e.rtpReceiver?s+=\"a=recvonly\\r\\n\":s+=\"a=inactive\\r\\n\",e.rtpSender){var i=\"msid:\"+n.id+\" \"+e.rtpSender.track.id+\"\\r\\n\";s+=\"a=\"+i,s+=\"a=ssrc:\"+e.sendEncodingParameters[0].ssrc+\" \"+i,e.sendEncodingParameters[0].rtx&&(s+=\"a=ssrc:\"+e.sendEncodingParameters[0].rtx.ssrc+\" \"+i,s+=\"a=ssrc-group:FID \"+e.sendEncodingParameters[0].ssrc+\" \"+e.sendEncodingParameters[0].rtx.ssrc+\"\\r\\n\")}return s+=\"a=ssrc:\"+e.sendEncodingParameters[0].ssrc+\" cname:\"+r.localCName+\"\\r\\n\",e.rtpSender&&e.sendEncodingParameters[0].rtx&&(s+=\"a=ssrc:\"+e.sendEncodingParameters[0].rtx.ssrc+\" cname:\"+r.localCName+\"\\r\\n\"),s},r.getDirection=function(e,t){for(var a=r.splitLines(e),n=0;n<a.length;n++)switch(a[n]){case\"a=sendrecv\":case\"a=sendonly\":case\"a=recvonly\":case\"a=inactive\":return a[n].substr(2)}return t?r.getDirection(t):\"sendrecv\"},r.getKind=function(e){return r.splitLines(e)[0].split(\" \")[0].substr(2)},r.isRejected=function(r){return\"0\"===r.split(\" \",2)[1]},r.parseMLine=function(e){var t=r.splitLines(e)[0].substr(2).split(\" \");return{kind:t[0],port:parseInt(t[1],10),protocol:t[2],fmt:t.slice(3).join(\" \")}},r.parseOLine=function(e){var t=r.matchPrefix(e,\"o=\")[0].substr(2).split(\" \");return{username:t[0],sessionId:t[1],sessionVersion:parseInt(t[2],10),netType:t[3],addressType:t[4],address:t[5]}},r.isValidSDP=function(e){if(\"string\"!=typeof e||0===e.length)return!1;for(var t=r.splitLines(e),a=0;a<t.length;a++)if(t[a].length<2||\"=\"!==t[a].charAt(1))return!1;return!0},\"object\"==typeof module&&(module.exports=r);\n},{}],\"NJ2u\":[function(require,module,exports) {\n\"use strict\";var e=require(\"sdp\");function t(e){return{inboundrtp:\"inbound-rtp\",outboundrtp:\"outbound-rtp\",candidatepair:\"candidate-pair\",localcandidate:\"local-candidate\",remotecandidate:\"remote-candidate\"}[e.type]||e.type}function r(t,r,n,a,i){var s=e.writeRtpDescription(t.kind,r);if(s+=e.writeIceParameters(t.iceGatherer.getLocalParameters()),s+=e.writeDtlsParameters(t.dtlsTransport.getLocalParameters(),\"offer\"===n?\"actpass\":i||\"active\"),s+=\"a=mid:\"+t.mid+\"\\r\\n\",t.rtpSender&&t.rtpReceiver?s+=\"a=sendrecv\\r\\n\":t.rtpSender?s+=\"a=sendonly\\r\\n\":t.rtpReceiver?s+=\"a=recvonly\\r\\n\":s+=\"a=inactive\\r\\n\",t.rtpSender){var o=t.rtpSender._initialTrackId||t.rtpSender.track.id;t.rtpSender._initialTrackId=o;var c=\"msid:\"+(a?a.id:\"-\")+\" \"+o+\"\\r\\n\";s+=\"a=\"+c,s+=\"a=ssrc:\"+t.sendEncodingParameters[0].ssrc+\" \"+c,t.sendEncodingParameters[0].rtx&&(s+=\"a=ssrc:\"+t.sendEncodingParameters[0].rtx.ssrc+\" \"+c,s+=\"a=ssrc-group:FID \"+t.sendEncodingParameters[0].ssrc+\" \"+t.sendEncodingParameters[0].rtx.ssrc+\"\\r\\n\")}return s+=\"a=ssrc:\"+t.sendEncodingParameters[0].ssrc+\" cname:\"+e.localCName+\"\\r\\n\",t.rtpSender&&t.sendEncodingParameters[0].rtx&&(s+=\"a=ssrc:\"+t.sendEncodingParameters[0].rtx.ssrc+\" cname:\"+e.localCName+\"\\r\\n\"),s}function n(e,t){var r=!1;return(e=JSON.parse(JSON.stringify(e))).filter(function(e){if(e&&(e.urls||e.url)){var n=e.urls||e.url;e.url&&!e.urls&&console.warn(\"RTCIceServer.url is deprecated! Use urls instead.\");var a=\"string\"==typeof n;return a&&(n=[n]),n=n.filter(function(e){return 0===e.indexOf(\"turn:\")&&-1!==e.indexOf(\"transport=udp\")&&-1===e.indexOf(\"turn:[\")&&!r?(r=!0,!0):0===e.indexOf(\"stun:\")&&t>=14393&&-1===e.indexOf(\"?transport=udp\")}),delete e.url,e.urls=a?n[0]:n,!!n.length}})}function a(e,t){var r={codecs:[],headerExtensions:[],fecMechanisms:[]},n=function(e,t){e=parseInt(e,10);for(var r=0;r<t.length;r++)if(t[r].payloadType===e||t[r].preferredPayloadType===e)return t[r]},a=function(e,t,r,a){var i=n(e.parameters.apt,r),s=n(t.parameters.apt,a);return i&&s&&i.name.toLowerCase()===s.name.toLowerCase()};return e.codecs.forEach(function(n){for(var i=0;i<t.codecs.length;i++){var s=t.codecs[i];if(n.name.toLowerCase()===s.name.toLowerCase()&&n.clockRate===s.clockRate){if(\"rtx\"===n.name.toLowerCase()&&n.parameters&&s.parameters.apt&&!a(n,s,e.codecs,t.codecs))continue;(s=JSON.parse(JSON.stringify(s))).numChannels=Math.min(n.numChannels,s.numChannels),r.codecs.push(s),s.rtcpFeedback=s.rtcpFeedback.filter(function(e){for(var t=0;t<n.rtcpFeedback.length;t++)if(n.rtcpFeedback[t].type===e.type&&n.rtcpFeedback[t].parameter===e.parameter)return!0;return!1});break}}}),e.headerExtensions.forEach(function(e){for(var n=0;n<t.headerExtensions.length;n++){var a=t.headerExtensions[n];if(e.uri===a.uri){r.headerExtensions.push(a);break}}}),r}function i(e,t,r){return-1!=={offer:{setLocalDescription:[\"stable\",\"have-local-offer\"],setRemoteDescription:[\"stable\",\"have-remote-offer\"]},answer:{setLocalDescription:[\"have-remote-offer\",\"have-local-pranswer\"],setRemoteDescription:[\"have-local-offer\",\"have-remote-pranswer\"]}}[t][e].indexOf(r)}function s(e,t){var r=e.getRemoteCandidates().find(function(e){return t.foundation===e.foundation&&t.ip===e.ip&&t.port===e.port&&t.priority===e.priority&&t.protocol===e.protocol&&t.type===e.type});return r||e.addRemoteCandidate(t),!r}function o(e,t){var r=new Error(t);return r.name=e,r.code={NotSupportedError:9,InvalidStateError:11,InvalidAccessError:15,TypeError:void 0,OperationError:void 0}[e],r}module.exports=function(c,d){function p(e,t){t.addTrack(e),t.dispatchEvent(new c.MediaStreamTrackEvent(\"addtrack\",{track:e}))}function l(e,t,r,n){var a=new Event(\"track\");a.track=t,a.receiver=r,a.transceiver={receiver:r},a.streams=n,c.setTimeout(function(){e._dispatchEvent(\"track\",a)})}var f=function(t){var r=this,a=document.createDocumentFragment();if([\"addEventListener\",\"removeEventListener\",\"dispatchEvent\"].forEach(function(e){r[e]=a[e].bind(a)}),this.canTrickleIceCandidates=null,this.needNegotiation=!1,this.localStreams=[],this.remoteStreams=[],this._localDescription=null,this._remoteDescription=null,this.signalingState=\"stable\",this.iceConnectionState=\"new\",this.connectionState=\"new\",this.iceGatheringState=\"new\",t=JSON.parse(JSON.stringify(t||{})),this.usingBundle=\"max-bundle\"===t.bundlePolicy,\"negotiate\"===t.rtcpMuxPolicy)throw o(\"NotSupportedError\",\"rtcpMuxPolicy 'negotiate' is not supported\");switch(t.rtcpMuxPolicy||(t.rtcpMuxPolicy=\"require\"),t.iceTransportPolicy){case\"all\":case\"relay\":break;default:t.iceTransportPolicy=\"all\"}switch(t.bundlePolicy){case\"balanced\":case\"max-compat\":case\"max-bundle\":break;default:t.bundlePolicy=\"balanced\"}if(t.iceServers=n(t.iceServers||[],d),this._iceGatherers=[],t.iceCandidatePoolSize)for(var i=t.iceCandidatePoolSize;i>0;i--)this._iceGatherers.push(new c.RTCIceGatherer({iceServers:t.iceServers,gatherPolicy:t.iceTransportPolicy}));else t.iceCandidatePoolSize=0;this._config=t,this.transceivers=[],this._sdpSessionId=e.generateSessionId(),this._sdpSessionVersion=0,this._dtlsRole=void 0,this._isClosed=!1};Object.defineProperty(f.prototype,\"localDescription\",{configurable:!0,get:function(){return this._localDescription}}),Object.defineProperty(f.prototype,\"remoteDescription\",{configurable:!0,get:function(){return this._remoteDescription}}),f.prototype.onicecandidate=null,f.prototype.onaddstream=null,f.prototype.ontrack=null,f.prototype.onremovestream=null,f.prototype.onsignalingstatechange=null,f.prototype.oniceconnectionstatechange=null,f.prototype.onconnectionstatechange=null,f.prototype.onicegatheringstatechange=null,f.prototype.onnegotiationneeded=null,f.prototype.ondatachannel=null,f.prototype._dispatchEvent=function(e,t){this._isClosed||(this.dispatchEvent(t),\"function\"==typeof this[\"on\"+e]&&this[\"on\"+e](t))},f.prototype._emitGatheringStateChange=function(){var e=new Event(\"icegatheringstatechange\");this._dispatchEvent(\"icegatheringstatechange\",e)},f.prototype.getConfiguration=function(){return this._config},f.prototype.getLocalStreams=function(){return this.localStreams},f.prototype.getRemoteStreams=function(){return this.remoteStreams},f.prototype._createTransceiver=function(e,t){var r=this.transceivers.length>0,n={track:null,iceGatherer:null,iceTransport:null,dtlsTransport:null,localCapabilities:null,remoteCapabilities:null,rtpSender:null,rtpReceiver:null,kind:e,mid:null,sendEncodingParameters:null,recvEncodingParameters:null,stream:null,associatedRemoteMediaStreams:[],wantReceive:!0};if(this.usingBundle&&r)n.iceTransport=this.transceivers[0].iceTransport,n.dtlsTransport=this.transceivers[0].dtlsTransport;else{var a=this._createIceAndDtlsTransports();n.iceTransport=a.iceTransport,n.dtlsTransport=a.dtlsTransport}return t||this.transceivers.push(n),n},f.prototype.addTrack=function(e,t){if(this._isClosed)throw o(\"InvalidStateError\",\"Attempted to call addTrack on a closed peerconnection.\");var r;if(this.transceivers.find(function(t){return t.track===e}))throw o(\"InvalidAccessError\",\"Track already exists.\");for(var n=0;n<this.transceivers.length;n++)this.transceivers[n].track||this.transceivers[n].kind!==e.kind||(r=this.transceivers[n]);return r||(r=this._createTransceiver(e.kind)),this._maybeFireNegotiationNeeded(),-1===this.localStreams.indexOf(t)&&this.localStreams.push(t),r.track=e,r.stream=t,r.rtpSender=new c.RTCRtpSender(e,r.dtlsTransport),r.rtpSender},f.prototype.addStream=function(e){var t=this;if(d>=15025)e.getTracks().forEach(function(r){t.addTrack(r,e)});else{var r=e.clone();e.getTracks().forEach(function(e,t){var n=r.getTracks()[t];e.addEventListener(\"enabled\",function(e){n.enabled=e.enabled})}),r.getTracks().forEach(function(e){t.addTrack(e,r)})}},f.prototype.removeTrack=function(e){if(this._isClosed)throw o(\"InvalidStateError\",\"Attempted to call removeTrack on a closed peerconnection.\");if(!(e instanceof c.RTCRtpSender))throw new TypeError(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\");var t=this.transceivers.find(function(t){return t.rtpSender===e});if(!t)throw o(\"InvalidAccessError\",\"Sender was not created by this connection.\");var r=t.stream;t.rtpSender.stop(),t.rtpSender=null,t.track=null,t.stream=null,-1===this.transceivers.map(function(e){return e.stream}).indexOf(r)&&this.localStreams.indexOf(r)>-1&&this.localStreams.splice(this.localStreams.indexOf(r),1),this._maybeFireNegotiationNeeded()},f.prototype.removeStream=function(e){var t=this;e.getTracks().forEach(function(e){var r=t.getSenders().find(function(t){return t.track===e});r&&t.removeTrack(r)})},f.prototype.getSenders=function(){return this.transceivers.filter(function(e){return!!e.rtpSender}).map(function(e){return e.rtpSender})},f.prototype.getReceivers=function(){return this.transceivers.filter(function(e){return!!e.rtpReceiver}).map(function(e){return e.rtpReceiver})},f.prototype._createIceGatherer=function(e,t){var r=this;if(t&&e>0)return this.transceivers[0].iceGatherer;if(this._iceGatherers.length)return this._iceGatherers.shift();var n=new c.RTCIceGatherer({iceServers:this._config.iceServers,gatherPolicy:this._config.iceTransportPolicy});return Object.defineProperty(n,\"state\",{value:\"new\",writable:!0}),this.transceivers[e].bufferedCandidateEvents=[],this.transceivers[e].bufferCandidates=function(t){var a=!t.candidate||0===Object.keys(t.candidate).length;n.state=a?\"completed\":\"gathering\",null!==r.transceivers[e].bufferedCandidateEvents&&r.transceivers[e].bufferedCandidateEvents.push(t)},n.addEventListener(\"localcandidate\",this.transceivers[e].bufferCandidates),n},f.prototype._gather=function(t,r){var n=this,a=this.transceivers[r].iceGatherer;if(!a.onlocalcandidate){var i=this.transceivers[r].bufferedCandidateEvents;this.transceivers[r].bufferedCandidateEvents=null,a.removeEventListener(\"localcandidate\",this.transceivers[r].bufferCandidates),a.onlocalcandidate=function(i){if(!(n.usingBundle&&r>0)){var s=new Event(\"icecandidate\");s.candidate={sdpMid:t,sdpMLineIndex:r};var o=i.candidate,c=!o||0===Object.keys(o).length;if(c)\"new\"!==a.state&&\"gathering\"!==a.state||(a.state=\"completed\");else{\"new\"===a.state&&(a.state=\"gathering\"),o.component=1,o.ufrag=a.getLocalParameters().usernameFragment;var d=e.writeCandidate(o);s.candidate=Object.assign(s.candidate,e.parseCandidate(d)),s.candidate.candidate=d,s.candidate.toJSON=function(){return{candidate:s.candidate.candidate,sdpMid:s.candidate.sdpMid,sdpMLineIndex:s.candidate.sdpMLineIndex,usernameFragment:s.candidate.usernameFragment}}}var p=e.getMediaSections(n._localDescription.sdp);p[s.candidate.sdpMLineIndex]+=c?\"a=end-of-candidates\\r\\n\":\"a=\"+s.candidate.candidate+\"\\r\\n\",n._localDescription.sdp=e.getDescription(n._localDescription.sdp)+p.join(\"\");var l=n.transceivers.every(function(e){return e.iceGatherer&&\"completed\"===e.iceGatherer.state});\"gathering\"!==n.iceGatheringState&&(n.iceGatheringState=\"gathering\",n._emitGatheringStateChange()),c||n._dispatchEvent(\"icecandidate\",s),l&&(n._dispatchEvent(\"icecandidate\",new Event(\"icecandidate\")),n.iceGatheringState=\"complete\",n._emitGatheringStateChange())}},c.setTimeout(function(){i.forEach(function(e){a.onlocalcandidate(e)})},0)}},f.prototype._createIceAndDtlsTransports=function(){var e=this,t=new c.RTCIceTransport(null);t.onicestatechange=function(){e._updateIceConnectionState(),e._updateConnectionState()};var r=new c.RTCDtlsTransport(t);return r.ondtlsstatechange=function(){e._updateConnectionState()},r.onerror=function(){Object.defineProperty(r,\"state\",{value:\"failed\",writable:!0}),e._updateConnectionState()},{iceTransport:t,dtlsTransport:r}},f.prototype._disposeIceAndDtlsTransports=function(e){var t=this.transceivers[e].iceGatherer;t&&(delete t.onlocalcandidate,delete this.transceivers[e].iceGatherer);var r=this.transceivers[e].iceTransport;r&&(delete r.onicestatechange,delete this.transceivers[e].iceTransport);var n=this.transceivers[e].dtlsTransport;n&&(delete n.ondtlsstatechange,delete n.onerror,delete this.transceivers[e].dtlsTransport)},f.prototype._transceive=function(t,r,n){var i=a(t.localCapabilities,t.remoteCapabilities);r&&t.rtpSender&&(i.encodings=t.sendEncodingParameters,i.rtcp={cname:e.localCName,compound:t.rtcpParameters.compound},t.recvEncodingParameters.length&&(i.rtcp.ssrc=t.recvEncodingParameters[0].ssrc),t.rtpSender.send(i)),n&&t.rtpReceiver&&i.codecs.length>0&&(\"video\"===t.kind&&t.recvEncodingParameters&&d<15019&&t.recvEncodingParameters.forEach(function(e){delete e.rtx}),t.recvEncodingParameters.length?i.encodings=t.recvEncodingParameters:i.encodings=[{}],i.rtcp={compound:t.rtcpParameters.compound},t.rtcpParameters.cname&&(i.rtcp.cname=t.rtcpParameters.cname),t.sendEncodingParameters.length&&(i.rtcp.ssrc=t.sendEncodingParameters[0].ssrc),t.rtpReceiver.receive(i))},f.prototype.setLocalDescription=function(t){var r,n,s=this;if(-1===[\"offer\",\"answer\"].indexOf(t.type))return Promise.reject(o(\"TypeError\",'Unsupported type \"'+t.type+'\"'));if(!i(\"setLocalDescription\",t.type,s.signalingState)||s._isClosed)return Promise.reject(o(\"InvalidStateError\",\"Can not set local \"+t.type+\" in state \"+s.signalingState));if(\"offer\"===t.type)r=e.splitSections(t.sdp),n=r.shift(),r.forEach(function(t,r){var n=e.parseRtpParameters(t);s.transceivers[r].localCapabilities=n}),s.transceivers.forEach(function(e,t){s._gather(e.mid,t)});else if(\"answer\"===t.type){r=e.splitSections(s._remoteDescription.sdp),n=r.shift();var c=e.matchPrefix(n,\"a=ice-lite\").length>0;r.forEach(function(t,r){var i=s.transceivers[r],o=i.iceGatherer,d=i.iceTransport,p=i.dtlsTransport,l=i.localCapabilities,f=i.remoteCapabilities;if(!(e.isRejected(t)&&0===e.matchPrefix(t,\"a=bundle-only\").length)&&!i.rejected){var u=e.getIceParameters(t,n),v=e.getDtlsParameters(t,n);c&&(v.role=\"server\"),s.usingBundle&&0!==r||(s._gather(i.mid,r),\"new\"===d.state&&d.start(o,u,c?\"controlling\":\"controlled\"),\"new\"===p.state&&p.start(v));var h=a(l,f);s._transceive(i,h.codecs.length>0,!1)}})}return s._localDescription={type:t.type,sdp:t.sdp},\"offer\"===t.type?s._updateSignalingState(\"have-local-offer\"):s._updateSignalingState(\"stable\"),Promise.resolve()},f.prototype.setRemoteDescription=function(t){var r=this;if(-1===[\"offer\",\"answer\"].indexOf(t.type))return Promise.reject(o(\"TypeError\",'Unsupported type \"'+t.type+'\"'));if(!i(\"setRemoteDescription\",t.type,r.signalingState)||r._isClosed)return Promise.reject(o(\"InvalidStateError\",\"Can not set remote \"+t.type+\" in state \"+r.signalingState));var n={};r.remoteStreams.forEach(function(e){n[e.id]=e});var f=[],u=e.splitSections(t.sdp),v=u.shift(),h=e.matchPrefix(v,\"a=ice-lite\").length>0,m=e.matchPrefix(v,\"a=group:BUNDLE \").length>0;r.usingBundle=m;var g=e.matchPrefix(v,\"a=ice-options:\")[0];return r.canTrickleIceCandidates=!!g&&g.substr(14).split(\" \").indexOf(\"trickle\")>=0,u.forEach(function(i,o){var l=e.splitLines(i),u=e.getKind(i),g=e.isRejected(i)&&0===e.matchPrefix(i,\"a=bundle-only\").length,y=l[0].substr(2).split(\" \")[2],S=e.getDirection(i,v),T=e.parseMsid(i),E=e.getMid(i)||e.generateIdentifier();if(g||\"application\"===u&&(\"DTLS/SCTP\"===y||\"UDP/DTLS/SCTP\"===y))r.transceivers[o]={mid:E,kind:u,protocol:y,rejected:!0};else{var C,P,w,R,_,k,b,x,D;!g&&r.transceivers[o]&&r.transceivers[o].rejected&&(r.transceivers[o]=r._createTransceiver(u,!0));var I,L,M=e.parseRtpParameters(i);g||(I=e.getIceParameters(i,v),(L=e.getDtlsParameters(i,v)).role=\"client\"),b=e.parseRtpEncodingParameters(i);var O=e.parseRtcpParameters(i),G=e.matchPrefix(i,\"a=end-of-candidates\",v).length>0,j=e.matchPrefix(i,\"a=candidate:\").map(function(t){return e.parseCandidate(t)}).filter(function(e){return 1===e.component});if((\"offer\"===t.type||\"answer\"===t.type)&&!g&&m&&o>0&&r.transceivers[o]&&(r._disposeIceAndDtlsTransports(o),r.transceivers[o].iceGatherer=r.transceivers[0].iceGatherer,r.transceivers[o].iceTransport=r.transceivers[0].iceTransport,r.transceivers[o].dtlsTransport=r.transceivers[0].dtlsTransport,r.transceivers[o].rtpSender&&r.transceivers[o].rtpSender.setTransport(r.transceivers[0].dtlsTransport),r.transceivers[o].rtpReceiver&&r.transceivers[o].rtpReceiver.setTransport(r.transceivers[0].dtlsTransport)),\"offer\"!==t.type||g){if(\"answer\"===t.type&&!g){P=(C=r.transceivers[o]).iceGatherer,w=C.iceTransport,R=C.dtlsTransport,_=C.rtpReceiver,k=C.sendEncodingParameters,x=C.localCapabilities,r.transceivers[o].recvEncodingParameters=b,r.transceivers[o].remoteCapabilities=M,r.transceivers[o].rtcpParameters=O,j.length&&\"new\"===w.state&&(!h&&!G||m&&0!==o?j.forEach(function(e){s(C.iceTransport,e)}):w.setRemoteCandidates(j)),m&&0!==o||(\"new\"===w.state&&w.start(P,I,\"controlling\"),\"new\"===R.state&&R.start(L)),!a(C.localCapabilities,C.remoteCapabilities).codecs.filter(function(e){return\"rtx\"===e.name.toLowerCase()}).length&&C.sendEncodingParameters[0].rtx&&delete C.sendEncodingParameters[0].rtx,r._transceive(C,\"sendrecv\"===S||\"recvonly\"===S,\"sendrecv\"===S||\"sendonly\"===S),!_||\"sendrecv\"!==S&&\"sendonly\"!==S?delete C.rtpReceiver:(D=_.track,T?(n[T.stream]||(n[T.stream]=new c.MediaStream),p(D,n[T.stream]),f.push([D,_,n[T.stream]])):(n.default||(n.default=new c.MediaStream),p(D,n.default),f.push([D,_,n.default])))}}else{(C=r.transceivers[o]||r._createTransceiver(u)).mid=E,C.iceGatherer||(C.iceGatherer=r._createIceGatherer(o,m)),j.length&&\"new\"===C.iceTransport.state&&(!G||m&&0!==o?j.forEach(function(e){s(C.iceTransport,e)}):C.iceTransport.setRemoteCandidates(j)),x=c.RTCRtpReceiver.getCapabilities(u),d<15019&&(x.codecs=x.codecs.filter(function(e){return\"rtx\"!==e.name})),k=C.sendEncodingParameters||[{ssrc:1001*(2*o+2)}];var N,A=!1;if(\"sendrecv\"===S||\"sendonly\"===S){if(A=!C.rtpReceiver,_=C.rtpReceiver||new c.RTCRtpReceiver(C.dtlsTransport,u),A)D=_.track,T&&\"-\"===T.stream||(T?(n[T.stream]||(n[T.stream]=new c.MediaStream,Object.defineProperty(n[T.stream],\"id\",{get:function(){return T.stream}})),Object.defineProperty(D,\"id\",{get:function(){return T.track}}),N=n[T.stream]):(n.default||(n.default=new c.MediaStream),N=n.default)),N&&(p(D,N),C.associatedRemoteMediaStreams.push(N)),f.push([D,_,N])}else C.rtpReceiver&&C.rtpReceiver.track&&(C.associatedRemoteMediaStreams.forEach(function(e){var t,r,n=e.getTracks().find(function(e){return e.id===C.rtpReceiver.track.id});n&&(t=n,(r=e).removeTrack(t),r.dispatchEvent(new c.MediaStreamTrackEvent(\"removetrack\",{track:t})))}),C.associatedRemoteMediaStreams=[]);C.localCapabilities=x,C.remoteCapabilities=M,C.rtpReceiver=_,C.rtcpParameters=O,C.sendEncodingParameters=k,C.recvEncodingParameters=b,r._transceive(r.transceivers[o],!1,A)}}}),void 0===r._dtlsRole&&(r._dtlsRole=\"offer\"===t.type?\"active\":\"passive\"),r._remoteDescription={type:t.type,sdp:t.sdp},\"offer\"===t.type?r._updateSignalingState(\"have-remote-offer\"):r._updateSignalingState(\"stable\"),Object.keys(n).forEach(function(e){var t=n[e];if(t.getTracks().length){if(-1===r.remoteStreams.indexOf(t)){r.remoteStreams.push(t);var a=new Event(\"addstream\");a.stream=t,c.setTimeout(function(){r._dispatchEvent(\"addstream\",a)})}f.forEach(function(e){var n=e[0],a=e[1];t.id===e[2].id&&l(r,n,a,[t])})}}),f.forEach(function(e){e[2]||l(r,e[0],e[1],[])}),c.setTimeout(function(){r&&r.transceivers&&r.transceivers.forEach(function(e){e.iceTransport&&\"new\"===e.iceTransport.state&&e.iceTransport.getRemoteCandidates().length>0&&(console.warn(\"Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification\"),e.iceTransport.addRemoteCandidate({}))})},4e3),Promise.resolve()},f.prototype.close=function(){this.transceivers.forEach(function(e){e.iceTransport&&e.iceTransport.stop(),e.dtlsTransport&&e.dtlsTransport.stop(),e.rtpSender&&e.rtpSender.stop(),e.rtpReceiver&&e.rtpReceiver.stop()}),this._isClosed=!0,this._updateSignalingState(\"closed\")},f.prototype._updateSignalingState=function(e){this.signalingState=e;var t=new Event(\"signalingstatechange\");this._dispatchEvent(\"signalingstatechange\",t)},f.prototype._maybeFireNegotiationNeeded=function(){var e=this;\"stable\"===this.signalingState&&!0!==this.needNegotiation&&(this.needNegotiation=!0,c.setTimeout(function(){if(e.needNegotiation){e.needNegotiation=!1;var t=new Event(\"negotiationneeded\");e._dispatchEvent(\"negotiationneeded\",t)}},0))},f.prototype._updateIceConnectionState=function(){var e,t={new:0,closed:0,checking:0,connected:0,completed:0,disconnected:0,failed:0};if(this.transceivers.forEach(function(e){e.iceTransport&&!e.rejected&&t[e.iceTransport.state]++}),e=\"new\",t.failed>0?e=\"failed\":t.checking>0?e=\"checking\":t.disconnected>0?e=\"disconnected\":t.new>0?e=\"new\":t.connected>0?e=\"connected\":t.completed>0&&(e=\"completed\"),e!==this.iceConnectionState){this.iceConnectionState=e;var r=new Event(\"iceconnectionstatechange\");this._dispatchEvent(\"iceconnectionstatechange\",r)}},f.prototype._updateConnectionState=function(){var e,t={new:0,closed:0,connecting:0,connected:0,completed:0,disconnected:0,failed:0};if(this.transceivers.forEach(function(e){e.iceTransport&&e.dtlsTransport&&!e.rejected&&(t[e.iceTransport.state]++,t[e.dtlsTransport.state]++)}),t.connected+=t.completed,e=\"new\",t.failed>0?e=\"failed\":t.connecting>0?e=\"connecting\":t.disconnected>0?e=\"disconnected\":t.new>0?e=\"new\":t.connected>0&&(e=\"connected\"),e!==this.connectionState){this.connectionState=e;var r=new Event(\"connectionstatechange\");this._dispatchEvent(\"connectionstatechange\",r)}},f.prototype.createOffer=function(){var t=this;if(t._isClosed)return Promise.reject(o(\"InvalidStateError\",\"Can not call createOffer after close\"));var n=t.transceivers.filter(function(e){return\"audio\"===e.kind}).length,a=t.transceivers.filter(function(e){return\"video\"===e.kind}).length,i=arguments[0];if(i){if(i.mandatory||i.optional)throw new TypeError(\"Legacy mandatory/optional constraints not supported.\");void 0!==i.offerToReceiveAudio&&(n=!0===i.offerToReceiveAudio?1:!1===i.offerToReceiveAudio?0:i.offerToReceiveAudio),void 0!==i.offerToReceiveVideo&&(a=!0===i.offerToReceiveVideo?1:!1===i.offerToReceiveVideo?0:i.offerToReceiveVideo)}for(t.transceivers.forEach(function(e){\"audio\"===e.kind?--n<0&&(e.wantReceive=!1):\"video\"===e.kind&&--a<0&&(e.wantReceive=!1)});n>0||a>0;)n>0&&(t._createTransceiver(\"audio\"),n--),a>0&&(t._createTransceiver(\"video\"),a--);var s=e.writeSessionBoilerplate(t._sdpSessionId,t._sdpSessionVersion++);t.transceivers.forEach(function(r,n){var a=r.track,i=r.kind,s=r.mid||e.generateIdentifier();r.mid=s,r.iceGatherer||(r.iceGatherer=t._createIceGatherer(n,t.usingBundle));var o=c.RTCRtpSender.getCapabilities(i);d<15019&&(o.codecs=o.codecs.filter(function(e){return\"rtx\"!==e.name})),o.codecs.forEach(function(e){\"H264\"===e.name&&void 0===e.parameters[\"level-asymmetry-allowed\"]&&(e.parameters[\"level-asymmetry-allowed\"]=\"1\"),r.remoteCapabilities&&r.remoteCapabilities.codecs&&r.remoteCapabilities.codecs.forEach(function(t){e.name.toLowerCase()===t.name.toLowerCase()&&e.clockRate===t.clockRate&&(e.preferredPayloadType=t.payloadType)})}),o.headerExtensions.forEach(function(e){(r.remoteCapabilities&&r.remoteCapabilities.headerExtensions||[]).forEach(function(t){e.uri===t.uri&&(e.id=t.id)})});var p=r.sendEncodingParameters||[{ssrc:1001*(2*n+1)}];a&&d>=15019&&\"video\"===i&&!p[0].rtx&&(p[0].rtx={ssrc:p[0].ssrc+1}),r.wantReceive&&(r.rtpReceiver=new c.RTCRtpReceiver(r.dtlsTransport,i)),r.localCapabilities=o,r.sendEncodingParameters=p}),\"max-compat\"!==t._config.bundlePolicy&&(s+=\"a=group:BUNDLE \"+t.transceivers.map(function(e){return e.mid}).join(\" \")+\"\\r\\n\"),s+=\"a=ice-options:trickle\\r\\n\",t.transceivers.forEach(function(n,a){s+=r(n,n.localCapabilities,\"offer\",n.stream,t._dtlsRole),s+=\"a=rtcp-rsize\\r\\n\",!n.iceGatherer||\"new\"===t.iceGatheringState||0!==a&&t.usingBundle||(n.iceGatherer.getLocalCandidates().forEach(function(t){t.component=1,s+=\"a=\"+e.writeCandidate(t)+\"\\r\\n\"}),\"completed\"===n.iceGatherer.state&&(s+=\"a=end-of-candidates\\r\\n\"))});var p=new c.RTCSessionDescription({type:\"offer\",sdp:s});return Promise.resolve(p)},f.prototype.createAnswer=function(){var t=this;if(t._isClosed)return Promise.reject(o(\"InvalidStateError\",\"Can not call createAnswer after close\"));if(\"have-remote-offer\"!==t.signalingState&&\"have-local-pranswer\"!==t.signalingState)return Promise.reject(o(\"InvalidStateError\",\"Can not call createAnswer in signalingState \"+t.signalingState));var n=e.writeSessionBoilerplate(t._sdpSessionId,t._sdpSessionVersion++);t.usingBundle&&(n+=\"a=group:BUNDLE \"+t.transceivers.map(function(e){return e.mid}).join(\" \")+\"\\r\\n\"),n+=\"a=ice-options:trickle\\r\\n\";var i=e.getMediaSections(t._remoteDescription.sdp).length;t.transceivers.forEach(function(e,s){if(!(s+1>i)){if(e.rejected)return\"application\"===e.kind?\"DTLS/SCTP\"===e.protocol?n+=\"m=application 0 DTLS/SCTP 5000\\r\\n\":n+=\"m=application 0 \"+e.protocol+\" webrtc-datachannel\\r\\n\":\"audio\"===e.kind?n+=\"m=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\na=rtpmap:0 PCMU/8000\\r\\n\":\"video\"===e.kind&&(n+=\"m=video 0 UDP/TLS/RTP/SAVPF 120\\r\\na=rtpmap:120 VP8/90000\\r\\n\"),void(n+=\"c=IN IP4 0.0.0.0\\r\\na=inactive\\r\\na=mid:\"+e.mid+\"\\r\\n\");var o;if(e.stream)\"audio\"===e.kind?o=e.stream.getAudioTracks()[0]:\"video\"===e.kind&&(o=e.stream.getVideoTracks()[0]),o&&d>=15019&&\"video\"===e.kind&&!e.sendEncodingParameters[0].rtx&&(e.sendEncodingParameters[0].rtx={ssrc:e.sendEncodingParameters[0].ssrc+1});var c=a(e.localCapabilities,e.remoteCapabilities);!c.codecs.filter(function(e){return\"rtx\"===e.name.toLowerCase()}).length&&e.sendEncodingParameters[0].rtx&&delete e.sendEncodingParameters[0].rtx,n+=r(e,c,\"answer\",e.stream,t._dtlsRole),e.rtcpParameters&&e.rtcpParameters.reducedSize&&(n+=\"a=rtcp-rsize\\r\\n\")}});var s=new c.RTCSessionDescription({type:\"answer\",sdp:n});return Promise.resolve(s)},f.prototype.addIceCandidate=function(t){var r,n=this;return t&&void 0===t.sdpMLineIndex&&!t.sdpMid?Promise.reject(new TypeError(\"sdpMLineIndex or sdpMid required\")):new Promise(function(a,i){if(!n._remoteDescription)return i(o(\"InvalidStateError\",\"Can not add ICE candidate without a remote description\"));if(t&&\"\"!==t.candidate){var c=t.sdpMLineIndex;if(t.sdpMid)for(var d=0;d<n.transceivers.length;d++)if(n.transceivers[d].mid===t.sdpMid){c=d;break}var p=n.transceivers[c];if(!p)return i(o(\"OperationError\",\"Can not add ICE candidate\"));if(p.rejected)return a();var l=Object.keys(t.candidate).length>0?e.parseCandidate(t.candidate):{};if(\"tcp\"===l.protocol&&(0===l.port||9===l.port))return a();if(l.component&&1!==l.component)return a();if((0===c||c>0&&p.iceTransport!==n.transceivers[0].iceTransport)&&!s(p.iceTransport,l))return i(o(\"OperationError\",\"Can not add ICE candidate\"));var f=t.candidate.trim();0===f.indexOf(\"a=\")&&(f=f.substr(2)),(r=e.getMediaSections(n._remoteDescription.sdp))[c]+=\"a=\"+(l.type?f:\"end-of-candidates\")+\"\\r\\n\",n._remoteDescription.sdp=e.getDescription(n._remoteDescription.sdp)+r.join(\"\")}else for(var u=0;u<n.transceivers.length&&(n.transceivers[u].rejected||(n.transceivers[u].iceTransport.addRemoteCandidate({}),(r=e.getMediaSections(n._remoteDescription.sdp))[u]+=\"a=end-of-candidates\\r\\n\",n._remoteDescription.sdp=e.getDescription(n._remoteDescription.sdp)+r.join(\"\"),!n.usingBundle));u++);a()})},f.prototype.getStats=function(e){if(e&&e instanceof c.MediaStreamTrack){var t=null;if(this.transceivers.forEach(function(r){r.rtpSender&&r.rtpSender.track===e?t=r.rtpSender:r.rtpReceiver&&r.rtpReceiver.track===e&&(t=r.rtpReceiver)}),!t)throw o(\"InvalidAccessError\",\"Invalid selector.\");return t.getStats()}var r=[];return this.transceivers.forEach(function(e){[\"rtpSender\",\"rtpReceiver\",\"iceGatherer\",\"iceTransport\",\"dtlsTransport\"].forEach(function(t){e[t]&&r.push(e[t].getStats())})}),Promise.all(r).then(function(e){var t=new Map;return e.forEach(function(e){e.forEach(function(e){t.set(e.id,e)})}),t})};[\"RTCRtpSender\",\"RTCRtpReceiver\",\"RTCIceGatherer\",\"RTCIceTransport\",\"RTCDtlsTransport\"].forEach(function(e){var r=c[e];if(r&&r.prototype&&r.prototype.getStats){var n=r.prototype.getStats;r.prototype.getStats=function(){return n.apply(this).then(function(e){var r=new Map;return Object.keys(e).forEach(function(n){e[n].type=t(e[n]),r.set(n,e[n])}),r})}}});var u=[\"createOffer\",\"createAnswer\"];return u.forEach(function(e){var t=f.prototype[e];f.prototype[e]=function(){var e=arguments;return\"function\"==typeof e[0]||\"function\"==typeof e[1]?t.apply(this,[arguments[2]]).then(function(t){\"function\"==typeof e[0]&&e[0].apply(null,[t])},function(t){\"function\"==typeof e[1]&&e[1].apply(null,[t])}):t.apply(this,arguments)}}),(u=[\"setLocalDescription\",\"setRemoteDescription\",\"addIceCandidate\"]).forEach(function(e){var t=f.prototype[e];f.prototype[e]=function(){var e=arguments;return\"function\"==typeof e[1]||\"function\"==typeof e[2]?t.apply(this,arguments).then(function(){\"function\"==typeof e[1]&&e[1].apply(null)},function(t){\"function\"==typeof e[2]&&e[2].apply(null,[t])}):t.apply(this,arguments)}}),[\"getStats\"].forEach(function(e){var t=f.prototype[e];f.prototype[e]=function(){var e=arguments;return\"function\"==typeof e[1]?t.apply(this,arguments).then(function(){\"function\"==typeof e[1]&&e[1].apply(null)}):t.apply(this,arguments)}}),f};\n},{\"sdp\":\"YHvh\"}],\"YdKx\":[function(require,module,exports) {\n\"use strict\";function e(e){var r=e&&e.navigator,t=r.mediaDevices.getUserMedia.bind(r.mediaDevices);r.mediaDevices.getUserMedia=function(e){return t(e).catch(function(e){return Promise.reject(function(e){return{name:{PermissionDeniedError:\"NotAllowedError\"}[e.name]||e.name,message:e.message,constraint:e.constraint,toString:function(){return this.name}}}(e))})}}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetUserMedia=e;\n},{}],\"P3bV\":[function(require,module,exports) {\n\"use strict\";function e(e){\"getDisplayMedia\"in e.navigator&&e.navigator.mediaDevices&&(e.navigator.mediaDevices&&\"getDisplayMedia\"in e.navigator.mediaDevices||(e.navigator.mediaDevices.getDisplayMedia=e.navigator.getDisplayMedia.bind(e.navigator)))}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetDisplayMedia=e;\n},{}],\"XRic\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimPeerConnection=p,exports.shimReplaceTrack=a,Object.defineProperty(exports,\"shimGetUserMedia\",{enumerable:!0,get:function(){return n.shimGetUserMedia}}),Object.defineProperty(exports,\"shimGetDisplayMedia\",{enumerable:!0,get:function(){return i.shimGetDisplayMedia}});var e=s(require(\"../utils\")),t=require(\"./filtericeservers\"),r=o(require(\"rtcpeerconnection-shim\")),n=require(\"./getusermedia\"),i=require(\"./getdisplaymedia\");function o(e){return e&&e.__esModule?e:{default:e}}function c(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return c=function(){return e},e}function s(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=c();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(r,i,o):r[i]=e[i]}return r.default=e,t&&t.set(e,r),r}function p(n,i){if(n.RTCIceGatherer&&(n.RTCIceCandidate||(n.RTCIceCandidate=function(e){return e}),n.RTCSessionDescription||(n.RTCSessionDescription=function(e){return e}),i.version<15025)){var o=Object.getOwnPropertyDescriptor(n.MediaStreamTrack.prototype,\"enabled\");Object.defineProperty(n.MediaStreamTrack.prototype,\"enabled\",{set:function(e){o.set.call(this,e);var t=new Event(\"enabled\");t.enabled=e,this.dispatchEvent(t)}})}!n.RTCRtpSender||\"dtmf\"in n.RTCRtpSender.prototype||Object.defineProperty(n.RTCRtpSender.prototype,\"dtmf\",{get:function(){return void 0===this._dtmf&&(\"audio\"===this.track.kind?this._dtmf=new n.RTCDtmfSender(this):\"video\"===this.track.kind&&(this._dtmf=null)),this._dtmf}}),n.RTCDtmfSender&&!n.RTCDTMFSender&&(n.RTCDTMFSender=n.RTCDtmfSender);var c=(0,r.default)(n,i.version);n.RTCPeerConnection=function(r){return r&&r.iceServers&&(r.iceServers=(0,t.filterIceServers)(r.iceServers,i.version),e.log(\"ICE servers after filtering:\",r.iceServers)),new c(r)},n.RTCPeerConnection.prototype=c.prototype}function a(e){!e.RTCRtpSender||\"replaceTrack\"in e.RTCRtpSender.prototype||(e.RTCRtpSender.prototype.replaceTrack=e.RTCRtpSender.prototype.setTrack)}\n},{\"../utils\":\"iSxC\",\"./filtericeservers\":\"NZ1C\",\"rtcpeerconnection-shim\":\"NJ2u\",\"./getusermedia\":\"YdKx\",\"./getdisplaymedia\":\"P3bV\"}],\"GzSv\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetUserMedia=n;var e=o(require(\"../utils\"));function t(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return t=function(){return e},e}function o(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var o=t();if(o&&o.has(e))return o.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=n?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(r,i,a):r[i]=e[i]}return r.default=e,o&&o.set(e,r),r}function r(e){return(r=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function n(t,o){var n=t&&t.navigator,i=t&&t.MediaStreamTrack;if(n.getUserMedia=function(t,o,r){e.deprecated(\"navigator.getUserMedia\",\"navigator.mediaDevices.getUserMedia\"),n.mediaDevices.getUserMedia(t).then(o,r)},!(o.version>55&&\"autoGainControl\"in n.mediaDevices.getSupportedConstraints())){var a=function(e,t,o){t in e&&!(o in e)&&(e[o]=e[t],delete e[t])},s=n.mediaDevices.getUserMedia.bind(n.mediaDevices);if(n.mediaDevices.getUserMedia=function(e){return\"object\"===r(e)&&\"object\"===r(e.audio)&&(e=JSON.parse(JSON.stringify(e)),a(e.audio,\"autoGainControl\",\"mozAutoGainControl\"),a(e.audio,\"noiseSuppression\",\"mozNoiseSuppression\")),s(e)},i&&i.prototype.getSettings){var p=i.prototype.getSettings;i.prototype.getSettings=function(){var e=p.apply(this,arguments);return a(e,\"mozAutoGainControl\",\"autoGainControl\"),a(e,\"mozNoiseSuppression\",\"noiseSuppression\"),e}}if(i&&i.prototype.applyConstraints){var u=i.prototype.applyConstraints;i.prototype.applyConstraints=function(e){return\"audio\"===this.kind&&\"object\"===r(e)&&(e=JSON.parse(JSON.stringify(e)),a(e,\"autoGainControl\",\"mozAutoGainControl\"),a(e,\"noiseSuppression\",\"mozNoiseSuppression\")),u.apply(this,[e])}}}}\n},{\"../utils\":\"iSxC\"}],\"UuGU\":[function(require,module,exports) {\n\"use strict\";function e(e,i){e.navigator.mediaDevices&&\"getDisplayMedia\"in e.navigator.mediaDevices||e.navigator.mediaDevices&&(e.navigator.mediaDevices.getDisplayMedia=function(a){if(!a||!a.video){var t=new DOMException(\"getDisplayMedia without video constraints is undefined\");return t.name=\"NotFoundError\",t.code=8,Promise.reject(t)}return!0===a.video?a.video={mediaSource:i}:a.video.mediaSource=i,e.navigator.mediaDevices.getUserMedia(a)})}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimGetDisplayMedia=e;\n},{}],\"Fzdr\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimOnTrack=s,exports.shimPeerConnection=c,exports.shimSenderGetStats=p,exports.shimReceiverGetStats=u,exports.shimRemoveStream=f,exports.shimRTCDataChannel=d,exports.shimAddTransceiver=C,exports.shimGetParameters=y,exports.shimCreateOffer=l,exports.shimCreateAnswer=m,Object.defineProperty(exports,\"shimGetUserMedia\",{enumerable:!0,get:function(){return t.shimGetUserMedia}}),Object.defineProperty(exports,\"shimGetDisplayMedia\",{enumerable:!0,get:function(){return n.shimGetDisplayMedia}});var e=o(require(\"../utils\")),t=require(\"./getusermedia\"),n=require(\"./getdisplaymedia\");function r(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return r=function(){return e},e}function o(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=r();if(t&&t.has(e))return t.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=o?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(n,i,a):n[i]=e[i]}return n.default=e,t&&t.set(e,n),n}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e){return(a=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function s(e){\"object\"===a(e)&&e.RTCTrackEvent&&\"receiver\"in e.RTCTrackEvent.prototype&&!(\"transceiver\"in e.RTCTrackEvent.prototype)&&Object.defineProperty(e.RTCTrackEvent.prototype,\"transceiver\",{get:function(){return{receiver:this.receiver}}})}function c(e,t){if(\"object\"===a(e)&&(e.RTCPeerConnection||e.mozRTCPeerConnection)){!e.RTCPeerConnection&&e.mozRTCPeerConnection&&(e.RTCPeerConnection=e.mozRTCPeerConnection),t.version<53&&[\"setLocalDescription\",\"setRemoteDescription\",\"addIceCandidate\"].forEach(function(t){var n=e.RTCPeerConnection.prototype[t],r=i({},t,function(){return arguments[0]=new(\"addIceCandidate\"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),n.apply(this,arguments)});e.RTCPeerConnection.prototype[t]=r[t]});var n={inboundrtp:\"inbound-rtp\",outboundrtp:\"outbound-rtp\",candidatepair:\"candidate-pair\",localcandidate:\"local-candidate\",remotecandidate:\"remote-candidate\"},r=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(){var[e,o,i]=arguments;return r.apply(this,[e||null]).then(function(e){if(t.version<53&&!o)try{e.forEach(function(e){e.type=n[e.type]||e.type})}catch(r){if(\"TypeError\"!==r.name)throw r;e.forEach(function(t,r){e.set(r,Object.assign({},t,{type:n[t.type]||t.type}))})}return e}).then(o,i)}}}function p(e){if(\"object\"===a(e)&&e.RTCPeerConnection&&e.RTCRtpSender&&!(e.RTCRtpSender&&\"getStats\"in e.RTCRtpSender.prototype)){var t=e.RTCPeerConnection.prototype.getSenders;t&&(e.RTCPeerConnection.prototype.getSenders=function(){var e=this,n=t.apply(this,[]);return n.forEach(function(t){return t._pc=e}),n});var n=e.RTCPeerConnection.prototype.addTrack;n&&(e.RTCPeerConnection.prototype.addTrack=function(){var e=n.apply(this,arguments);return e._pc=this,e}),e.RTCRtpSender.prototype.getStats=function(){return this.track?this._pc.getStats(this.track):Promise.resolve(new Map)}}}function u(t){if(\"object\"===a(t)&&t.RTCPeerConnection&&t.RTCRtpSender&&!(t.RTCRtpSender&&\"getStats\"in t.RTCRtpReceiver.prototype)){var n=t.RTCPeerConnection.prototype.getReceivers;n&&(t.RTCPeerConnection.prototype.getReceivers=function(){var e=this,t=n.apply(this,[]);return t.forEach(function(t){return t._pc=e}),t}),e.wrapPeerConnectionEvent(t,\"track\",function(e){return e.receiver._pc=e.srcElement,e}),t.RTCRtpReceiver.prototype.getStats=function(){return this._pc.getStats(this.track)}}}function f(t){!t.RTCPeerConnection||\"removeStream\"in t.RTCPeerConnection.prototype||(t.RTCPeerConnection.prototype.removeStream=function(t){var n=this;e.deprecated(\"removeStream\",\"removeTrack\"),this.getSenders().forEach(function(e){e.track&&t.getTracks().includes(e.track)&&n.removeTrack(e)})})}function d(e){e.DataChannel&&!e.RTCDataChannel&&(e.RTCDataChannel=e.DataChannel)}function C(e){if(\"object\"===a(e)&&e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype.addTransceiver;t&&(e.RTCPeerConnection.prototype.addTransceiver=function(){this.setParametersPromises=[];var e=arguments[1],n=e&&\"sendEncodings\"in e;n&&e.sendEncodings.forEach(function(e){if(\"rid\"in e){if(!/^[a-z0-9]{0,16}$/i.test(e.rid))throw new TypeError(\"Invalid RID value provided.\")}if(\"scaleResolutionDownBy\"in e&&!(parseFloat(e.scaleResolutionDownBy)>=1))throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");if(\"maxFramerate\"in e&&!(parseFloat(e.maxFramerate)>=0))throw new RangeError(\"max_framerate must be >= 0.0\")});var r=t.apply(this,arguments);if(n){var{sender:o}=r,i=o.getParameters();\"encodings\"in i&&(1!==i.encodings.length||0!==Object.keys(i.encodings[0]).length)||(i.encodings=e.sendEncodings,o.sendEncodings=e.sendEncodings,this.setParametersPromises.push(o.setParameters(i).then(function(){delete o.sendEncodings}).catch(function(){delete o.sendEncodings})))}return r})}}function y(e){if(\"object\"===a(e)&&e.RTCRtpSender){var t=e.RTCRtpSender.prototype.getParameters;t&&(e.RTCRtpSender.prototype.getParameters=function(){var e=t.apply(this,arguments);return\"encodings\"in e||(e.encodings=[].concat(this.sendEncodings||[{}])),e})}}function l(e){if(\"object\"===a(e)&&e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype.createOffer;e.RTCPeerConnection.prototype.createOffer=function(){var e=arguments,n=this;return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then(function(){return t.apply(n,e)}).finally(function(){n.setParametersPromises=[]}):t.apply(this,arguments)}}}function m(e){if(\"object\"===a(e)&&e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype.createAnswer;e.RTCPeerConnection.prototype.createAnswer=function(){var e=arguments,n=this;return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then(function(){return t.apply(n,e)}).finally(function(){n.setParametersPromises=[]}):t.apply(this,arguments)}}}\n},{\"../utils\":\"iSxC\",\"./getusermedia\":\"GzSv\",\"./getdisplaymedia\":\"UuGU\"}],\"t1lL\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimLocalStreamsAPI=n,exports.shimRemoteStreamsAPI=i,exports.shimCallbacksAPI=a,exports.shimGetUserMedia=c,exports.shimConstraints=s,exports.shimRTCIceServerUrls=d,exports.shimTrackEventTransceiver=f,exports.shimCreateOfferLegacy=p,exports.shimAudioContext=u;var e=r(require(\"../utils\"));function t(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return t=function(){return e},e}function r(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var r=t();if(r&&r.has(e))return r.get(e);var o={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=n?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(o,i,a):o[i]=e[i]}return o.default=e,r&&r.set(e,o),o}function o(e){return(o=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function n(e){if(\"object\"===o(e)&&e.RTCPeerConnection){if(\"getLocalStreams\"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getLocalStreams=function(){return this._localStreams||(this._localStreams=[]),this._localStreams}),!(\"addStream\"in e.RTCPeerConnection.prototype)){var t=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addStream=function(e){var r=this;this._localStreams||(this._localStreams=[]),this._localStreams.includes(e)||this._localStreams.push(e),e.getAudioTracks().forEach(function(o){return t.call(r,o,e)}),e.getVideoTracks().forEach(function(o){return t.call(r,o,e)})},e.RTCPeerConnection.prototype.addTrack=function(e){for(var r=this,o=arguments.length,n=new Array(o>1?o-1:0),i=1;i<o;i++)n[i-1]=arguments[i];return n&&n.forEach(function(e){r._localStreams?r._localStreams.includes(e)||r._localStreams.push(e):r._localStreams=[e]}),t.apply(this,arguments)}}\"removeStream\"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.removeStream=function(e){var t=this;this._localStreams||(this._localStreams=[]);var r=this._localStreams.indexOf(e);if(-1!==r){this._localStreams.splice(r,1);var o=e.getTracks();this.getSenders().forEach(function(e){o.includes(e.track)&&t.removeTrack(e)})}})}}function i(e){if(\"object\"===o(e)&&e.RTCPeerConnection&&(\"getRemoteStreams\"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getRemoteStreams=function(){return this._remoteStreams?this._remoteStreams:[]}),!(\"onaddstream\"in e.RTCPeerConnection.prototype))){Object.defineProperty(e.RTCPeerConnection.prototype,\"onaddstream\",{get:function(){return this._onaddstream},set:function(e){var t=this;this._onaddstream&&(this.removeEventListener(\"addstream\",this._onaddstream),this.removeEventListener(\"track\",this._onaddstreampoly)),this.addEventListener(\"addstream\",this._onaddstream=e),this.addEventListener(\"track\",this._onaddstreampoly=function(e){e.streams.forEach(function(e){if(t._remoteStreams||(t._remoteStreams=[]),!t._remoteStreams.includes(e)){t._remoteStreams.push(e);var r=new Event(\"addstream\");r.stream=e,t.dispatchEvent(r)}})})}});var t=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(){var e=this;return this._onaddstreampoly||this.addEventListener(\"track\",this._onaddstreampoly=function(t){t.streams.forEach(function(t){if(e._remoteStreams||(e._remoteStreams=[]),!(e._remoteStreams.indexOf(t)>=0)){e._remoteStreams.push(t);var r=new Event(\"addstream\");r.stream=t,e.dispatchEvent(r)}})}),t.apply(e,arguments)}}}function a(e){if(\"object\"===o(e)&&e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype,r=t.createOffer,n=t.createAnswer,i=t.setLocalDescription,a=t.setRemoteDescription,c=t.addIceCandidate;t.createOffer=function(e,t){var o=arguments.length>=2?arguments[2]:arguments[0],n=r.apply(this,[o]);return t?(n.then(e,t),Promise.resolve()):n},t.createAnswer=function(e,t){var r=arguments.length>=2?arguments[2]:arguments[0],o=n.apply(this,[r]);return t?(o.then(e,t),Promise.resolve()):o};var s=function(e,t,r){var o=i.apply(this,[e]);return r?(o.then(t,r),Promise.resolve()):o};t.setLocalDescription=s,s=function(e,t,r){var o=a.apply(this,[e]);return r?(o.then(t,r),Promise.resolve()):o},t.setRemoteDescription=s,s=function(e,t,r){var o=c.apply(this,[e]);return r?(o.then(t,r),Promise.resolve()):o},t.addIceCandidate=s}}function c(e){var t=e&&e.navigator;if(t.mediaDevices&&t.mediaDevices.getUserMedia){var r=t.mediaDevices,o=r.getUserMedia.bind(r);t.mediaDevices.getUserMedia=function(e){return o(s(e))}}!t.getUserMedia&&t.mediaDevices&&t.mediaDevices.getUserMedia&&(t.getUserMedia=function(e,r,o){t.mediaDevices.getUserMedia(e).then(r,o)}.bind(t))}function s(t){return t&&void 0!==t.video?Object.assign({},t,{video:e.compactObject(t.video)}):t}function d(t){if(t.RTCPeerConnection){var r=t.RTCPeerConnection;t.RTCPeerConnection=function(t,o){if(t&&t.iceServers){for(var n=[],i=0;i<t.iceServers.length;i++){var a=t.iceServers[i];!a.hasOwnProperty(\"urls\")&&a.hasOwnProperty(\"url\")?(e.deprecated(\"RTCIceServer.url\",\"RTCIceServer.urls\"),(a=JSON.parse(JSON.stringify(a))).urls=a.url,delete a.url,n.push(a)):n.push(t.iceServers[i])}t.iceServers=n}return new r(t,o)},t.RTCPeerConnection.prototype=r.prototype,\"generateCertificate\"in r&&Object.defineProperty(t.RTCPeerConnection,\"generateCertificate\",{get:function(){return r.generateCertificate}})}}function f(e){\"object\"===o(e)&&e.RTCTrackEvent&&\"receiver\"in e.RTCTrackEvent.prototype&&!(\"transceiver\"in e.RTCTrackEvent.prototype)&&Object.defineProperty(e.RTCTrackEvent.prototype,\"transceiver\",{get:function(){return{receiver:this.receiver}}})}function p(e){var t=e.RTCPeerConnection.prototype.createOffer;e.RTCPeerConnection.prototype.createOffer=function(e){if(e){void 0!==e.offerToReceiveAudio&&(e.offerToReceiveAudio=!!e.offerToReceiveAudio);var r=this.getTransceivers().find(function(e){return\"audio\"===e.receiver.track.kind});!1===e.offerToReceiveAudio&&r?\"sendrecv\"===r.direction?r.setDirection?r.setDirection(\"sendonly\"):r.direction=\"sendonly\":\"recvonly\"===r.direction&&(r.setDirection?r.setDirection(\"inactive\"):r.direction=\"inactive\"):!0!==e.offerToReceiveAudio||r||this.addTransceiver(\"audio\"),void 0!==e.offerToReceiveVideo&&(e.offerToReceiveVideo=!!e.offerToReceiveVideo);var o=this.getTransceivers().find(function(e){return\"video\"===e.receiver.track.kind});!1===e.offerToReceiveVideo&&o?\"sendrecv\"===o.direction?o.setDirection?o.setDirection(\"sendonly\"):o.direction=\"sendonly\":\"recvonly\"===o.direction&&(o.setDirection?o.setDirection(\"inactive\"):o.direction=\"inactive\"):!0!==e.offerToReceiveVideo||o||this.addTransceiver(\"video\")}return t.apply(this,arguments)}}function u(e){\"object\"!==o(e)||e.AudioContext||(e.AudioContext=e.webkitAudioContext)}\n},{\"../utils\":\"iSxC\"}],\"GOQK\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.shimRTCIceCandidate=a,exports.shimMaxMessageSize=c,exports.shimSendThrowTypeError=s,exports.shimConnectionState=p,exports.removeExtmapAllowMixed=d,exports.shimAddIceCandidateNullOrEmpty=u;var e=r(require(\"sdp\")),t=o(require(\"./utils\"));function n(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return n=function(){return e},e}function o(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=n();if(t&&t.has(e))return t.get(e);var o={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var a=r?Object.getOwnPropertyDescriptor(e,i):null;a&&(a.get||a.set)?Object.defineProperty(o,i,a):o[i]=e[i]}return o.default=e,t&&t.set(e,o),o}function r(e){return e&&e.__esModule?e:{default:e}}function i(e){return(i=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function a(n){if(n.RTCIceCandidate&&!(n.RTCIceCandidate&&\"foundation\"in n.RTCIceCandidate.prototype)){var o=n.RTCIceCandidate;n.RTCIceCandidate=function(t){if(\"object\"===i(t)&&t.candidate&&0===t.candidate.indexOf(\"a=\")&&((t=JSON.parse(JSON.stringify(t))).candidate=t.candidate.substr(2)),t.candidate&&t.candidate.length){var n=new o(t),r=e.default.parseCandidate(t.candidate),a=Object.assign(n,r);return a.toJSON=function(){return{candidate:a.candidate,sdpMid:a.sdpMid,sdpMLineIndex:a.sdpMLineIndex,usernameFragment:a.usernameFragment}},a}return new o(t)},n.RTCIceCandidate.prototype=o.prototype,t.wrapPeerConnectionEvent(n,\"icecandidate\",function(e){return e.candidate&&Object.defineProperty(e,\"candidate\",{value:new n.RTCIceCandidate(e.candidate),writable:\"false\"}),e})}}function c(t,n){if(t.RTCPeerConnection){\"sctp\"in t.RTCPeerConnection.prototype||Object.defineProperty(t.RTCPeerConnection.prototype,\"sctp\",{get:function(){return void 0===this._sctp?null:this._sctp}});var o=t.RTCPeerConnection.prototype.setRemoteDescription;t.RTCPeerConnection.prototype.setRemoteDescription=function(){if(this._sctp=null,\"chrome\"===n.browser&&n.version>=76){var{sdpSemantics:t}=this.getConfiguration();\"plan-b\"===t&&Object.defineProperty(this,\"sctp\",{get:function(){return void 0===this._sctp?null:this._sctp},enumerable:!0,configurable:!0})}if(function(t){if(!t||!t.sdp)return!1;var n=e.default.splitSections(t.sdp);return n.shift(),n.some(function(t){var n=e.default.parseMLine(t);return n&&\"application\"===n.kind&&-1!==n.protocol.indexOf(\"SCTP\")})}(arguments[0])){var r,i=function(e){var t=e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);if(null===t||t.length<2)return-1;var n=parseInt(t[1],10);return n!=n?-1:n}(arguments[0]),a=(p=i,d=65536,\"firefox\"===n.browser&&(d=n.version<57?-1===p?16384:2147483637:n.version<60?57===n.version?65535:65536:2147483637),d),c=function(t,o){var r=65536;\"firefox\"===n.browser&&57===n.version&&(r=65535);var i=e.default.matchPrefix(t.sdp,\"a=max-message-size:\");return i.length>0?r=parseInt(i[0].substr(19),10):\"firefox\"===n.browser&&-1!==o&&(r=2147483637),r}(arguments[0],i);r=0===a&&0===c?Number.POSITIVE_INFINITY:0===a||0===c?Math.max(a,c):Math.min(a,c);var s={};Object.defineProperty(s,\"maxMessageSize\",{get:function(){return r}}),this._sctp=s}var p,d;return o.apply(this,arguments)}}}function s(e){if(e.RTCPeerConnection&&\"createDataChannel\"in e.RTCPeerConnection.prototype){var n=e.RTCPeerConnection.prototype.createDataChannel;e.RTCPeerConnection.prototype.createDataChannel=function(){var e=n.apply(this,arguments);return o(e,this),e},t.wrapPeerConnectionEvent(e,\"datachannel\",function(e){return o(e.channel,e.target),e})}function o(e,t){var n=e.send;e.send=function(){var o=arguments[0],r=o.length||o.size||o.byteLength;if(\"open\"===e.readyState&&t.sctp&&r>t.sctp.maxMessageSize)throw new TypeError(\"Message too large (can send a maximum of \"+t.sctp.maxMessageSize+\" bytes)\");return n.apply(e,arguments)}}}function p(e){if(e.RTCPeerConnection&&!(\"connectionState\"in e.RTCPeerConnection.prototype)){var t=e.RTCPeerConnection.prototype;Object.defineProperty(t,\"connectionState\",{get:function(){return{completed:\"connected\",checking:\"connecting\"}[this.iceConnectionState]||this.iceConnectionState},enumerable:!0,configurable:!0}),Object.defineProperty(t,\"onconnectionstatechange\",{get:function(){return this._onconnectionstatechange||null},set:function(e){this._onconnectionstatechange&&(this.removeEventListener(\"connectionstatechange\",this._onconnectionstatechange),delete this._onconnectionstatechange),e&&this.addEventListener(\"connectionstatechange\",this._onconnectionstatechange=e)},enumerable:!0,configurable:!0}),[\"setLocalDescription\",\"setRemoteDescription\"].forEach(function(e){var n=t[e];t[e]=function(){return this._connectionstatechangepoly||(this._connectionstatechangepoly=function(e){var t=e.target;if(t._lastConnectionState!==t.connectionState){t._lastConnectionState=t.connectionState;var n=new Event(\"connectionstatechange\",e);t.dispatchEvent(n)}return e},this.addEventListener(\"iceconnectionstatechange\",this._connectionstatechangepoly)),n.apply(this,arguments)}})}}function d(e,t){if(e.RTCPeerConnection&&!(\"chrome\"===t.browser&&t.version>=71||\"safari\"===t.browser&&t.version>=605)){var n=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(t){if(t&&t.sdp&&-1!==t.sdp.indexOf(\"\\na=extmap-allow-mixed\")){var o=t.sdp.split(\"\\n\").filter(function(e){return\"a=extmap-allow-mixed\"!==e.trim()}).join(\"\\n\");e.RTCSessionDescription&&t instanceof e.RTCSessionDescription?arguments[0]=new e.RTCSessionDescription({type:t.type,sdp:o}):t.sdp=o}return n.apply(this,arguments)}}}function u(e,t){if(e.RTCPeerConnection&&e.RTCPeerConnection.prototype){var n=e.RTCPeerConnection.prototype.addIceCandidate;n&&0!==n.length&&(e.RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?(\"chrome\"===t.browser&&t.version<78||\"firefox\"===t.browser&&t.version<68||\"safari\"===t.browser)&&arguments[0]&&\"\"===arguments[0].candidate?Promise.resolve():n.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())})}}\n},{\"sdp\":\"YHvh\",\"./utils\":\"iSxC\"}],\"KtlG\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.adapterFactory=o;var e=m(require(\"./utils\")),i=m(require(\"./chrome/chrome_shim\")),r=m(require(\"./edge/edge_shim\")),s=m(require(\"./firefox/firefox_shim\")),t=m(require(\"./safari/safari_shim\")),a=m(require(\"./common_shim\"));function n(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return n=function(){return e},e}function m(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var i=n();if(i&&i.has(e))return i.get(e);var r={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var t in e)if(Object.prototype.hasOwnProperty.call(e,t)){var a=s?Object.getOwnPropertyDescriptor(e,t):null;a&&(a.get||a.set)?Object.defineProperty(r,t,a):r[t]=e[t]}return r.default=e,i&&i.set(e,r),r}function o(){var{window:n}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},m=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{shimChrome:!0,shimFirefox:!0,shimEdge:!0,shimSafari:!0},o=e.log,h=e.detectBrowser(n),d={browserDetails:h,commonShim:a,extractVersion:e.extractVersion,disableLog:e.disableLog,disableWarnings:e.disableWarnings};switch(h.browser){case\"chrome\":if(!i||!i.shimPeerConnection||!m.shimChrome)return o(\"Chrome shim is not included in this adapter release.\"),d;if(null===h.version)return o(\"Chrome shim can not determine version, not shimming.\"),d;o(\"adapter.js shimming chrome.\"),d.browserShim=i,a.shimAddIceCandidateNullOrEmpty(n,h),i.shimGetUserMedia(n,h),i.shimMediaStream(n,h),i.shimPeerConnection(n,h),i.shimOnTrack(n,h),i.shimAddTrackRemoveTrack(n,h),i.shimGetSendersWithDtmf(n,h),i.shimGetStats(n,h),i.shimSenderReceiverGetStats(n,h),i.fixNegotiationNeeded(n,h),a.shimRTCIceCandidate(n,h),a.shimConnectionState(n,h),a.shimMaxMessageSize(n,h),a.shimSendThrowTypeError(n,h),a.removeExtmapAllowMixed(n,h);break;case\"firefox\":if(!s||!s.shimPeerConnection||!m.shimFirefox)return o(\"Firefox shim is not included in this adapter release.\"),d;o(\"adapter.js shimming firefox.\"),d.browserShim=s,a.shimAddIceCandidateNullOrEmpty(n,h),s.shimGetUserMedia(n,h),s.shimPeerConnection(n,h),s.shimOnTrack(n,h),s.shimRemoveStream(n,h),s.shimSenderGetStats(n,h),s.shimReceiverGetStats(n,h),s.shimRTCDataChannel(n,h),s.shimAddTransceiver(n,h),s.shimGetParameters(n,h),s.shimCreateOffer(n,h),s.shimCreateAnswer(n,h),a.shimRTCIceCandidate(n,h),a.shimConnectionState(n,h),a.shimMaxMessageSize(n,h),a.shimSendThrowTypeError(n,h);break;case\"edge\":if(!r||!r.shimPeerConnection||!m.shimEdge)return o(\"MS edge shim is not included in this adapter release.\"),d;o(\"adapter.js shimming edge.\"),d.browserShim=r,r.shimGetUserMedia(n,h),r.shimGetDisplayMedia(n,h),r.shimPeerConnection(n,h),r.shimReplaceTrack(n,h),a.shimMaxMessageSize(n,h),a.shimSendThrowTypeError(n,h);break;case\"safari\":if(!t||!m.shimSafari)return o(\"Safari shim is not included in this adapter release.\"),d;o(\"adapter.js shimming safari.\"),d.browserShim=t,a.shimAddIceCandidateNullOrEmpty(n,h),t.shimRTCIceServerUrls(n,h),t.shimCreateOfferLegacy(n,h),t.shimCallbacksAPI(n,h),t.shimLocalStreamsAPI(n,h),t.shimRemoteStreamsAPI(n,h),t.shimTrackEventTransceiver(n,h),t.shimGetUserMedia(n,h),t.shimAudioContext(n,h),a.shimRTCIceCandidate(n,h),a.shimMaxMessageSize(n,h),a.shimSendThrowTypeError(n,h),a.removeExtmapAllowMixed(n,h);break;default:o(\"Unsupported browser!\")}return d}\n},{\"./utils\":\"iSxC\",\"./chrome/chrome_shim\":\"uI5X\",\"./edge/edge_shim\":\"XRic\",\"./firefox/firefox_shim\":\"Fzdr\",\"./safari/safari_shim\":\"t1lL\",\"./common_shim\":\"GOQK\"}],\"tI1X\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var e=require(\"./adapter_factory.js\"),t=(0,e.adapterFactory)({window:\"undefined\"==typeof window?void 0:window}),d=t;exports.default=d;\n},{\"./adapter_factory.js\":\"KtlG\"}],\"sXtV\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.webRTCAdapter=void 0;var t=e(require(\"webrtc-adapter\"));exports.webRTCAdapter=t.default;\n},{\"webrtc-adapter\":\"tI1X\"}],\"I31f\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Supports=void 0;var r=require(\"./adapter\");exports.Supports=new(function(){function e(){this.isIOS=[\"iPad\",\"iPhone\",\"iPod\"].includes(navigator.platform),this.supportedBrowsers=[\"firefox\",\"chrome\",\"safari\"],this.minFirefoxVersion=59,this.minChromeVersion=72,this.minSafariVersion=605}return e.prototype.isWebRTCSupported=function(){return\"undefined\"!=typeof RTCPeerConnection},e.prototype.isBrowserSupported=function(){var r=this.getBrowser(),e=this.getVersion();return!!this.supportedBrowsers.includes(r)&&(\"chrome\"===r?e>=this.minChromeVersion:\"firefox\"===r?e>=this.minFirefoxVersion:\"safari\"===r&&(!this.isIOS&&e>=this.minSafariVersion))},e.prototype.getBrowser=function(){return r.webRTCAdapter.browserDetails.browser},e.prototype.getVersion=function(){return r.webRTCAdapter.browserDetails.version||0},e.prototype.isUnifiedPlanSupported=function(){var e,i=this.getBrowser(),t=r.webRTCAdapter.browserDetails.version||0;if(\"chrome\"===i&&t<72)return!1;if(\"firefox\"===i&&t>=59)return!0;if(!(window.RTCRtpTransceiver&&\"currentDirection\"in RTCRtpTransceiver.prototype))return!1;var o=!1;try{(e=new RTCPeerConnection).addTransceiver(\"audio\"),o=!0}catch(s){}finally{e&&e.close()}return o},e.prototype.toString=function(){return\"Supports: \\n    browser:\"+this.getBrowser()+\" \\n    version:\"+this.getVersion()+\" \\n    isIOS:\"+this.isIOS+\" \\n    isWebRTCSupported:\"+this.isWebRTCSupported()+\" \\n    isBrowserSupported:\"+this.isBrowserSupported()+\" \\n    isUnifiedPlanSupported:\"+this.isUnifiedPlanSupported()},e}());\n},{\"./adapter\":\"sXtV\"}],\"BHXf\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r),Object.defineProperty(e,o,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),t=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,\"default\",{enumerable:!0,value:t})}:function(e,t){e.default=t}),r=this&&this.__importStar||function(r){if(r&&r.__esModule)return r;var o={};if(null!=r)for(var n in r)\"default\"!==n&&Object.prototype.hasOwnProperty.call(r,n)&&e(o,r,n);return t(o,r),o};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.util=void 0;var o=r(require(\"peerjs-js-binarypack\")),n=require(\"./supports\"),i={iceServers:[{urls:\"stun:stun.l.google.com:19302\"},{urls:\"turn:0.peerjs.com:3478\",username:\"peerjs\",credential:\"peerjsp\"}],sdpSemantics:\"unified-plan\"};exports.util=new(function(){function e(){this.CLOUD_HOST=\"0.peerjs.com\",this.CLOUD_PORT=443,this.chunkedBrowsers={Chrome:1,chrome:1},this.chunkedMTU=16300,this.defaultConfig=i,this.browser=n.Supports.getBrowser(),this.browserVersion=n.Supports.getVersion(),this.supports=function(){var e,t={browser:n.Supports.isBrowserSupported(),webRTC:n.Supports.isWebRTCSupported(),audioVideo:!1,data:!1,binaryBlob:!1,reliable:!1};if(!t.webRTC)return t;try{e=new RTCPeerConnection(i),t.audioVideo=!0;var r=void 0;try{r=e.createDataChannel(\"_PEERJSTEST\",{ordered:!0}),t.data=!0,t.reliable=!!r.ordered;try{r.binaryType=\"blob\",t.binaryBlob=!n.Supports.isIOS}catch(o){}}catch(o){}finally{r&&r.close()}}catch(o){}finally{e&&e.close()}return t}(),this.pack=o.pack,this.unpack=o.unpack,this._dataCount=1}return e.prototype.noop=function(){},e.prototype.validateId=function(e){return!e||/^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(e)},e.prototype.chunk=function(e){for(var t=[],r=e.size,o=Math.ceil(r/exports.util.chunkedMTU),n=0,i=0;i<r;){var a=Math.min(r,i+exports.util.chunkedMTU),u=e.slice(i,a),s={__peerData:this._dataCount,n:n,data:u,total:o};t.push(s),i=a,n++}return this._dataCount++,t},e.prototype.blobToArrayBuffer=function(e,t){var r=new FileReader;return r.onload=function(e){e.target&&t(e.target.result)},r.readAsArrayBuffer(e),r},e.prototype.binaryStringToArrayBuffer=function(e){for(var t=new Uint8Array(e.length),r=0;r<e.length;r++)t[r]=255&e.charCodeAt(r);return t.buffer},e.prototype.randomToken=function(){return Math.random().toString(36).substr(2)},e.prototype.isSecure=function(){return\"https:\"===location.protocol},e}());\n},{\"peerjs-js-binarypack\":\"kdPp\",\"./supports\":\"I31f\"}],\"JJlS\":[function(require,module,exports) {\n\"use strict\";var e=Object.prototype.hasOwnProperty,t=\"~\";function n(){}function r(e,t,n){this.fn=e,this.context=t,this.once=n||!1}function o(e,n,o,s,i){if(\"function\"!=typeof o)throw new TypeError(\"The listener must be a function\");var c=new r(o,s||e,i),f=t?t+n:n;return e._events[f]?e._events[f].fn?e._events[f]=[e._events[f],c]:e._events[f].push(c):(e._events[f]=c,e._eventsCount++),e}function s(e,t){0==--e._eventsCount?e._events=new n:delete e._events[t]}function i(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(t=!1)),i.prototype.eventNames=function(){var n,r,o=[];if(0===this._eventsCount)return o;for(r in n=this._events)e.call(n,r)&&o.push(t?r.slice(1):r);return Object.getOwnPropertySymbols?o.concat(Object.getOwnPropertySymbols(n)):o},i.prototype.listeners=function(e){var n=t?t+e:e,r=this._events[n];if(!r)return[];if(r.fn)return[r.fn];for(var o=0,s=r.length,i=new Array(s);o<s;o++)i[o]=r[o].fn;return i},i.prototype.listenerCount=function(e){var n=t?t+e:e,r=this._events[n];return r?r.fn?1:r.length:0},i.prototype.emit=function(e,n,r,o,s,i){var c=t?t+e:e;if(!this._events[c])return!1;var f,u,a=this._events[c],l=arguments.length;if(a.fn){switch(a.once&&this.removeListener(e,a.fn,void 0,!0),l){case 1:return a.fn.call(a.context),!0;case 2:return a.fn.call(a.context,n),!0;case 3:return a.fn.call(a.context,n,r),!0;case 4:return a.fn.call(a.context,n,r,o),!0;case 5:return a.fn.call(a.context,n,r,o,s),!0;case 6:return a.fn.call(a.context,n,r,o,s,i),!0}for(u=1,f=new Array(l-1);u<l;u++)f[u-1]=arguments[u];a.fn.apply(a.context,f)}else{var v,h=a.length;for(u=0;u<h;u++)switch(a[u].once&&this.removeListener(e,a[u].fn,void 0,!0),l){case 1:a[u].fn.call(a[u].context);break;case 2:a[u].fn.call(a[u].context,n);break;case 3:a[u].fn.call(a[u].context,n,r);break;case 4:a[u].fn.call(a[u].context,n,r,o);break;default:if(!f)for(v=1,f=new Array(l-1);v<l;v++)f[v-1]=arguments[v];a[u].fn.apply(a[u].context,f)}}return!0},i.prototype.on=function(e,t,n){return o(this,e,t,n,!1)},i.prototype.once=function(e,t,n){return o(this,e,t,n,!0)},i.prototype.removeListener=function(e,n,r,o){var i=t?t+e:e;if(!this._events[i])return this;if(!n)return s(this,i),this;var c=this._events[i];if(c.fn)c.fn!==n||o&&!c.once||r&&c.context!==r||s(this,i);else{for(var f=0,u=[],a=c.length;f<a;f++)(c[f].fn!==n||o&&!c[f].once||r&&c[f].context!==r)&&u.push(c[f]);u.length?this._events[i]=1===u.length?u[0]:u:s(this,i)}return this},i.prototype.removeAllListeners=function(e){var r;return e?(r=t?t+e:e,this._events[r]&&s(this,r)):(this._events=new n,this._eventsCount=0),this},i.prototype.off=i.prototype.removeListener,i.prototype.addListener=i.prototype.on,i.prefixed=t,i.EventEmitter=i,\"undefined\"!=typeof module&&(module.exports=i);\n},{}],\"WOs9\":[function(require,module,exports) {\n\"use strict\";var r=this&&this.__read||function(r,e){var o=\"function\"==typeof Symbol&&r[Symbol.iterator];if(!o)return r;var t,n,l=o.call(r),i=[];try{for(;(void 0===e||e-- >0)&&!(t=l.next()).done;)i.push(t.value)}catch(s){n={error:s}}finally{try{t&&!t.done&&(o=l.return)&&o.call(l)}finally{if(n)throw n.error}}return i},e=this&&this.__spreadArray||function(r,e){for(var o=0,t=e.length,n=r.length;o<t;o++,n++)r[n]=e[o];return r};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.LogLevel=void 0;var o,t=\"PeerJS: \";!function(r){r[r.Disabled=0]=\"Disabled\",r[r.Errors=1]=\"Errors\",r[r.Warnings=2]=\"Warnings\",r[r.All=3]=\"All\"}(o=exports.LogLevel||(exports.LogLevel={}));var n=function(){function n(){this._logLevel=o.Disabled}return Object.defineProperty(n.prototype,\"logLevel\",{get:function(){return this._logLevel},set:function(r){this._logLevel=r},enumerable:!1,configurable:!0}),n.prototype.log=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];this._logLevel>=o.All&&this._print.apply(this,e([o.All],r(t)))},n.prototype.warn=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];this._logLevel>=o.Warnings&&this._print.apply(this,e([o.Warnings],r(t)))},n.prototype.error=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];this._logLevel>=o.Errors&&this._print.apply(this,e([o.Errors],r(t)))},n.prototype.setLogFunction=function(r){this._print=r},n.prototype._print=function(n){for(var l=[],i=1;i<arguments.length;i++)l[i-1]=arguments[i];var s=e([t],r(l));for(var a in s)s[a]instanceof Error&&(s[a]=\"(\"+s[a].name+\") \"+s[a].message);n>=o.All?console.log.apply(console,e([],r(s))):n>=o.Warnings?console.warn.apply(console,e([\"WARNING\"],r(s))):n>=o.Errors&&console.error.apply(console,e([\"ERROR\"],r(s)))},n}();exports.default=new n;\n},{}],\"ZRYf\":[function(require,module,exports) {\n\"use strict\";var e,r,o,n,t,a,i;Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.ServerMessageType=exports.SocketEventType=exports.SerializationType=exports.PeerErrorType=exports.PeerEventType=exports.ConnectionType=exports.ConnectionEventType=void 0,function(e){e.Open=\"open\",e.Stream=\"stream\",e.Data=\"data\",e.Close=\"close\",e.Error=\"error\",e.IceStateChanged=\"iceStateChanged\"}(e=exports.ConnectionEventType||(exports.ConnectionEventType={})),function(e){e.Data=\"data\",e.Media=\"media\"}(r=exports.ConnectionType||(exports.ConnectionType={})),function(e){e.Open=\"open\",e.Close=\"close\",e.Connection=\"connection\",e.Call=\"call\",e.Disconnected=\"disconnected\",e.Error=\"error\"}(o=exports.PeerEventType||(exports.PeerEventType={})),function(e){e.BrowserIncompatible=\"browser-incompatible\",e.Disconnected=\"disconnected\",e.InvalidID=\"invalid-id\",e.InvalidKey=\"invalid-key\",e.Network=\"network\",e.PeerUnavailable=\"peer-unavailable\",e.SslUnavailable=\"ssl-unavailable\",e.ServerError=\"server-error\",e.SocketError=\"socket-error\",e.SocketClosed=\"socket-closed\",e.UnavailableID=\"unavailable-id\",e.WebRTC=\"webrtc\"}(n=exports.PeerErrorType||(exports.PeerErrorType={})),function(e){e.Binary=\"binary\",e.BinaryUTF8=\"binary-utf8\",e.JSON=\"json\"}(t=exports.SerializationType||(exports.SerializationType={})),function(e){e.Message=\"message\",e.Disconnected=\"disconnected\",e.Error=\"error\",e.Close=\"close\"}(a=exports.SocketEventType||(exports.SocketEventType={})),function(e){e.Heartbeat=\"HEARTBEAT\",e.Candidate=\"CANDIDATE\",e.Offer=\"OFFER\",e.Answer=\"ANSWER\",e.Open=\"OPEN\",e.Error=\"ERROR\",e.IdTaken=\"ID-TAKEN\",e.InvalidKey=\"INVALID-KEY\",e.Leave=\"LEAVE\",e.Expire=\"EXPIRE\"}(i=exports.ServerMessageType||(exports.ServerMessageType={}));\n},{}],\"wJlv\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__extends||function(){var e=function(t,n){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(t,n)};return function(t,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function o(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}(),t=this&&this.__read||function(e,t){var n=\"function\"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var o,s,r=n.call(e),i=[];try{for(;(void 0===t||t-- >0)&&!(o=r.next()).done;)i.push(o.value)}catch(c){s={error:c}}finally{try{o&&!o.done&&(n=r.return)&&n.call(r)}finally{if(s)throw s.error}}return i},n=this&&this.__spreadArray||function(e,t){for(var n=0,o=t.length,s=e.length;n<o;n++,s++)e[s]=t[n];return e},o=this&&this.__values||function(e){var t=\"function\"==typeof Symbol&&Symbol.iterator,n=t&&e[t],o=0;if(n)return n.call(e);if(e&&\"number\"==typeof e.length)return{next:function(){return e&&o>=e.length&&(e=void 0),{value:e&&e[o++],done:!e}}};throw new TypeError(t?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")},s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Socket=void 0;var r=require(\"eventemitter3\"),i=s(require(\"./logger\")),c=require(\"./enums\"),a=function(s){function r(e,t,n,o,r,i){void 0===i&&(i=5e3);var c=s.call(this)||this;c.pingInterval=i,c._disconnected=!0,c._messagesQueue=[];var a=e?\"wss://\":\"ws://\";return c._baseUrl=a+t+\":\"+n+o+\"peerjs?key=\"+r,c}return e(r,s),r.prototype.start=function(e,t){var n=this;this._id=e;var o=this._baseUrl+\"&id=\"+e+\"&token=\"+t;!this._socket&&this._disconnected&&(this._socket=new WebSocket(o),this._disconnected=!1,this._socket.onmessage=function(e){var t;try{t=JSON.parse(e.data),i.default.log(\"Server message received:\",t)}catch(o){return void i.default.log(\"Invalid server message\",e.data)}n.emit(c.SocketEventType.Message,t)},this._socket.onclose=function(e){n._disconnected||(i.default.log(\"Socket closed.\",e),n._cleanup(),n._disconnected=!0,n.emit(c.SocketEventType.Disconnected))},this._socket.onopen=function(){n._disconnected||(n._sendQueuedMessages(),i.default.log(\"Socket open\"),n._scheduleHeartbeat())})},r.prototype._scheduleHeartbeat=function(){var e=this;this._wsPingTimer=setTimeout(function(){e._sendHeartbeat()},this.pingInterval)},r.prototype._sendHeartbeat=function(){if(this._wsOpen()){var e=JSON.stringify({type:c.ServerMessageType.Heartbeat});this._socket.send(e),this._scheduleHeartbeat()}else i.default.log(\"Cannot send heartbeat, because socket closed\")},r.prototype._wsOpen=function(){return!!this._socket&&1===this._socket.readyState},r.prototype._sendQueuedMessages=function(){var e,s,r=n([],t(this._messagesQueue));this._messagesQueue=[];try{for(var i=o(r),c=i.next();!c.done;c=i.next()){var a=c.value;this.send(a)}}catch(u){e={error:u}}finally{try{c&&!c.done&&(s=i.return)&&s.call(i)}finally{if(e)throw e.error}}},r.prototype.send=function(e){if(!this._disconnected)if(this._id)if(e.type){if(this._wsOpen()){var t=JSON.stringify(e);this._socket.send(t)}}else this.emit(c.SocketEventType.Error,\"Invalid message\");else this._messagesQueue.push(e)},r.prototype.close=function(){this._disconnected||(this._cleanup(),this._disconnected=!0)},r.prototype._cleanup=function(){this._socket&&(this._socket.onopen=this._socket.onmessage=this._socket.onclose=null,this._socket.close(),this._socket=void 0),clearTimeout(this._wsPingTimer)},r}(r.EventEmitter);exports.Socket=a;\n},{\"eventemitter3\":\"JJlS\",\"./logger\":\"WOs9\",\"./enums\":\"ZRYf\"}],\"HCdX\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__assign||function(){return(e=Object.assign||function(e){for(var n,t=1,o=arguments.length;t<o;t++)for(var i in n=arguments[t])Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i]);return e}).apply(this,arguments)},n=this&&this.__awaiter||function(e,n,t,o){return new(t||(t=Promise))(function(i,r){function c(e){try{s(o.next(e))}catch(n){r(n)}}function a(e){try{s(o.throw(e))}catch(n){r(n)}}function s(e){var n;e.done?i(e.value):(n=e.value,n instanceof t?n:new t(function(e){e(n)})).then(c,a)}s((o=o.apply(e,n||[])).next())})},t=this&&this.__generator||function(e,n){var t,o,i,r,c={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},\"function\"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function a(r){return function(a){return function(r){if(t)throw new TypeError(\"Generator is already executing.\");for(;c;)try{if(t=1,o&&(i=2&r[0]?o.return:r[0]?o.throw||((i=o.return)&&i.call(o),0):o.next)&&!(i=i.call(o,r[1])).done)return i;switch(o=0,i&&(r=[2&r[0],i.value]),r[0]){case 0:case 1:i=r;break;case 4:return c.label++,{value:r[1],done:!1};case 5:c.label++,o=r[1],r=[0];continue;case 7:r=c.ops.pop(),c.trys.pop();continue;default:if(!(i=(i=c.trys).length>0&&i[i.length-1])&&(6===r[0]||2===r[0])){c=0;continue}if(3===r[0]&&(!i||r[1]>i[0]&&r[1]<i[3])){c.label=r[1];break}if(6===r[0]&&c.label<i[1]){c.label=i[1],i=r;break}if(i&&c.label<i[2]){c.label=i[2],c.ops.push(r);break}i[2]&&c.ops.pop(),c.trys.pop();continue}r=n.call(e,c)}catch(a){r=[6,a],o=0}finally{t=i=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,a])}}},o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Negotiator=void 0;var i=require(\"./util\"),r=o(require(\"./logger\")),c=require(\"./enums\"),a=function(){function o(e){this.connection=e}return o.prototype.startConnection=function(e){var n=this._startPeerConnection();if(this.connection.peerConnection=n,this.connection.type===c.ConnectionType.Media&&e._stream&&this._addTracksToConnection(e._stream,n),e.originator){if(this.connection.type===c.ConnectionType.Data){var t=this.connection,o={ordered:!!e.reliable},i=n.createDataChannel(t.label,o);t.initialize(i)}this._makeOffer()}else this.handleSDP(\"OFFER\",e.sdp)},o.prototype._startPeerConnection=function(){r.default.log(\"Creating RTCPeerConnection.\");var e=new RTCPeerConnection(this.connection.provider.options.config);return this._setupListeners(e),e},o.prototype._setupListeners=function(e){var n=this,t=this.connection.peer,o=this.connection.connectionId,a=this.connection.type,s=this.connection.provider;r.default.log(\"Listening for ICE candidates.\"),e.onicecandidate=function(e){e.candidate&&e.candidate.candidate&&(r.default.log(\"Received ICE candidates for \"+t+\":\",e.candidate),s.socket.send({type:c.ServerMessageType.Candidate,payload:{candidate:e.candidate,type:a,connectionId:o},dst:t}))},e.oniceconnectionstatechange=function(){switch(e.iceConnectionState){case\"failed\":r.default.log(\"iceConnectionState is failed, closing connections to \"+t),n.connection.emit(c.ConnectionEventType.Error,new Error(\"Negotiation of connection to \"+t+\" failed.\")),n.connection.close();break;case\"closed\":r.default.log(\"iceConnectionState is closed, closing connections to \"+t),n.connection.emit(c.ConnectionEventType.Error,new Error(\"Connection to \"+t+\" closed.\")),n.connection.close();break;case\"disconnected\":r.default.log(\"iceConnectionState changed to disconnected on the connection with \"+t);break;case\"completed\":e.onicecandidate=i.util.noop}n.connection.emit(c.ConnectionEventType.IceStateChanged,e.iceConnectionState)},r.default.log(\"Listening for data channel\"),e.ondatachannel=function(e){r.default.log(\"Received data channel\");var n=e.channel;s.getConnection(t,o).initialize(n)},r.default.log(\"Listening for remote stream\"),e.ontrack=function(e){r.default.log(\"Received remote stream\");var i=e.streams[0],a=s.getConnection(t,o);if(a.type===c.ConnectionType.Media){var d=a;n._addStreamToMediaConnection(i,d)}}},o.prototype.cleanup=function(){r.default.log(\"Cleaning up PeerConnection to \"+this.connection.peer);var e=this.connection.peerConnection;if(e){this.connection.peerConnection=null,e.onicecandidate=e.oniceconnectionstatechange=e.ondatachannel=e.ontrack=function(){};var n=\"closed\"!==e.signalingState,t=!1;if(this.connection.type===c.ConnectionType.Data){var o=this.connection.dataChannel;o&&(t=!!o.readyState&&\"closed\"!==o.readyState)}(n||t)&&e.close()}},o.prototype._makeOffer=function(){return n(this,void 0,Promise,function(){var n,o,a,s,d,l,u;return t(this,function(t){switch(t.label){case 0:n=this.connection.peerConnection,o=this.connection.provider,t.label=1;case 1:return t.trys.push([1,7,,8]),[4,n.createOffer(this.connection.options.constraints)];case 2:a=t.sent(),r.default.log(\"Created offer.\"),this.connection.options.sdpTransform&&\"function\"==typeof this.connection.options.sdpTransform&&(a.sdp=this.connection.options.sdpTransform(a.sdp)||a.sdp),t.label=3;case 3:return t.trys.push([3,5,,6]),[4,n.setLocalDescription(a)];case 4:return t.sent(),r.default.log(\"Set localDescription:\",a,\"for:\"+this.connection.peer),s={sdp:a,type:this.connection.type,connectionId:this.connection.connectionId,metadata:this.connection.metadata,browser:i.util.browser},this.connection.type===c.ConnectionType.Data&&(d=this.connection,s=e(e({},s),{label:d.label,reliable:d.reliable,serialization:d.serialization})),o.socket.send({type:c.ServerMessageType.Offer,payload:s,dst:this.connection.peer}),[3,6];case 5:return\"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\"!=(l=t.sent())&&(o.emitError(c.PeerErrorType.WebRTC,l),r.default.log(\"Failed to setLocalDescription, \",l)),[3,6];case 6:return[3,8];case 7:return u=t.sent(),o.emitError(c.PeerErrorType.WebRTC,u),r.default.log(\"Failed to createOffer, \",u),[3,8];case 8:return[2]}})})},o.prototype._makeAnswer=function(){return n(this,void 0,Promise,function(){var e,n,o,a,s;return t(this,function(t){switch(t.label){case 0:e=this.connection.peerConnection,n=this.connection.provider,t.label=1;case 1:return t.trys.push([1,7,,8]),[4,e.createAnswer()];case 2:o=t.sent(),r.default.log(\"Created answer.\"),this.connection.options.sdpTransform&&\"function\"==typeof this.connection.options.sdpTransform&&(o.sdp=this.connection.options.sdpTransform(o.sdp)||o.sdp),t.label=3;case 3:return t.trys.push([3,5,,6]),[4,e.setLocalDescription(o)];case 4:return t.sent(),r.default.log(\"Set localDescription:\",o,\"for:\"+this.connection.peer),n.socket.send({type:c.ServerMessageType.Answer,payload:{sdp:o,type:this.connection.type,connectionId:this.connection.connectionId,browser:i.util.browser},dst:this.connection.peer}),[3,6];case 5:return a=t.sent(),n.emitError(c.PeerErrorType.WebRTC,a),r.default.log(\"Failed to setLocalDescription, \",a),[3,6];case 6:return[3,8];case 7:return s=t.sent(),n.emitError(c.PeerErrorType.WebRTC,s),r.default.log(\"Failed to create answer, \",s),[3,8];case 8:return[2]}})})},o.prototype.handleSDP=function(e,o){return n(this,void 0,Promise,function(){var n,i,a,s;return t(this,function(t){switch(t.label){case 0:o=new RTCSessionDescription(o),n=this.connection.peerConnection,i=this.connection.provider,r.default.log(\"Setting remote description\",o),a=this,t.label=1;case 1:return t.trys.push([1,5,,6]),[4,n.setRemoteDescription(o)];case 2:return t.sent(),r.default.log(\"Set remoteDescription:\"+e+\" for:\"+this.connection.peer),\"OFFER\"!==e?[3,4]:[4,a._makeAnswer()];case 3:t.sent(),t.label=4;case 4:return[3,6];case 5:return s=t.sent(),i.emitError(c.PeerErrorType.WebRTC,s),r.default.log(\"Failed to setRemoteDescription, \",s),[3,6];case 6:return[2]}})})},o.prototype.handleCandidate=function(e){return n(this,void 0,Promise,function(){var n,o,i,a,s,d;return t(this,function(t){switch(t.label){case 0:r.default.log(\"handleCandidate:\",e),n=e.candidate,o=e.sdpMLineIndex,i=e.sdpMid,a=this.connection.peerConnection,s=this.connection.provider,t.label=1;case 1:return t.trys.push([1,3,,4]),[4,a.addIceCandidate(new RTCIceCandidate({sdpMid:i,sdpMLineIndex:o,candidate:n}))];case 2:return t.sent(),r.default.log(\"Added ICE candidate for:\"+this.connection.peer),[3,4];case 3:return d=t.sent(),s.emitError(c.PeerErrorType.WebRTC,d),r.default.log(\"Failed to handleCandidate, \",d),[3,4];case 4:return[2]}})})},o.prototype._addTracksToConnection=function(e,n){if(r.default.log(\"add tracks from stream \"+e.id+\" to peer connection\"),!n.addTrack)return r.default.error(\"Your browser does't support RTCPeerConnection#addTrack. Ignored.\");e.getTracks().forEach(function(t){n.addTrack(t,e)})},o.prototype._addStreamToMediaConnection=function(e,n){r.default.log(\"add stream \"+e.id+\" to media connection \"+n.connectionId),n.addStream(e)},o}();exports.Negotiator=a;\n},{\"./util\":\"BHXf\",\"./logger\":\"WOs9\",\"./enums\":\"ZRYf\"}],\"tQFK\":[function(require,module,exports) {\n\"use strict\";var t=this&&this.__extends||function(){var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])})(e,n)};return function(e,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function o(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o)}}();Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.BaseConnection=void 0;var e=require(\"eventemitter3\"),n=function(e){function n(t,n,o){var r=e.call(this)||this;return r.peer=t,r.provider=n,r.options=o,r._open=!1,r.metadata=o.metadata,r}return t(n,e),Object.defineProperty(n.prototype,\"open\",{get:function(){return this._open},enumerable:!1,configurable:!0}),n}(e.EventEmitter);exports.BaseConnection=n;\n},{\"eventemitter3\":\"JJlS\"}],\"dbHP\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__extends||function(){var e=function(t,o){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])})(t,o)};return function(t,o){if(\"function\"!=typeof o&&null!==o)throw new TypeError(\"Class extends value \"+String(o)+\" is not a constructor or null\");function r(){this.constructor=t}e(t,o),t.prototype=null===o?Object.create(o):(r.prototype=o.prototype,new r)}}(),t=this&&this.__assign||function(){return(t=Object.assign||function(e){for(var t,o=1,r=arguments.length;o<r;o++)for(var n in t=arguments[o])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}).apply(this,arguments)},o=this&&this.__values||function(e){var t=\"function\"==typeof Symbol&&Symbol.iterator,o=t&&e[t],r=0;if(o)return o.call(e);if(e&&\"number\"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")},r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.MediaConnection=void 0;var n=require(\"./util\"),i=r(require(\"./logger\")),a=require(\"./negotiator\"),s=require(\"./enums\"),l=require(\"./baseconnection\"),c=function(r){function l(e,t,o){var i=r.call(this,e,t,o)||this;return i._localStream=i.options._stream,i.connectionId=i.options.connectionId||l.ID_PREFIX+n.util.randomToken(),i._negotiator=new a.Negotiator(i),i._localStream&&i._negotiator.startConnection({_stream:i._localStream,originator:!0}),i}return e(l,r),Object.defineProperty(l.prototype,\"type\",{get:function(){return s.ConnectionType.Media},enumerable:!1,configurable:!0}),Object.defineProperty(l.prototype,\"localStream\",{get:function(){return this._localStream},enumerable:!1,configurable:!0}),Object.defineProperty(l.prototype,\"remoteStream\",{get:function(){return this._remoteStream},enumerable:!1,configurable:!0}),l.prototype.addStream=function(e){i.default.log(\"Receiving stream\",e),this._remoteStream=e,r.prototype.emit.call(this,s.ConnectionEventType.Stream,e)},l.prototype.handleMessage=function(e){var t=e.type,o=e.payload;switch(e.type){case s.ServerMessageType.Answer:this._negotiator.handleSDP(t,o.sdp),this._open=!0;break;case s.ServerMessageType.Candidate:this._negotiator.handleCandidate(o.candidate);break;default:i.default.warn(\"Unrecognized message type:\"+t+\" from peer:\"+this.peer)}},l.prototype.answer=function(e,r){var n,a;if(void 0===r&&(r={}),this._localStream)i.default.warn(\"Local stream already exists on this MediaConnection. Are you answering a call twice?\");else{this._localStream=e,r&&r.sdpTransform&&(this.options.sdpTransform=r.sdpTransform),this._negotiator.startConnection(t(t({},this.options._payload),{_stream:e}));var s=this.provider._getMessages(this.connectionId);try{for(var l=o(s),c=l.next();!c.done;c=l.next()){var p=c.value;this.handleMessage(p)}}catch(u){n={error:u}}finally{try{c&&!c.done&&(a=l.return)&&a.call(l)}finally{if(n)throw n.error}}this._open=!0}},l.prototype.close=function(){this._negotiator&&(this._negotiator.cleanup(),this._negotiator=null),this._localStream=null,this._remoteStream=null,this.provider&&(this.provider._removeConnection(this),this.provider=null),this.options&&this.options._stream&&(this.options._stream=null),this.open&&(this._open=!1,r.prototype.emit.call(this,s.ConnectionEventType.Close))},l.ID_PREFIX=\"mc_\",l}(l.BaseConnection);exports.MediaConnection=c;\n},{\"./util\":\"BHXf\",\"./logger\":\"WOs9\",\"./negotiator\":\"HCdX\",\"./enums\":\"ZRYf\",\"./baseconnection\":\"tQFK\"}],\"GGp6\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__extends||function(){var e=function(t,r){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])})(t,r)};return function(t,r){if(\"function\"!=typeof r&&null!==r)throw new TypeError(\"Class extends value \"+String(r)+\" is not a constructor or null\");function o(){this.constructor=t}e(t,r),t.prototype=null===r?Object.create(r):(o.prototype=r.prototype,new o)}}(),t=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.EncodingQueue=void 0;var r=require(\"eventemitter3\"),o=t(require(\"./logger\")),n=function(t){function r(){var e=t.call(this)||this;return e.fileReader=new FileReader,e._queue=[],e._processing=!1,e.fileReader.onload=function(t){e._processing=!1,t.target&&e.emit(\"done\",t.target.result),e.doNextTask()},e.fileReader.onerror=function(t){o.default.error(\"EncodingQueue error:\",t),e._processing=!1,e.destroy(),e.emit(\"error\",t)},e}return e(r,t),Object.defineProperty(r.prototype,\"queue\",{get:function(){return this._queue},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,\"size\",{get:function(){return this.queue.length},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,\"processing\",{get:function(){return this._processing},enumerable:!1,configurable:!0}),r.prototype.enque=function(e){this.queue.push(e),this.processing||this.doNextTask()},r.prototype.destroy=function(){this.fileReader.abort(),this._queue=[]},r.prototype.doNextTask=function(){0!==this.size&&(this.processing||(this._processing=!0,this.fileReader.readAsArrayBuffer(this.queue.shift())))},r}(r.EventEmitter);exports.EncodingQueue=n;\n},{\"eventemitter3\":\"JJlS\",\"./logger\":\"WOs9\"}],\"GBTQ\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__extends||function(){var e=function(t,n){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(t,n)};return function(t,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function i(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(i.prototype=n.prototype,new i)}}(),t=this&&this.__values||function(e){var t=\"function\"==typeof Symbol&&Symbol.iterator,n=t&&e[t],i=0;if(n)return n.call(e);if(e&&\"number\"==typeof e.length)return{next:function(){return e&&i>=e.length&&(e=void 0),{value:e&&e[i++],done:!e}}};throw new TypeError(t?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")},n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.DataConnection=void 0;var i=require(\"./util\"),o=n(require(\"./logger\")),r=require(\"./negotiator\"),a=require(\"./enums\"),s=require(\"./baseconnection\"),u=require(\"./encodingQueue\"),l=function(n){function s(e,t,l){var f=n.call(this,e,t,l)||this;return f.stringify=JSON.stringify,f.parse=JSON.parse,f._buffer=[],f._bufferSize=0,f._buffering=!1,f._chunkedData={},f._encodingQueue=new u.EncodingQueue,f.connectionId=f.options.connectionId||s.ID_PREFIX+i.util.randomToken(),f.label=f.options.label||f.connectionId,f.serialization=f.options.serialization||a.SerializationType.Binary,f.reliable=!!f.options.reliable,f._encodingQueue.on(\"done\",function(e){f._bufferedSend(e)}),f._encodingQueue.on(\"error\",function(){o.default.error(\"DC#\"+f.connectionId+\": Error occured in encoding from blob to arraybuffer, close DC\"),f.close()}),f._negotiator=new r.Negotiator(f),f._negotiator.startConnection(f.options._payload||{originator:!0}),f}return e(s,n),Object.defineProperty(s.prototype,\"type\",{get:function(){return a.ConnectionType.Data},enumerable:!1,configurable:!0}),Object.defineProperty(s.prototype,\"dataChannel\",{get:function(){return this._dc},enumerable:!1,configurable:!0}),Object.defineProperty(s.prototype,\"bufferSize\",{get:function(){return this._bufferSize},enumerable:!1,configurable:!0}),s.prototype.initialize=function(e){this._dc=e,this._configureDataChannel()},s.prototype._configureDataChannel=function(){var e=this;i.util.supports.binaryBlob&&!i.util.supports.reliable||(this.dataChannel.binaryType=\"arraybuffer\"),this.dataChannel.onopen=function(){o.default.log(\"DC#\"+e.connectionId+\" dc connection success\"),e._open=!0,e.emit(a.ConnectionEventType.Open)},this.dataChannel.onmessage=function(t){o.default.log(\"DC#\"+e.connectionId+\" dc onmessage:\",t.data),e._handleDataMessage(t)},this.dataChannel.onclose=function(){o.default.log(\"DC#\"+e.connectionId+\" dc closed for:\",e.peer),e.close()}},s.prototype._handleDataMessage=function(e){var t=this,o=e.data,r=o.constructor,s=o;if(this.serialization===a.SerializationType.Binary||this.serialization===a.SerializationType.BinaryUTF8){if(r===Blob)return void i.util.blobToArrayBuffer(o,function(e){var n=i.util.unpack(e);t.emit(a.ConnectionEventType.Data,n)});if(r===ArrayBuffer)s=i.util.unpack(o);else if(r===String){var u=i.util.binaryStringToArrayBuffer(o);s=i.util.unpack(u)}}else this.serialization===a.SerializationType.JSON&&(s=this.parse(o));s.__peerData?this._handleChunk(s):n.prototype.emit.call(this,a.ConnectionEventType.Data,s)},s.prototype._handleChunk=function(e){var t=e.__peerData,n=this._chunkedData[t]||{data:[],count:0,total:e.total};if(n.data[e.n]=e.data,n.count++,this._chunkedData[t]=n,n.total===n.count){delete this._chunkedData[t];var i=new Blob(n.data);this._handleDataMessage({data:i})}},s.prototype.close=function(){this._buffer=[],this._bufferSize=0,this._chunkedData={},this._negotiator&&(this._negotiator.cleanup(),this._negotiator=null),this.provider&&(this.provider._removeConnection(this),this.provider=null),this.dataChannel&&(this.dataChannel.onopen=null,this.dataChannel.onmessage=null,this.dataChannel.onclose=null,this._dc=null),this._encodingQueue&&(this._encodingQueue.destroy(),this._encodingQueue.removeAllListeners(),this._encodingQueue=null),this.open&&(this._open=!1,n.prototype.emit.call(this,a.ConnectionEventType.Close))},s.prototype.send=function(e,t){if(this.open)if(this.serialization===a.SerializationType.JSON)this._bufferedSend(this.stringify(e));else if(this.serialization===a.SerializationType.Binary||this.serialization===a.SerializationType.BinaryUTF8){var o=i.util.pack(e);if(!t&&o.size>i.util.chunkedMTU)return void this._sendChunks(o);i.util.supports.binaryBlob?this._bufferedSend(o):this._encodingQueue.enque(o)}else this._bufferedSend(e);else n.prototype.emit.call(this,a.ConnectionEventType.Error,new Error(\"Connection is not open. You should listen for the `open` event before sending messages.\"))},s.prototype._bufferedSend=function(e){!this._buffering&&this._trySend(e)||(this._buffer.push(e),this._bufferSize=this._buffer.length)},s.prototype._trySend=function(e){var t=this;if(!this.open)return!1;if(this.dataChannel.bufferedAmount>s.MAX_BUFFERED_AMOUNT)return this._buffering=!0,setTimeout(function(){t._buffering=!1,t._tryBuffer()},50),!1;try{this.dataChannel.send(e)}catch(n){return o.default.error(\"DC#:\"+this.connectionId+\" Error when sending:\",n),this._buffering=!0,this.close(),!1}return!0},s.prototype._tryBuffer=function(){if(this.open&&0!==this._buffer.length){var e=this._buffer[0];this._trySend(e)&&(this._buffer.shift(),this._bufferSize=this._buffer.length,this._tryBuffer())}},s.prototype._sendChunks=function(e){var n,r,a=i.util.chunk(e);o.default.log(\"DC#\"+this.connectionId+\" Try to send \"+a.length+\" chunks...\");try{for(var s=t(a),u=s.next();!u.done;u=s.next()){var l=u.value;this.send(l,!0)}}catch(f){n={error:f}}finally{try{u&&!u.done&&(r=s.return)&&r.call(s)}finally{if(n)throw n.error}}},s.prototype.handleMessage=function(e){var t=e.payload;switch(e.type){case a.ServerMessageType.Answer:this._negotiator.handleSDP(e.type,t.sdp);break;case a.ServerMessageType.Candidate:this._negotiator.handleCandidate(t.candidate);break;default:o.default.warn(\"Unrecognized message type:\",e.type,\"from peer:\",this.peer)}},s.ID_PREFIX=\"dc_\",s.MAX_BUFFERED_AMOUNT=8388608,s}(s.BaseConnection);exports.DataConnection=l;\n},{\"./util\":\"BHXf\",\"./logger\":\"WOs9\",\"./negotiator\":\"HCdX\",\"./enums\":\"ZRYf\",\"./baseconnection\":\"tQFK\",\"./encodingQueue\":\"GGp6\"}],\"in7L\":[function(require,module,exports) {\n\"use strict\";var t=this&&this.__awaiter||function(t,e,r,o){return new(r||(r=Promise))(function(n,s){function i(t){try{a(o.next(t))}catch(e){s(e)}}function u(t){try{a(o.throw(t))}catch(e){s(e)}}function a(t){var e;t.done?n(t.value):(e=t.value,e instanceof r?e:new r(function(t){t(e)})).then(i,u)}a((o=o.apply(t,e||[])).next())})},e=this&&this.__generator||function(t,e){var r,o,n,s,i={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return s={next:u(0),throw:u(1),return:u(2)},\"function\"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function u(s){return function(u){return function(s){if(r)throw new TypeError(\"Generator is already executing.\");for(;i;)try{if(r=1,o&&(n=2&s[0]?o.return:s[0]?o.throw||((n=o.return)&&n.call(o),0):o.next)&&!(n=n.call(o,s[1])).done)return n;switch(o=0,n&&(s=[2&s[0],n.value]),s[0]){case 0:case 1:n=s;break;case 4:return i.label++,{value:s[1],done:!1};case 5:i.label++,o=s[1],s=[0];continue;case 7:s=i.ops.pop(),i.trys.pop();continue;default:if(!(n=(n=i.trys).length>0&&n[n.length-1])&&(6===s[0]||2===s[0])){i=0;continue}if(3===s[0]&&(!n||s[1]>n[0]&&s[1]<n[3])){i.label=s[1];break}if(6===s[0]&&i.label<n[1]){i.label=n[1],n=s;break}if(n&&i.label<n[2]){i.label=n[2],i.ops.push(s);break}n[2]&&i.ops.pop(),i.trys.pop();continue}s=e.call(t,i)}catch(u){s=[6,u],o=0}finally{r=n=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,u])}}},r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.API=void 0;var o=require(\"./util\"),n=r(require(\"./logger\")),s=function(){function r(t){this._options=t}return r.prototype._buildUrl=function(t){var e=(this._options.secure?\"https://\":\"http://\")+this._options.host+\":\"+this._options.port+this._options.path+this._options.key+\"/\"+t;return e+=\"?ts=\"+(new Date).getTime()+Math.random()},r.prototype.retrieveId=function(){return t(this,void 0,Promise,function(){var t,r,s,i;return e(this,function(e){switch(e.label){case 0:t=this._buildUrl(\"id\"),e.label=1;case 1:return e.trys.push([1,3,,4]),[4,fetch(t)];case 2:if(200!==(r=e.sent()).status)throw new Error(\"Error. Status:\"+r.status);return[2,r.text()];case 3:throw s=e.sent(),n.default.error(\"Error retrieving ID\",s),i=\"\",\"/\"===this._options.path&&this._options.host!==o.util.CLOUD_HOST&&(i=\" If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer.\"),new Error(\"Could not get an ID from the server.\"+i);case 4:return[2]}})})},r.prototype.listAllPeers=function(){return t(this,void 0,Promise,function(){var t,r,s,i;return e(this,function(e){switch(e.label){case 0:t=this._buildUrl(\"peers\"),e.label=1;case 1:return e.trys.push([1,3,,4]),[4,fetch(t)];case 2:if(200!==(r=e.sent()).status){if(401===r.status)throw s=\"\",s=this._options.host===o.util.CLOUD_HOST?\"It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.\":\"You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.\",new Error(\"It doesn't look like you have permission to list peers IDs. \"+s);throw new Error(\"Error. Status:\"+r.status)}return[2,r.json()];case 3:throw i=e.sent(),n.default.error(\"Error retrieving list peers\",i),new Error(\"Could not get list peers from the server.\"+i);case 4:return[2]}})})},r}();exports.API=s;\n},{\"./util\":\"BHXf\",\"./logger\":\"WOs9\"}],\"Hxpd\":[function(require,module,exports) {\n\"use strict\";var e=this&&this.__extends||function(){var e=function(t,n){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(t,n)};return function(t,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");function r(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),t=this&&this.__assign||function(){return(t=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var o in t=arguments[n])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e}).apply(this,arguments)},n=this&&this.__values||function(e){var t=\"function\"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&\"number\"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")},r=this&&this.__read||function(e,t){var n=\"function\"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,o,i=n.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(r=i.next()).done;)s.push(r.value)}catch(a){o={error:a}}finally{try{r&&!r.done&&(n=i.return)&&n.call(i)}finally{if(o)throw o.error}}return s},o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Peer=void 0;var i=require(\"eventemitter3\"),s=require(\"./util\"),a=o(require(\"./logger\")),c=require(\"./socket\"),l=require(\"./mediaconnection\"),u=require(\"./dataconnection\"),d=require(\"./enums\"),p=require(\"./api\"),h=function(){return function(){}}(),f=function(o){function i(e,n){var r,c=o.call(this)||this;return c._id=null,c._lastServerId=null,c._destroyed=!1,c._disconnected=!1,c._open=!1,c._connections=new Map,c._lostMessages=new Map,e&&e.constructor==Object?n=e:e&&(r=e.toString()),n=t({debug:0,host:s.util.CLOUD_HOST,port:s.util.CLOUD_PORT,path:\"/\",key:i.DEFAULT_KEY,token:s.util.randomToken(),config:s.util.defaultConfig},n),c._options=n,\"/\"===c._options.host&&(c._options.host=window.location.hostname),c._options.path&&(\"/\"!==c._options.path[0]&&(c._options.path=\"/\"+c._options.path),\"/\"!==c._options.path[c._options.path.length-1]&&(c._options.path+=\"/\")),void 0===c._options.secure&&c._options.host!==s.util.CLOUD_HOST?c._options.secure=s.util.isSecure():c._options.host==s.util.CLOUD_HOST&&(c._options.secure=!0),c._options.logFunction&&a.default.setLogFunction(c._options.logFunction),a.default.logLevel=c._options.debug||0,c._api=new p.API(n),c._socket=c._createServerConnection(),s.util.supports.audioVideo||s.util.supports.data?r&&!s.util.validateId(r)?(c._delayedAbort(d.PeerErrorType.InvalidID,'ID \"'+r+'\" is invalid'),c):(r?c._initialize(r):c._api.retrieveId().then(function(e){return c._initialize(e)}).catch(function(e){return c._abort(d.PeerErrorType.ServerError,e)}),c):(c._delayedAbort(d.PeerErrorType.BrowserIncompatible,\"The current browser does not support WebRTC\"),c)}return e(i,o),Object.defineProperty(i.prototype,\"id\",{get:function(){return this._id},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"options\",{get:function(){return this._options},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"open\",{get:function(){return this._open},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"socket\",{get:function(){return this._socket},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"connections\",{get:function(){var e,t,o=Object.create(null);try{for(var i=n(this._connections),s=i.next();!s.done;s=i.next()){var a=r(s.value,2),c=a[0],l=a[1];o[c]=l}}catch(u){e={error:u}}finally{try{s&&!s.done&&(t=i.return)&&t.call(i)}finally{if(e)throw e.error}}return o},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"destroyed\",{get:function(){return this._destroyed},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,\"disconnected\",{get:function(){return this._disconnected},enumerable:!1,configurable:!0}),i.prototype._createServerConnection=function(){var e=this,t=new c.Socket(this._options.secure,this._options.host,this._options.port,this._options.path,this._options.key,this._options.pingInterval);return t.on(d.SocketEventType.Message,function(t){e._handleMessage(t)}),t.on(d.SocketEventType.Error,function(t){e._abort(d.PeerErrorType.SocketError,t)}),t.on(d.SocketEventType.Disconnected,function(){e.disconnected||(e.emitError(d.PeerErrorType.Network,\"Lost connection to server.\"),e.disconnect())}),t.on(d.SocketEventType.Close,function(){e.disconnected||e._abort(d.PeerErrorType.SocketClosed,\"Underlying socket is already closed.\")}),t},i.prototype._initialize=function(e){this._id=e,this.socket.start(e,this._options.token)},i.prototype._handleMessage=function(e){var t,r,o=e.type,i=e.payload,s=e.src;switch(o){case d.ServerMessageType.Open:this._lastServerId=this.id,this._open=!0,this.emit(d.PeerEventType.Open,this.id);break;case d.ServerMessageType.Error:this._abort(d.PeerErrorType.ServerError,i.msg);break;case d.ServerMessageType.IdTaken:this._abort(d.PeerErrorType.UnavailableID,'ID \"'+this.id+'\" is taken');break;case d.ServerMessageType.InvalidKey:this._abort(d.PeerErrorType.InvalidKey,'API KEY \"'+this._options.key+'\" is invalid');break;case d.ServerMessageType.Leave:a.default.log(\"Received leave message from \"+s),this._cleanupPeer(s),this._connections.delete(s);break;case d.ServerMessageType.Expire:this.emitError(d.PeerErrorType.PeerUnavailable,\"Could not connect to peer \"+s);break;case d.ServerMessageType.Offer:var c=i.connectionId;if((_=this.getConnection(s,c))&&(_.close(),a.default.warn(\"Offer received for existing Connection ID:\"+c)),i.type===d.ConnectionType.Media)_=new l.MediaConnection(s,this,{connectionId:c,_payload:i,metadata:i.metadata}),this._addConnection(s,_),this.emit(d.PeerEventType.Call,_);else{if(i.type!==d.ConnectionType.Data)return void a.default.warn(\"Received malformed connection type:\"+i.type);_=new u.DataConnection(s,this,{connectionId:c,_payload:i,metadata:i.metadata,label:i.label,serialization:i.serialization,reliable:i.reliable}),this._addConnection(s,_),this.emit(d.PeerEventType.Connection,_)}var p=this._getMessages(c);try{for(var h=n(p),f=h.next();!f.done;f=h.next()){var y=f.value;_.handleMessage(y)}}catch(v){t={error:v}}finally{try{f&&!f.done&&(r=h.return)&&r.call(h)}finally{if(t)throw t.error}}break;default:if(!i)return void a.default.warn(\"You received a malformed message from \"+s+\" of type \"+o);var _;c=i.connectionId;(_=this.getConnection(s,c))&&_.peerConnection?_.handleMessage(e):c?this._storeMessage(c,e):a.default.warn(\"You received an unrecognized message:\",e)}},i.prototype._storeMessage=function(e,t){this._lostMessages.has(e)||this._lostMessages.set(e,[]),this._lostMessages.get(e).push(t)},i.prototype._getMessages=function(e){var t=this._lostMessages.get(e);return t?(this._lostMessages.delete(e),t):[]},i.prototype.connect=function(e,t){if(void 0===t&&(t={}),this.disconnected)return a.default.warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available.\"),void this.emitError(d.PeerErrorType.Disconnected,\"Cannot connect to new Peer after disconnecting from server.\");var n=new u.DataConnection(e,this,t);return this._addConnection(e,n),n},i.prototype.call=function(e,t,n){if(void 0===n&&(n={}),this.disconnected)return a.default.warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect.\"),void this.emitError(d.PeerErrorType.Disconnected,\"Cannot connect to new Peer after disconnecting from server.\");if(t){n._stream=t;var r=new l.MediaConnection(e,this,n);return this._addConnection(e,r),r}a.default.error(\"To call a peer, you must provide a stream from your browser's `getUserMedia`.\")},i.prototype._addConnection=function(e,t){a.default.log(\"add connection \"+t.type+\":\"+t.connectionId+\" to peerId:\"+e),this._connections.has(e)||this._connections.set(e,[]),this._connections.get(e).push(t)},i.prototype._removeConnection=function(e){var t=this._connections.get(e.peer);if(t){var n=t.indexOf(e);-1!==n&&t.splice(n,1)}this._lostMessages.delete(e.connectionId)},i.prototype.getConnection=function(e,t){var r,o,i=this._connections.get(e);if(!i)return null;try{for(var s=n(i),a=s.next();!a.done;a=s.next()){var c=a.value;if(c.connectionId===t)return c}}catch(l){r={error:l}}finally{try{a&&!a.done&&(o=s.return)&&o.call(s)}finally{if(r)throw r.error}}return null},i.prototype._delayedAbort=function(e,t){var n=this;setTimeout(function(){n._abort(e,t)},0)},i.prototype._abort=function(e,t){a.default.error(\"Aborting!\"),this.emitError(e,t),this._lastServerId?this.disconnect():this.destroy()},i.prototype.emitError=function(e,t){var n;a.default.error(\"Error:\",t),(n=\"string\"==typeof t?new Error(t):t).type=e,this.emit(d.PeerEventType.Error,n)},i.prototype.destroy=function(){this.destroyed||(a.default.log(\"Destroy peer with ID:\"+this.id),this.disconnect(),this._cleanup(),this._destroyed=!0,this.emit(d.PeerEventType.Close))},i.prototype._cleanup=function(){var e,t;try{for(var r=n(this._connections.keys()),o=r.next();!o.done;o=r.next()){var i=o.value;this._cleanupPeer(i),this._connections.delete(i)}}catch(s){e={error:s}}finally{try{o&&!o.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}this.socket.removeAllListeners()},i.prototype._cleanupPeer=function(e){var t,r,o=this._connections.get(e);if(o)try{for(var i=n(o),s=i.next();!s.done;s=i.next()){s.value.close()}}catch(a){t={error:a}}finally{try{s&&!s.done&&(r=i.return)&&r.call(i)}finally{if(t)throw t.error}}},i.prototype.disconnect=function(){if(!this.disconnected){var e=this.id;a.default.log(\"Disconnect peer with ID:\"+e),this._disconnected=!0,this._open=!1,this.socket.close(),this._lastServerId=e,this._id=null,this.emit(d.PeerEventType.Disconnected,e)}},i.prototype.reconnect=function(){if(this.disconnected&&!this.destroyed)a.default.log(\"Attempting reconnection to server with ID \"+this._lastServerId),this._disconnected=!1,this._initialize(this._lastServerId);else{if(this.destroyed)throw new Error(\"This peer cannot reconnect to the server. It has already been destroyed.\");if(this.disconnected||this.open)throw new Error(\"Peer \"+this.id+\" cannot reconnect because it is not disconnected from the server!\");a.default.error(\"In a hurry? We're still trying to make the initial connection!\")}},i.prototype.listAllPeers=function(e){var t=this;void 0===e&&(e=function(e){}),this._api.listAllPeers().then(function(t){return e(t)}).catch(function(e){return t._abort(d.PeerErrorType.ServerError,e)})},i.DEFAULT_KEY=\"peerjs\",i}(i.EventEmitter);exports.Peer=f;\n},{\"eventemitter3\":\"JJlS\",\"./util\":\"BHXf\",\"./logger\":\"WOs9\",\"./socket\":\"wJlv\",\"./mediaconnection\":\"dbHP\",\"./dataconnection\":\"GBTQ\",\"./enums\":\"ZRYf\",\"./api\":\"in7L\"}],\"iTK6\":[function(require,module,exports) {\n\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.peerjs=void 0;var e=require(\"./util\"),r=require(\"./peer\");exports.peerjs={Peer:r.Peer,util:e.util},exports.default=r.Peer,window.peerjs=exports.peerjs,window.Peer=r.Peer;\n},{\"./util\":\"BHXf\",\"./peer\":\"Hxpd\"}]},{},[\"iTK6\"], null)\n//# sourceMappingURL=/peerjs.min.js.map\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/peerjs/dist/peerjs.min.js?");

/***/ }),

/***/ "./node_modules/peerjs/dist sync recursive":
/*!****************************************!*\
  !*** ./node_modules/peerjs/dist/ sync ***!
  \****************************************/
/***/ ((module) => {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/peerjs/dist sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/peerjs/dist/_sync?");

/***/ }),

/***/ "./node_modules/qrcode/lib/browser.js":
/*!********************************************!*\
  !*** ./node_modules/qrcode/lib/browser.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst canPromise = __webpack_require__(/*! ./can-promise */ \"./node_modules/qrcode/lib/can-promise.js\")\n\nconst QRCode = __webpack_require__(/*! ./core/qrcode */ \"./node_modules/qrcode/lib/core/qrcode.js\")\nconst CanvasRenderer = __webpack_require__(/*! ./renderer/canvas */ \"./node_modules/qrcode/lib/renderer/canvas.js\")\nconst SvgRenderer = __webpack_require__(/*! ./renderer/svg-tag.js */ \"./node_modules/qrcode/lib/renderer/svg-tag.js\")\n\nfunction renderCanvas (renderFunc, canvas, text, opts, cb) {\n  const args = [].slice.call(arguments, 1)\n  const argsNum = args.length\n  const isLastArgCb = typeof args[argsNum - 1] === 'function'\n\n  if (!isLastArgCb && !canPromise()) {\n    throw new Error('Callback required as last argument')\n  }\n\n  if (isLastArgCb) {\n    if (argsNum < 2) {\n      throw new Error('Too few arguments provided')\n    }\n\n    if (argsNum === 2) {\n      cb = text\n      text = canvas\n      canvas = opts = undefined\n    } else if (argsNum === 3) {\n      if (canvas.getContext && typeof cb === 'undefined') {\n        cb = opts\n        opts = undefined\n      } else {\n        cb = opts\n        opts = text\n        text = canvas\n        canvas = undefined\n      }\n    }\n  } else {\n    if (argsNum < 1) {\n      throw new Error('Too few arguments provided')\n    }\n\n    if (argsNum === 1) {\n      text = canvas\n      canvas = opts = undefined\n    } else if (argsNum === 2 && !canvas.getContext) {\n      opts = text\n      text = canvas\n      canvas = undefined\n    }\n\n    return new Promise(function (resolve, reject) {\n      try {\n        const data = QRCode.create(text, opts)\n        resolve(renderFunc(data, canvas, opts))\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n\n  try {\n    const data = QRCode.create(text, opts)\n    cb(null, renderFunc(data, canvas, opts))\n  } catch (e) {\n    cb(e)\n  }\n}\n\nexports.create = QRCode.create\nexports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render)\nexports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL)\n\n// only svg for now.\nexports.toString = renderCanvas.bind(null, function (data, _, opts) {\n  return SvgRenderer.render(data, opts)\n})\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/browser.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/can-promise.js":
/*!************************************************!*\
  !*** ./node_modules/qrcode/lib/can-promise.js ***!
  \************************************************/
/***/ ((module) => {

eval("// can-promise has a crash in some versions of react native that dont have\n// standard global objects\n// https://github.com/soldair/node-qrcode/issues/157\n\nmodule.exports = function () {\n  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/can-promise.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/alignment-pattern.js":
/*!***********************************************************!*\
  !*** ./node_modules/qrcode/lib/core/alignment-pattern.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Alignment pattern are fixed reference pattern in defined positions\n * in a matrix symbology, which enables the decode software to re-synchronise\n * the coordinate mapping of the image modules in the event of moderate amounts\n * of distortion of the image.\n *\n * Alignment patterns are present only in QR Code symbols of version 2 or larger\n * and their number depends on the symbol version.\n */\n\nconst getSymbolSize = (__webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\").getSymbolSize)\n\n/**\n * Calculate the row/column coordinates of the center module of each alignment pattern\n * for the specified QR Code version.\n *\n * The alignment patterns are positioned symmetrically on either side of the diagonal\n * running from the top left corner of the symbol to the bottom right corner.\n *\n * Since positions are simmetrical only half of the coordinates are returned.\n * Each item of the array will represent in turn the x and y coordinate.\n * @see {@link getPositions}\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinate\n */\nexports.getRowColCoords = function getRowColCoords (version) {\n  if (version === 1) return []\n\n  const posCount = Math.floor(version / 7) + 2\n  const size = getSymbolSize(version)\n  const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2\n  const positions = [size - 7] // Last coord is always (size - 7)\n\n  for (let i = 1; i < posCount - 1; i++) {\n    positions[i] = positions[i - 1] - intervals\n  }\n\n  positions.push(6) // First coord is always 6\n\n  return positions.reverse()\n}\n\n/**\n * Returns an array containing the positions of each alignment pattern.\n * Each array's element represent the center point of the pattern as (x, y) coordinates\n *\n * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}\n * and filtering out the items that overlaps with finder pattern\n *\n * @example\n * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.\n * The alignment patterns, therefore, are to be centered on (row, column)\n * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).\n * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns\n * and are not therefore used for alignment patterns.\n *\n * let pos = getPositions(7)\n * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nexports.getPositions = function getPositions (version) {\n  const coords = []\n  const pos = exports.getRowColCoords(version)\n  const posLength = pos.length\n\n  for (let i = 0; i < posLength; i++) {\n    for (let j = 0; j < posLength; j++) {\n      // Skip if position is occupied by finder patterns\n      if ((i === 0 && j === 0) || // top-left\n          (i === 0 && j === posLength - 1) || // bottom-left\n          (i === posLength - 1 && j === 0)) { // top-right\n        continue\n      }\n\n      coords.push([pos[i], pos[j]])\n    }\n  }\n\n  return coords\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/alignment-pattern.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/alphanumeric-data.js":
/*!***********************************************************!*\
  !*** ./node_modules/qrcode/lib/core/alphanumeric-data.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\n\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\nconst ALPHA_NUM_CHARS = [\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n  ' ', '$', '%', '*', '+', '-', '.', '/', ':'\n]\n\nfunction AlphanumericData (data) {\n  this.mode = Mode.ALPHANUMERIC\n  this.data = data\n}\n\nAlphanumericData.getBitsLength = function getBitsLength (length) {\n  return 11 * Math.floor(length / 2) + 6 * (length % 2)\n}\n\nAlphanumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nAlphanumericData.prototype.getBitsLength = function getBitsLength () {\n  return AlphanumericData.getBitsLength(this.data.length)\n}\n\nAlphanumericData.prototype.write = function write (bitBuffer) {\n  let i\n\n  // Input data characters are divided into groups of two characters\n  // and encoded as 11-bit binary codes.\n  for (i = 0; i + 2 <= this.data.length; i += 2) {\n    // The character value of the first character is multiplied by 45\n    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45\n\n    // The character value of the second digit is added to the product\n    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1])\n\n    // The sum is then stored as 11-bit binary number\n    bitBuffer.put(value, 11)\n  }\n\n  // If the number of input data characters is not a multiple of two,\n  // the character value of the final character is encoded as a 6-bit binary number.\n  if (this.data.length % 2) {\n    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6)\n  }\n}\n\nmodule.exports = AlphanumericData\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/alphanumeric-data.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/bit-buffer.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/bit-buffer.js ***!
  \****************************************************/
/***/ ((module) => {

eval("function BitBuffer () {\n  this.buffer = []\n  this.length = 0\n}\n\nBitBuffer.prototype = {\n\n  get: function (index) {\n    const bufIndex = Math.floor(index / 8)\n    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1\n  },\n\n  put: function (num, length) {\n    for (let i = 0; i < length; i++) {\n      this.putBit(((num >>> (length - i - 1)) & 1) === 1)\n    }\n  },\n\n  getLengthInBits: function () {\n    return this.length\n  },\n\n  putBit: function (bit) {\n    const bufIndex = Math.floor(this.length / 8)\n    if (this.buffer.length <= bufIndex) {\n      this.buffer.push(0)\n    }\n\n    if (bit) {\n      this.buffer[bufIndex] |= (0x80 >>> (this.length % 8))\n    }\n\n    this.length++\n  }\n}\n\nmodule.exports = BitBuffer\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/bit-buffer.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/bit-matrix.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/bit-matrix.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/**\n * Helper class to handle QR Code symbol modules\n *\n * @param {Number} size Symbol size\n */\nfunction BitMatrix (size) {\n  if (!size || size < 1) {\n    throw new Error('BitMatrix size must be defined and greater than 0')\n  }\n\n  this.size = size\n  this.data = new Uint8Array(size * size)\n  this.reservedBit = new Uint8Array(size * size)\n}\n\n/**\n * Set bit value at specified location\n * If reserved flag is set, this bit will be ignored during masking process\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n * @param {Boolean} reserved\n */\nBitMatrix.prototype.set = function (row, col, value, reserved) {\n  const index = row * this.size + col\n  this.data[index] = value\n  if (reserved) this.reservedBit[index] = true\n}\n\n/**\n * Returns bit value at specified location\n *\n * @param  {Number}  row\n * @param  {Number}  col\n * @return {Boolean}\n */\nBitMatrix.prototype.get = function (row, col) {\n  return this.data[row * this.size + col]\n}\n\n/**\n * Applies xor operator at specified location\n * (used during masking process)\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n */\nBitMatrix.prototype.xor = function (row, col, value) {\n  this.data[row * this.size + col] ^= value\n}\n\n/**\n * Check if bit at specified location is reserved\n *\n * @param {Number}   row\n * @param {Number}   col\n * @return {Boolean}\n */\nBitMatrix.prototype.isReserved = function (row, col) {\n  return this.reservedBit[row * this.size + col]\n}\n\nmodule.exports = BitMatrix\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/bit-matrix.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/byte-data.js":
/*!***************************************************!*\
  !*** ./node_modules/qrcode/lib/core/byte-data.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const encodeUtf8 = __webpack_require__(/*! encode-utf8 */ \"./node_modules/encode-utf8/index.js\")\nconst Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\n\nfunction ByteData (data) {\n  this.mode = Mode.BYTE\n  this.data = new Uint8Array(encodeUtf8(data))\n}\n\nByteData.getBitsLength = function getBitsLength (length) {\n  return length * 8\n}\n\nByteData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nByteData.prototype.getBitsLength = function getBitsLength () {\n  return ByteData.getBitsLength(this.data.length)\n}\n\nByteData.prototype.write = function (bitBuffer) {\n  for (let i = 0, l = this.data.length; i < l; i++) {\n    bitBuffer.put(this.data[i], 8)\n  }\n}\n\nmodule.exports = ByteData\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/byte-data.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/error-correction-code.js":
/*!***************************************************************!*\
  !*** ./node_modules/qrcode/lib/core/error-correction-code.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const ECLevel = __webpack_require__(/*! ./error-correction-level */ \"./node_modules/qrcode/lib/core/error-correction-level.js\")\r\n\r\nconst EC_BLOCKS_TABLE = [\r\n// L  M  Q  H\r\n  1, 1, 1, 1,\r\n  1, 1, 1, 1,\r\n  1, 1, 2, 2,\r\n  1, 2, 2, 4,\r\n  1, 2, 4, 4,\r\n  2, 4, 4, 4,\r\n  2, 4, 6, 5,\r\n  2, 4, 6, 6,\r\n  2, 5, 8, 8,\r\n  4, 5, 8, 8,\r\n  4, 5, 8, 11,\r\n  4, 8, 10, 11,\r\n  4, 9, 12, 16,\r\n  4, 9, 16, 16,\r\n  6, 10, 12, 18,\r\n  6, 10, 17, 16,\r\n  6, 11, 16, 19,\r\n  6, 13, 18, 21,\r\n  7, 14, 21, 25,\r\n  8, 16, 20, 25,\r\n  8, 17, 23, 25,\r\n  9, 17, 23, 34,\r\n  9, 18, 25, 30,\r\n  10, 20, 27, 32,\r\n  12, 21, 29, 35,\r\n  12, 23, 34, 37,\r\n  12, 25, 34, 40,\r\n  13, 26, 35, 42,\r\n  14, 28, 38, 45,\r\n  15, 29, 40, 48,\r\n  16, 31, 43, 51,\r\n  17, 33, 45, 54,\r\n  18, 35, 48, 57,\r\n  19, 37, 51, 60,\r\n  19, 38, 53, 63,\r\n  20, 40, 56, 66,\r\n  21, 43, 59, 70,\r\n  22, 45, 62, 74,\r\n  24, 47, 65, 77,\r\n  25, 49, 68, 81\r\n]\r\n\r\nconst EC_CODEWORDS_TABLE = [\r\n// L  M  Q  H\r\n  7, 10, 13, 17,\r\n  10, 16, 22, 28,\r\n  15, 26, 36, 44,\r\n  20, 36, 52, 64,\r\n  26, 48, 72, 88,\r\n  36, 64, 96, 112,\r\n  40, 72, 108, 130,\r\n  48, 88, 132, 156,\r\n  60, 110, 160, 192,\r\n  72, 130, 192, 224,\r\n  80, 150, 224, 264,\r\n  96, 176, 260, 308,\r\n  104, 198, 288, 352,\r\n  120, 216, 320, 384,\r\n  132, 240, 360, 432,\r\n  144, 280, 408, 480,\r\n  168, 308, 448, 532,\r\n  180, 338, 504, 588,\r\n  196, 364, 546, 650,\r\n  224, 416, 600, 700,\r\n  224, 442, 644, 750,\r\n  252, 476, 690, 816,\r\n  270, 504, 750, 900,\r\n  300, 560, 810, 960,\r\n  312, 588, 870, 1050,\r\n  336, 644, 952, 1110,\r\n  360, 700, 1020, 1200,\r\n  390, 728, 1050, 1260,\r\n  420, 784, 1140, 1350,\r\n  450, 812, 1200, 1440,\r\n  480, 868, 1290, 1530,\r\n  510, 924, 1350, 1620,\r\n  540, 980, 1440, 1710,\r\n  570, 1036, 1530, 1800,\r\n  570, 1064, 1590, 1890,\r\n  600, 1120, 1680, 1980,\r\n  630, 1204, 1770, 2100,\r\n  660, 1260, 1860, 2220,\r\n  720, 1316, 1950, 2310,\r\n  750, 1372, 2040, 2430\r\n]\r\n\r\n/**\r\n * Returns the number of error correction block that the QR Code should contain\r\n * for the specified version and error correction level.\r\n *\r\n * @param  {Number} version              QR Code version\r\n * @param  {Number} errorCorrectionLevel Error correction level\r\n * @return {Number}                      Number of error correction blocks\r\n */\r\nexports.getBlocksCount = function getBlocksCount (version, errorCorrectionLevel) {\r\n  switch (errorCorrectionLevel) {\r\n    case ECLevel.L:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]\r\n    case ECLevel.M:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]\r\n    case ECLevel.Q:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]\r\n    case ECLevel.H:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]\r\n    default:\r\n      return undefined\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the number of error correction codewords to use for the specified\r\n * version and error correction level.\r\n *\r\n * @param  {Number} version              QR Code version\r\n * @param  {Number} errorCorrectionLevel Error correction level\r\n * @return {Number}                      Number of error correction codewords\r\n */\r\nexports.getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel) {\r\n  switch (errorCorrectionLevel) {\r\n    case ECLevel.L:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]\r\n    case ECLevel.M:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]\r\n    case ECLevel.Q:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]\r\n    case ECLevel.H:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]\r\n    default:\r\n      return undefined\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/error-correction-code.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/error-correction-level.js":
/*!****************************************************************!*\
  !*** ./node_modules/qrcode/lib/core/error-correction-level.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.L = { bit: 1 }\nexports.M = { bit: 0 }\nexports.Q = { bit: 3 }\nexports.H = { bit: 2 }\n\nfunction fromString (string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string')\n  }\n\n  const lcStr = string.toLowerCase()\n\n  switch (lcStr) {\n    case 'l':\n    case 'low':\n      return exports.L\n\n    case 'm':\n    case 'medium':\n      return exports.M\n\n    case 'q':\n    case 'quartile':\n      return exports.Q\n\n    case 'h':\n    case 'high':\n      return exports.H\n\n    default:\n      throw new Error('Unknown EC Level: ' + string)\n  }\n}\n\nexports.isValid = function isValid (level) {\n  return level && typeof level.bit !== 'undefined' &&\n    level.bit >= 0 && level.bit < 4\n}\n\nexports.from = function from (value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value\n  }\n\n  try {\n    return fromString(value)\n  } catch (e) {\n    return defaultValue\n  }\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/error-correction-level.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/finder-pattern.js":
/*!********************************************************!*\
  !*** ./node_modules/qrcode/lib/core/finder-pattern.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const getSymbolSize = (__webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\").getSymbolSize)\nconst FINDER_PATTERN_SIZE = 7\n\n/**\n * Returns an array containing the positions of each finder pattern.\n * Each array's element represent the top-left point of the pattern as (x, y) coordinates\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nexports.getPositions = function getPositions (version) {\n  const size = getSymbolSize(version)\n\n  return [\n    // top-left\n    [0, 0],\n    // top-right\n    [size - FINDER_PATTERN_SIZE, 0],\n    // bottom-left\n    [0, size - FINDER_PATTERN_SIZE]\n  ]\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/finder-pattern.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/format-info.js":
/*!*****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/format-info.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\")\n\nconst G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0)\nconst G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)\nconst G15_BCH = Utils.getBCHDigit(G15)\n\n/**\n * Returns format information with relative error correction bits\n *\n * The format information is a 15-bit sequence containing 5 data bits,\n * with 10 error correction bits calculated using the (15, 5) BCH code.\n *\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Number} mask                 Mask pattern\n * @return {Number}                      Encoded format information bits\n */\nexports.getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {\n  const data = ((errorCorrectionLevel.bit << 3) | mask)\n  let d = data << 10\n\n  while (Utils.getBCHDigit(d) - G15_BCH >= 0) {\n    d ^= (G15 << (Utils.getBCHDigit(d) - G15_BCH))\n  }\n\n  // xor final data with mask pattern in order to ensure that\n  // no combination of Error Correction Level and data mask pattern\n  // will result in an all-zero data string\n  return ((data << 10) | d) ^ G15_MASK\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/format-info.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/galois-field.js":
/*!******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/galois-field.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("const EXP_TABLE = new Uint8Array(512)\nconst LOG_TABLE = new Uint8Array(256)\n/**\n * Precompute the log and anti-log tables for faster computation later\n *\n * For each possible value in the galois field 2^8, we will pre-compute\n * the logarithm and anti-logarithm (exponential) of this value\n *\n * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}\n */\n;(function initTables () {\n  let x = 1\n  for (let i = 0; i < 255; i++) {\n    EXP_TABLE[i] = x\n    LOG_TABLE[x] = i\n\n    x <<= 1 // multiply by 2\n\n    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n    // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)\n      x ^= 0x11D\n    }\n  }\n\n  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n  // stay inside the bounds (because we will mainly use this table for the multiplication of\n  // two GF numbers, no more).\n  // @see {@link mul}\n  for (let i = 255; i < 512; i++) {\n    EXP_TABLE[i] = EXP_TABLE[i - 255]\n  }\n}())\n\n/**\n * Returns log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.log = function log (n) {\n  if (n < 1) throw new Error('log(' + n + ')')\n  return LOG_TABLE[n]\n}\n\n/**\n * Returns anti-log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.exp = function exp (n) {\n  return EXP_TABLE[n]\n}\n\n/**\n * Multiplies two number inside Galois Field\n *\n * @param  {Number} x\n * @param  {Number} y\n * @return {Number}\n */\nexports.mul = function mul (x, y) {\n  if (x === 0 || y === 0) return 0\n\n  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n  // @see {@link initTables}\n  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/galois-field.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/kanji-data.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/kanji-data.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\nconst Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\")\n\nfunction KanjiData (data) {\n  this.mode = Mode.KANJI\n  this.data = data\n}\n\nKanjiData.getBitsLength = function getBitsLength (length) {\n  return length * 13\n}\n\nKanjiData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nKanjiData.prototype.getBitsLength = function getBitsLength () {\n  return KanjiData.getBitsLength(this.data.length)\n}\n\nKanjiData.prototype.write = function (bitBuffer) {\n  let i\n\n  // In the Shift JIS system, Kanji characters are represented by a two byte combination.\n  // These byte values are shifted from the JIS X 0208 values.\n  // JIS X 0208 gives details of the shift coded representation.\n  for (i = 0; i < this.data.length; i++) {\n    let value = Utils.toSJIS(this.data[i])\n\n    // For characters with Shift JIS values from 0x8140 to 0x9FFC:\n    if (value >= 0x8140 && value <= 0x9FFC) {\n      // Subtract 0x8140 from Shift JIS value\n      value -= 0x8140\n\n    // For characters with Shift JIS values from 0xE040 to 0xEBBF\n    } else if (value >= 0xE040 && value <= 0xEBBF) {\n      // Subtract 0xC140 from Shift JIS value\n      value -= 0xC140\n    } else {\n      throw new Error(\n        'Invalid SJIS character: ' + this.data[i] + '\\n' +\n        'Make sure your charset is UTF-8')\n    }\n\n    // Multiply most significant byte of result by 0xC0\n    // and add least significant byte to product\n    value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff)\n\n    // Convert result to a 13-bit binary string\n    bitBuffer.put(value, 13)\n  }\n}\n\nmodule.exports = KanjiData\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/kanji-data.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/mask-pattern.js":
/*!******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/mask-pattern.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Data mask pattern reference\n * @type {Object}\n */\nexports.Patterns = {\n  PATTERN000: 0,\n  PATTERN001: 1,\n  PATTERN010: 2,\n  PATTERN011: 3,\n  PATTERN100: 4,\n  PATTERN101: 5,\n  PATTERN110: 6,\n  PATTERN111: 7\n}\n\n/**\n * Weighted penalty scores for the undesirable features\n * @type {Object}\n */\nconst PenaltyScores = {\n  N1: 3,\n  N2: 3,\n  N3: 40,\n  N4: 10\n}\n\n/**\n * Check if mask pattern value is valid\n *\n * @param  {Number}  mask    Mask pattern\n * @return {Boolean}         true if valid, false otherwise\n */\nexports.isValid = function isValid (mask) {\n  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7\n}\n\n/**\n * Returns mask pattern from a value.\n * If value is not valid, returns undefined\n *\n * @param  {Number|String} value        Mask pattern value\n * @return {Number}                     Valid mask pattern or undefined\n */\nexports.from = function from (value) {\n  return exports.isValid(value) ? parseInt(value, 10) : undefined\n}\n\n/**\n* Find adjacent modules in row/column with the same color\n* and assign a penalty value.\n*\n* Points: N1 + i\n* i is the amount by which the number of adjacent modules of the same color exceeds 5\n*/\nexports.getPenaltyN1 = function getPenaltyN1 (data) {\n  const size = data.size\n  let points = 0\n  let sameCountCol = 0\n  let sameCountRow = 0\n  let lastCol = null\n  let lastRow = null\n\n  for (let row = 0; row < size; row++) {\n    sameCountCol = sameCountRow = 0\n    lastCol = lastRow = null\n\n    for (let col = 0; col < size; col++) {\n      let module = data.get(row, col)\n      if (module === lastCol) {\n        sameCountCol++\n      } else {\n        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n        lastCol = module\n        sameCountCol = 1\n      }\n\n      module = data.get(col, row)\n      if (module === lastRow) {\n        sameCountRow++\n      } else {\n        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n        lastRow = module\n        sameCountRow = 1\n      }\n    }\n\n    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n  }\n\n  return points\n}\n\n/**\n * Find 2x2 blocks with the same color and assign a penalty value\n *\n * Points: N2 * (m - 1) * (n - 1)\n */\nexports.getPenaltyN2 = function getPenaltyN2 (data) {\n  const size = data.size\n  let points = 0\n\n  for (let row = 0; row < size - 1; row++) {\n    for (let col = 0; col < size - 1; col++) {\n      const last = data.get(row, col) +\n        data.get(row, col + 1) +\n        data.get(row + 1, col) +\n        data.get(row + 1, col + 1)\n\n      if (last === 4 || last === 0) points++\n    }\n  }\n\n  return points * PenaltyScores.N2\n}\n\n/**\n * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n * preceded or followed by light area 4 modules wide\n *\n * Points: N3 * number of pattern found\n */\nexports.getPenaltyN3 = function getPenaltyN3 (data) {\n  const size = data.size\n  let points = 0\n  let bitsCol = 0\n  let bitsRow = 0\n\n  for (let row = 0; row < size; row++) {\n    bitsCol = bitsRow = 0\n    for (let col = 0; col < size; col++) {\n      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col)\n      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++\n\n      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row)\n      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++\n    }\n  }\n\n  return points * PenaltyScores.N3\n}\n\n/**\n * Calculate proportion of dark modules in entire symbol\n *\n * Points: N4 * k\n *\n * k is the rating of the deviation of the proportion of dark modules\n * in the symbol from 50% in steps of 5%\n */\nexports.getPenaltyN4 = function getPenaltyN4 (data) {\n  let darkCount = 0\n  const modulesCount = data.data.length\n\n  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i]\n\n  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10)\n\n  return k * PenaltyScores.N4\n}\n\n/**\n * Return mask value at given position\n *\n * @param  {Number} maskPattern Pattern reference value\n * @param  {Number} i           Row\n * @param  {Number} j           Column\n * @return {Boolean}            Mask value\n */\nfunction getMaskAt (maskPattern, i, j) {\n  switch (maskPattern) {\n    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0\n    case exports.Patterns.PATTERN001: return i % 2 === 0\n    case exports.Patterns.PATTERN010: return j % 3 === 0\n    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0\n    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0\n    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0\n    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0\n    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0\n\n    default: throw new Error('bad maskPattern:' + maskPattern)\n  }\n}\n\n/**\n * Apply a mask pattern to a BitMatrix\n *\n * @param  {Number}    pattern Pattern reference number\n * @param  {BitMatrix} data    BitMatrix data\n */\nexports.applyMask = function applyMask (pattern, data) {\n  const size = data.size\n\n  for (let col = 0; col < size; col++) {\n    for (let row = 0; row < size; row++) {\n      if (data.isReserved(row, col)) continue\n      data.xor(row, col, getMaskAt(pattern, row, col))\n    }\n  }\n}\n\n/**\n * Returns the best mask pattern for data\n *\n * @param  {BitMatrix} data\n * @return {Number} Mask pattern reference number\n */\nexports.getBestMask = function getBestMask (data, setupFormatFunc) {\n  const numPatterns = Object.keys(exports.Patterns).length\n  let bestPattern = 0\n  let lowerPenalty = Infinity\n\n  for (let p = 0; p < numPatterns; p++) {\n    setupFormatFunc(p)\n    exports.applyMask(p, data)\n\n    // Calculate penalty\n    const penalty =\n      exports.getPenaltyN1(data) +\n      exports.getPenaltyN2(data) +\n      exports.getPenaltyN3(data) +\n      exports.getPenaltyN4(data)\n\n    // Undo previously applied mask\n    exports.applyMask(p, data)\n\n    if (penalty < lowerPenalty) {\n      lowerPenalty = penalty\n      bestPattern = p\n    }\n  }\n\n  return bestPattern\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/mask-pattern.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/mode.js":
/*!**********************************************!*\
  !*** ./node_modules/qrcode/lib/core/mode.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const VersionCheck = __webpack_require__(/*! ./version-check */ \"./node_modules/qrcode/lib/core/version-check.js\")\nconst Regex = __webpack_require__(/*! ./regex */ \"./node_modules/qrcode/lib/core/regex.js\")\n\n/**\n * Numeric mode encodes data from the decimal digit set (0 - 9)\n * (byte values 30HEX to 39HEX).\n * Normally, 3 data characters are represented by 10 bits.\n *\n * @type {Object}\n */\nexports.NUMERIC = {\n  id: 'Numeric',\n  bit: 1 << 0,\n  ccBits: [10, 12, 14]\n}\n\n/**\n * Alphanumeric mode encodes data from a set of 45 characters,\n * i.e. 10 numeric digits (0 - 9),\n *      26 alphabetic characters (A - Z),\n *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n * Normally, two input characters are represented by 11 bits.\n *\n * @type {Object}\n */\nexports.ALPHANUMERIC = {\n  id: 'Alphanumeric',\n  bit: 1 << 1,\n  ccBits: [9, 11, 13]\n}\n\n/**\n * In byte mode, data is encoded at 8 bits per character.\n *\n * @type {Object}\n */\nexports.BYTE = {\n  id: 'Byte',\n  bit: 1 << 2,\n  ccBits: [8, 16, 16]\n}\n\n/**\n * The Kanji mode efficiently encodes Kanji characters in accordance with\n * the Shift JIS system based on JIS X 0208.\n * The Shift JIS values are shifted from the JIS X 0208 values.\n * JIS X 0208 gives details of the shift coded representation.\n * Each two-byte character value is compacted to a 13-bit binary codeword.\n *\n * @type {Object}\n */\nexports.KANJI = {\n  id: 'Kanji',\n  bit: 1 << 3,\n  ccBits: [8, 10, 12]\n}\n\n/**\n * Mixed mode will contain a sequences of data in a combination of any of\n * the modes described above\n *\n * @type {Object}\n */\nexports.MIXED = {\n  bit: -1\n}\n\n/**\n * Returns the number of bits needed to store the data length\n * according to QR Code specifications.\n *\n * @param  {Mode}   mode    Data mode\n * @param  {Number} version QR Code version\n * @return {Number}         Number of bits\n */\nexports.getCharCountIndicator = function getCharCountIndicator (mode, version) {\n  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)\n\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid version: ' + version)\n  }\n\n  if (version >= 1 && version < 10) return mode.ccBits[0]\n  else if (version < 27) return mode.ccBits[1]\n  return mode.ccBits[2]\n}\n\n/**\n * Returns the most efficient mode to store the specified data\n *\n * @param  {String} dataStr Input data string\n * @return {Mode}           Best mode\n */\nexports.getBestModeForData = function getBestModeForData (dataStr) {\n  if (Regex.testNumeric(dataStr)) return exports.NUMERIC\n  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC\n  else if (Regex.testKanji(dataStr)) return exports.KANJI\n  else return exports.BYTE\n}\n\n/**\n * Return mode name as string\n *\n * @param {Mode} mode Mode object\n * @returns {String}  Mode name\n */\nexports.toString = function toString (mode) {\n  if (mode && mode.id) return mode.id\n  throw new Error('Invalid mode')\n}\n\n/**\n * Check if input param is a valid mode object\n *\n * @param   {Mode}    mode Mode object\n * @returns {Boolean} True if valid mode, false otherwise\n */\nexports.isValid = function isValid (mode) {\n  return mode && mode.bit && mode.ccBits\n}\n\n/**\n * Get mode object from its name\n *\n * @param   {String} string Mode name\n * @returns {Mode}          Mode object\n */\nfunction fromString (string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string')\n  }\n\n  const lcStr = string.toLowerCase()\n\n  switch (lcStr) {\n    case 'numeric':\n      return exports.NUMERIC\n    case 'alphanumeric':\n      return exports.ALPHANUMERIC\n    case 'kanji':\n      return exports.KANJI\n    case 'byte':\n      return exports.BYTE\n    default:\n      throw new Error('Unknown mode: ' + string)\n  }\n}\n\n/**\n * Returns mode from a value.\n * If value is not a valid mode, returns defaultValue\n *\n * @param  {Mode|String} value        Encoding mode\n * @param  {Mode}        defaultValue Fallback value\n * @return {Mode}                     Encoding mode\n */\nexports.from = function from (value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value\n  }\n\n  try {\n    return fromString(value)\n  } catch (e) {\n    return defaultValue\n  }\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/mode.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/numeric-data.js":
/*!******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/numeric-data.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\n\nfunction NumericData (data) {\n  this.mode = Mode.NUMERIC\n  this.data = data.toString()\n}\n\nNumericData.getBitsLength = function getBitsLength (length) {\n  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)\n}\n\nNumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nNumericData.prototype.getBitsLength = function getBitsLength () {\n  return NumericData.getBitsLength(this.data.length)\n}\n\nNumericData.prototype.write = function write (bitBuffer) {\n  let i, group, value\n\n  // The input data string is divided into groups of three digits,\n  // and each group is converted to its 10-bit binary equivalent.\n  for (i = 0; i + 3 <= this.data.length; i += 3) {\n    group = this.data.substr(i, 3)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, 10)\n  }\n\n  // If the number of input digits is not an exact multiple of three,\n  // the final one or two digits are converted to 4 or 7 bits respectively.\n  const remainingNum = this.data.length - i\n  if (remainingNum > 0) {\n    group = this.data.substr(i)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, remainingNum * 3 + 1)\n  }\n}\n\nmodule.exports = NumericData\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/numeric-data.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/polynomial.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/core/polynomial.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const GF = __webpack_require__(/*! ./galois-field */ \"./node_modules/qrcode/lib/core/galois-field.js\")\n\n/**\n * Multiplies two polynomials inside Galois Field\n *\n * @param  {Uint8Array} p1 Polynomial\n * @param  {Uint8Array} p2 Polynomial\n * @return {Uint8Array}    Product of p1 and p2\n */\nexports.mul = function mul (p1, p2) {\n  const coeff = new Uint8Array(p1.length + p2.length - 1)\n\n  for (let i = 0; i < p1.length; i++) {\n    for (let j = 0; j < p2.length; j++) {\n      coeff[i + j] ^= GF.mul(p1[i], p2[j])\n    }\n  }\n\n  return coeff\n}\n\n/**\n * Calculate the remainder of polynomials division\n *\n * @param  {Uint8Array} divident Polynomial\n * @param  {Uint8Array} divisor  Polynomial\n * @return {Uint8Array}          Remainder\n */\nexports.mod = function mod (divident, divisor) {\n  let result = new Uint8Array(divident)\n\n  while ((result.length - divisor.length) >= 0) {\n    const coeff = result[0]\n\n    for (let i = 0; i < divisor.length; i++) {\n      result[i] ^= GF.mul(divisor[i], coeff)\n    }\n\n    // remove all zeros from buffer head\n    let offset = 0\n    while (offset < result.length && result[offset] === 0) offset++\n    result = result.slice(offset)\n  }\n\n  return result\n}\n\n/**\n * Generate an irreducible generator polynomial of specified degree\n * (used by Reed-Solomon encoder)\n *\n * @param  {Number} degree Degree of the generator polynomial\n * @return {Uint8Array}    Buffer containing polynomial coefficients\n */\nexports.generateECPolynomial = function generateECPolynomial (degree) {\n  let poly = new Uint8Array([1])\n  for (let i = 0; i < degree; i++) {\n    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]))\n  }\n\n  return poly\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/polynomial.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/qrcode.js":
/*!************************************************!*\
  !*** ./node_modules/qrcode/lib/core/qrcode.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\")\nconst ECLevel = __webpack_require__(/*! ./error-correction-level */ \"./node_modules/qrcode/lib/core/error-correction-level.js\")\nconst BitBuffer = __webpack_require__(/*! ./bit-buffer */ \"./node_modules/qrcode/lib/core/bit-buffer.js\")\nconst BitMatrix = __webpack_require__(/*! ./bit-matrix */ \"./node_modules/qrcode/lib/core/bit-matrix.js\")\nconst AlignmentPattern = __webpack_require__(/*! ./alignment-pattern */ \"./node_modules/qrcode/lib/core/alignment-pattern.js\")\nconst FinderPattern = __webpack_require__(/*! ./finder-pattern */ \"./node_modules/qrcode/lib/core/finder-pattern.js\")\nconst MaskPattern = __webpack_require__(/*! ./mask-pattern */ \"./node_modules/qrcode/lib/core/mask-pattern.js\")\nconst ECCode = __webpack_require__(/*! ./error-correction-code */ \"./node_modules/qrcode/lib/core/error-correction-code.js\")\nconst ReedSolomonEncoder = __webpack_require__(/*! ./reed-solomon-encoder */ \"./node_modules/qrcode/lib/core/reed-solomon-encoder.js\")\nconst Version = __webpack_require__(/*! ./version */ \"./node_modules/qrcode/lib/core/version.js\")\nconst FormatInfo = __webpack_require__(/*! ./format-info */ \"./node_modules/qrcode/lib/core/format-info.js\")\nconst Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\nconst Segments = __webpack_require__(/*! ./segments */ \"./node_modules/qrcode/lib/core/segments.js\")\n\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern (matrix, version) {\n  const size = matrix.size\n  const pos = FinderPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue\n\n      for (let c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue\n\n        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern (matrix) {\n  const size = matrix.size\n\n  for (let r = 8; r < size - 8; r++) {\n    const value = r % 2 === 0\n    matrix.set(r, 6, value, true)\n    matrix.set(6, r, value, true)\n  }\n}\n\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern (matrix, version) {\n  const pos = AlignmentPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -2; r <= 2; r++) {\n      for (let c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 ||\n          (r === 0 && c === 0)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo (matrix, version) {\n  const size = matrix.size\n  const bits = Version.getEncodedBits(version)\n  let row, col, mod\n\n  for (let i = 0; i < 18; i++) {\n    row = Math.floor(i / 3)\n    col = i % 3 + size - 8 - 3\n    mod = ((bits >> i) & 1) === 1\n\n    matrix.set(row, col, mod, true)\n    matrix.set(col, row, mod, true)\n  }\n}\n\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {\n  const size = matrix.size\n  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)\n  let i, mod\n\n  for (i = 0; i < 15; i++) {\n    mod = ((bits >> i) & 1) === 1\n\n    // vertical\n    if (i < 6) {\n      matrix.set(i, 8, mod, true)\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true)\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true)\n    }\n\n    // horizontal\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true)\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true)\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true)\n    }\n  }\n\n  // fixed module\n  matrix.set(size - 8, 8, 1, true)\n}\n\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix}  matrix Modules matrix\n * @param  {Uint8Array} data   Data codewords\n */\nfunction setupData (matrix, data) {\n  const size = matrix.size\n  let inc = -1\n  let row = size - 1\n  let bitIndex = 7\n  let byteIndex = 0\n\n  for (let col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--\n\n    while (true) {\n      for (let c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          let dark = false\n\n          if (byteIndex < data.length) {\n            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)\n          }\n\n          matrix.set(row, col - c, dark)\n          bitIndex--\n\n          if (bitIndex === -1) {\n            byteIndex++\n            bitIndex = 7\n          }\n        }\n      }\n\n      row += inc\n\n      if (row < 0 || size <= row) {\n        row -= inc\n        inc = -inc\n        break\n      }\n    }\n  }\n}\n\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Uint8Array}                    Buffer containing encoded codewords\n */\nfunction createData (version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  const buffer = new BitBuffer()\n\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4)\n\n    // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))\n\n    // add binary data sequence to buffer\n    data.write(buffer)\n  })\n\n  // Calculate required number of bits\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4)\n  }\n\n  // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0)\n  }\n\n  // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8\n  for (let i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8)\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel)\n}\n\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Uint8Array}                     Buffer containing encoded codewords\n */\nfunction createCodewords (bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewords = totalCodewords - ecTotalCodewords\n\n  // Total number of blocks\n  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)\n\n  // Calculate how many blocks each group should contain\n  const blocksInGroup2 = totalCodewords % ecTotalBlocks\n  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2\n\n  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)\n\n  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)\n  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1\n\n  // Number of EC codewords is the same for both groups\n  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1\n\n  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n  const rs = new ReedSolomonEncoder(ecCount)\n\n  let offset = 0\n  const dcData = new Array(ecTotalBlocks)\n  const ecData = new Array(ecTotalBlocks)\n  let maxDataSize = 0\n  const buffer = new Uint8Array(bitBuffer.buffer)\n\n  // Divide the buffer into the required number of blocks\n  for (let b = 0; b < ecTotalBlocks; b++) {\n    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2\n\n    // extract a block of data from buffer\n    dcData[b] = buffer.slice(offset, offset + dataSize)\n\n    // Calculate EC codewords for this data block\n    ecData[b] = rs.encode(dcData[b])\n\n    offset += dataSize\n    maxDataSize = Math.max(maxDataSize, dataSize)\n  }\n\n  // Create final data\n  // Interleave the data and error correction codewords from each block\n  const data = new Uint8Array(totalCodewords)\n  let index = 0\n  let i, r\n\n  // Add data codewords\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i]\n      }\n    }\n  }\n\n  // Apped EC codewords\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i]\n    }\n  }\n\n  return data\n}\n\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol (data, version, errorCorrectionLevel, maskPattern) {\n  let segments\n\n  if (Array.isArray(data)) {\n    segments = Segments.fromArray(data)\n  } else if (typeof data === 'string') {\n    let estimatedVersion = version\n\n    if (!estimatedVersion) {\n      const rawSegments = Segments.rawSplit(data)\n\n      // Estimate best version that can contain raw splitted segments\n      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel)\n    }\n\n    // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n    segments = Segments.fromString(data, estimatedVersion || 40)\n  } else {\n    throw new Error('Invalid data')\n  }\n\n  // Get the min version that can contain data\n  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel)\n\n  // If no version is found, data cannot be stored\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code')\n  }\n\n  // If not specified, use min version as default\n  if (!version) {\n    version = bestVersion\n\n  // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' +\n      'The chosen QR Code version cannot contain this amount of data.\\n' +\n      'Minimum version required to store current data is: ' + bestVersion + '.\\n'\n    )\n  }\n\n  const dataBits = createData(version, errorCorrectionLevel, segments)\n\n  // Allocate matrix buffer\n  const moduleCount = Utils.getSymbolSize(version)\n  const modules = new BitMatrix(moduleCount)\n\n  // Add function modules\n  setupFinderPattern(modules, version)\n  setupTimingPattern(modules)\n  setupAlignmentPattern(modules, version)\n\n  // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n  setupFormatInfo(modules, errorCorrectionLevel, 0)\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version)\n  }\n\n  // Add data codewords\n  setupData(modules, dataBits)\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules,\n      setupFormatInfo.bind(null, modules, errorCorrectionLevel))\n  }\n\n  // Apply mask pattern\n  MaskPattern.applyMask(maskPattern, modules)\n\n  // Replace format info bits with correct values\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)\n\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  }\n}\n\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nexports.create = function create (data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text')\n  }\n\n  let errorCorrectionLevel = ECLevel.M\n  let version\n  let mask\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)\n    version = Version.from(options.version)\n    mask = MaskPattern.from(options.maskPattern)\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc)\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask)\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/qrcode.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/reed-solomon-encoder.js":
/*!**************************************************************!*\
  !*** ./node_modules/qrcode/lib/core/reed-solomon-encoder.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Polynomial = __webpack_require__(/*! ./polynomial */ \"./node_modules/qrcode/lib/core/polynomial.js\")\n\nfunction ReedSolomonEncoder (degree) {\n  this.genPoly = undefined\n  this.degree = degree\n\n  if (this.degree) this.initialize(this.degree)\n}\n\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize (degree) {\n  // create an irreducible generator polynomial\n  this.degree = degree\n  this.genPoly = Polynomial.generateECPolynomial(this.degree)\n}\n\n/**\n * Encodes a chunk of data\n *\n * @param  {Uint8Array} data Buffer containing input data\n * @return {Uint8Array}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode (data) {\n  if (!this.genPoly) {\n    throw new Error('Encoder not initialized')\n  }\n\n  // Calculate EC for this data block\n  // extends data size to data+genPoly size\n  const paddedData = new Uint8Array(data.length + this.degree)\n  paddedData.set(data)\n\n  // The error correction codewords are the remainder after dividing the data codewords\n  // by a generator polynomial\n  const remainder = Polynomial.mod(paddedData, this.genPoly)\n\n  // return EC data blocks (last n byte, where n is the degree of genPoly)\n  // If coefficients number in remainder are less than genPoly degree,\n  // pad with 0s to the left to reach the needed number of coefficients\n  const start = this.degree - remainder.length\n  if (start > 0) {\n    const buff = new Uint8Array(this.degree)\n    buff.set(remainder, start)\n\n    return buff\n  }\n\n  return remainder\n}\n\nmodule.exports = ReedSolomonEncoder\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/reed-solomon-encoder.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/regex.js":
/*!***********************************************!*\
  !*** ./node_modules/qrcode/lib/core/regex.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("const numeric = '[0-9]+'\nconst alphanumeric = '[A-Z $%*+\\\\-./:]+'\nlet kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +\n  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +\n  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +\n  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+'\nkanji = kanji.replace(/u/g, '\\\\u')\n\nconst byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+'\n\nexports.KANJI = new RegExp(kanji, 'g')\nexports.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g')\nexports.BYTE = new RegExp(byte, 'g')\nexports.NUMERIC = new RegExp(numeric, 'g')\nexports.ALPHANUMERIC = new RegExp(alphanumeric, 'g')\n\nconst TEST_KANJI = new RegExp('^' + kanji + '$')\nconst TEST_NUMERIC = new RegExp('^' + numeric + '$')\nconst TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$')\n\nexports.testKanji = function testKanji (str) {\n  return TEST_KANJI.test(str)\n}\n\nexports.testNumeric = function testNumeric (str) {\n  return TEST_NUMERIC.test(str)\n}\n\nexports.testAlphanumeric = function testAlphanumeric (str) {\n  return TEST_ALPHANUMERIC.test(str)\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/regex.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/segments.js":
/*!**************************************************!*\
  !*** ./node_modules/qrcode/lib/core/segments.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\nconst NumericData = __webpack_require__(/*! ./numeric-data */ \"./node_modules/qrcode/lib/core/numeric-data.js\")\nconst AlphanumericData = __webpack_require__(/*! ./alphanumeric-data */ \"./node_modules/qrcode/lib/core/alphanumeric-data.js\")\nconst ByteData = __webpack_require__(/*! ./byte-data */ \"./node_modules/qrcode/lib/core/byte-data.js\")\nconst KanjiData = __webpack_require__(/*! ./kanji-data */ \"./node_modules/qrcode/lib/core/kanji-data.js\")\nconst Regex = __webpack_require__(/*! ./regex */ \"./node_modules/qrcode/lib/core/regex.js\")\nconst Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\")\nconst dijkstra = __webpack_require__(/*! dijkstrajs */ \"./node_modules/dijkstrajs/dijkstra.js\")\n\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\nfunction getStringByteLength (str) {\n  return unescape(encodeURIComponent(str)).length\n}\n\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\nfunction getSegments (regex, mode, str) {\n  const segments = []\n  let result\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    })\n  }\n\n  return segments\n}\n\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\nfunction getSegmentsFromString (dataStr) {\n  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n  let byteSegs\n  let kanjiSegs\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n    kanjiSegs = []\n  }\n\n  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n  return segs\n    .sort(function (s1, s2) {\n      return s1.index - s2.index\n    })\n    .map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      }\n    })\n}\n\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\nfunction getSegmentBitsLength (length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length)\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length)\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length)\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length)\n  }\n}\n\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction mergeSegments (segs) {\n  return segs.reduce(function (acc, curr) {\n    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data\n      return acc\n    }\n\n    acc.push(curr)\n    return acc\n  }, [])\n}\n\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction buildNodes (segs) {\n  const nodes = []\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i]\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.KANJI:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n        break\n      case Mode.BYTE:\n        nodes.push([\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n    }\n  }\n\n  return nodes\n}\n\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\nfunction buildGraph (nodes, version) {\n  const table = {}\n  const graph = { start: {} }\n  let prevNodeIds = ['start']\n\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeGroup = nodes[i]\n    const currentNodeIds = []\n\n    for (let j = 0; j < nodeGroup.length; j++) {\n      const node = nodeGroup[j]\n      const key = '' + i + j\n\n      currentNodeIds.push(key)\n      table[key] = { node: node, lastCount: 0 }\n      graph[key] = {}\n\n      for (let n = 0; n < prevNodeIds.length; n++) {\n        const prevNodeId = prevNodeIds[n]\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] =\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n          table[prevNodeId].lastCount += node.length\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds\n  }\n\n  for (let n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]].end = 0\n  }\n\n  return { map: graph, table: table }\n}\n\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\nfunction buildSingleSegment (data, modesHint) {\n  let mode\n  const bestMode = Mode.getBestModeForData(data)\n\n  mode = Mode.from(modesHint, bestMode)\n\n  // Make sure data can be encoded\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' +\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n  }\n\n  // Use Mode.BYTE if Kanji support is disabled\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data)\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data)\n\n    case Mode.KANJI:\n      return new KanjiData(data)\n\n    case Mode.BYTE:\n      return new ByteData(data)\n  }\n}\n\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\nexports.fromArray = function fromArray (array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null))\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode))\n    }\n\n    return acc\n  }, [])\n}\n\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\nexports.fromString = function fromString (data, version) {\n  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n  const nodes = buildNodes(segs)\n  const graph = buildGraph(nodes, version)\n  const path = dijkstra.find_path(graph.map, 'start', 'end')\n\n  const optimizedSegs = []\n  for (let i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node)\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs))\n}\n\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\nexports.rawSplit = function rawSplit (data) {\n  return exports.fromArray(\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n  )\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/segments.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/qrcode/lib/core/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("let toSJISFunction\nconst CODEWORDS_COUNT = [\n  0, // Not used\n  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,\n  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,\n  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706\n]\n\n/**\n * Returns the QR Code size for the specified version\n *\n * @param  {Number} version QR Code version\n * @return {Number}         size of QR code\n */\nexports.getSymbolSize = function getSymbolSize (version) {\n  if (!version) throw new Error('\"version\" cannot be null or undefined')\n  if (version < 1 || version > 40) throw new Error('\"version\" should be in range from 1 to 40')\n  return version * 4 + 17\n}\n\n/**\n * Returns the total number of codewords used to store data and EC information.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Data length in bits\n */\nexports.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {\n  return CODEWORDS_COUNT[version]\n}\n\n/**\n * Encode data with Bose-Chaudhuri-Hocquenghem\n *\n * @param  {Number} data Value to encode\n * @return {Number}      Encoded value\n */\nexports.getBCHDigit = function (data) {\n  let digit = 0\n\n  while (data !== 0) {\n    digit++\n    data >>>= 1\n  }\n\n  return digit\n}\n\nexports.setToSJISFunction = function setToSJISFunction (f) {\n  if (typeof f !== 'function') {\n    throw new Error('\"toSJISFunc\" is not a valid function.')\n  }\n\n  toSJISFunction = f\n}\n\nexports.isKanjiModeEnabled = function () {\n  return typeof toSJISFunction !== 'undefined'\n}\n\nexports.toSJIS = function toSJIS (kanji) {\n  return toSJISFunction(kanji)\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/utils.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/version-check.js":
/*!*******************************************************!*\
  !*** ./node_modules/qrcode/lib/core/version-check.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Check if QR Code version is valid\n *\n * @param  {Number}  version QR Code version\n * @return {Boolean}         true if valid version, false otherwise\n */\nexports.isValid = function isValid (version) {\n  return !isNaN(version) && version >= 1 && version <= 40\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/version-check.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/core/version.js":
/*!*************************************************!*\
  !*** ./node_modules/qrcode/lib/core/version.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/core/utils.js\")\nconst ECCode = __webpack_require__(/*! ./error-correction-code */ \"./node_modules/qrcode/lib/core/error-correction-code.js\")\nconst ECLevel = __webpack_require__(/*! ./error-correction-level */ \"./node_modules/qrcode/lib/core/error-correction-level.js\")\nconst Mode = __webpack_require__(/*! ./mode */ \"./node_modules/qrcode/lib/core/mode.js\")\nconst VersionCheck = __webpack_require__(/*! ./version-check */ \"./node_modules/qrcode/lib/core/version-check.js\")\n\n// Generator polynomial used to encode version information\nconst G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)\nconst G18_BCH = Utils.getBCHDigit(G18)\n\nfunction getBestVersionForDataLength (mode, length, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\nfunction getReservedBitsCount (mode, version) {\n  // Character count indicator + mode indicator bits\n  return Mode.getCharCountIndicator(mode, version) + 4\n}\n\nfunction getTotalBitsFromDataArray (segments, version) {\n  let totalBits = 0\n\n  segments.forEach(function (data) {\n    const reservedBits = getReservedBitsCount(data.mode, version)\n    totalBits += reservedBits + data.getBitsLength()\n  })\n\n  return totalBits\n}\n\nfunction getBestVersionForMixedData (segments, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    const length = getTotalBitsFromDataArray(segments, currentVersion)\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns version number from a value.\n * If value is not a valid version, returns defaultValue\n *\n * @param  {Number|String} value        QR Code version\n * @param  {Number}        defaultValue Fallback value\n * @return {Number}                     QR Code version number\n */\nexports.from = function from (value, defaultValue) {\n  if (VersionCheck.isValid(value)) {\n    return parseInt(value, 10)\n  }\n\n  return defaultValue\n}\n\n/**\n * Returns how much data can be stored with the specified QR code version\n * and error correction level\n *\n * @param  {Number} version              QR Code version (1-40)\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Mode}   mode                 Data mode\n * @return {Number}                      Quantity of storable data\n */\nexports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  // Use Byte mode as default\n  if (typeof mode === 'undefined') mode = Mode.BYTE\n\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  if (mode === Mode.MIXED) return dataTotalCodewordsBits\n\n  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)\n\n  // Return max number of storable codewords\n  switch (mode) {\n    case Mode.NUMERIC:\n      return Math.floor((usableBits / 10) * 3)\n\n    case Mode.ALPHANUMERIC:\n      return Math.floor((usableBits / 11) * 2)\n\n    case Mode.KANJI:\n      return Math.floor(usableBits / 13)\n\n    case Mode.BYTE:\n    default:\n      return Math.floor(usableBits / 8)\n  }\n}\n\n/**\n * Returns the minimum version needed to contain the amount of data\n *\n * @param  {Segment} data                    Segment of data\n * @param  {Number} [errorCorrectionLevel=H] Error correction level\n * @param  {Mode} mode                       Data mode\n * @return {Number}                          QR Code version\n */\nexports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {\n  let seg\n\n  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)\n\n  if (Array.isArray(data)) {\n    if (data.length > 1) {\n      return getBestVersionForMixedData(data, ecl)\n    }\n\n    if (data.length === 0) {\n      return 1\n    }\n\n    seg = data[0]\n  } else {\n    seg = data\n  }\n\n  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)\n}\n\n/**\n * Returns version information with relative error correction bits\n *\n * The version information is included in QR Code symbols of version 7 or larger.\n * It consists of an 18-bit sequence containing 6 data bits,\n * with 12 error correction bits calculated using the (18, 6) Golay code.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Encoded version info bits\n */\nexports.getEncodedBits = function getEncodedBits (version) {\n  if (!VersionCheck.isValid(version) || version < 7) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  let d = version << 12\n\n  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))\n  }\n\n  return (version << 12) | d\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/core/version.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/renderer/canvas.js":
/*!****************************************************!*\
  !*** ./node_modules/qrcode/lib/renderer/canvas.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/renderer/utils.js\")\n\nfunction clearCanvas (ctx, canvas, size) {\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n  if (!canvas.style) canvas.style = {}\n  canvas.height = size\n  canvas.width = size\n  canvas.style.height = size + 'px'\n  canvas.style.width = size + 'px'\n}\n\nfunction getCanvasElement () {\n  try {\n    return document.createElement('canvas')\n  } catch (e) {\n    throw new Error('You need to specify a canvas element')\n  }\n}\n\nexports.render = function render (qrData, canvas, options) {\n  let opts = options\n  let canvasEl = canvas\n\n  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n    opts = canvas\n    canvas = undefined\n  }\n\n  if (!canvas) {\n    canvasEl = getCanvasElement()\n  }\n\n  opts = Utils.getOptions(opts)\n  const size = Utils.getImageWidth(qrData.modules.size, opts)\n\n  const ctx = canvasEl.getContext('2d')\n  const image = ctx.createImageData(size, size)\n  Utils.qrToImageData(image.data, qrData, opts)\n\n  clearCanvas(ctx, canvasEl, size)\n  ctx.putImageData(image, 0, 0)\n\n  return canvasEl\n}\n\nexports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {\n  let opts = options\n\n  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n    opts = canvas\n    canvas = undefined\n  }\n\n  if (!opts) opts = {}\n\n  const canvasEl = exports.render(qrData, canvas, opts)\n\n  const type = opts.type || 'image/png'\n  const rendererOpts = opts.rendererOpts || {}\n\n  return canvasEl.toDataURL(type, rendererOpts.quality)\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/renderer/canvas.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/renderer/svg-tag.js":
/*!*****************************************************!*\
  !*** ./node_modules/qrcode/lib/renderer/svg-tag.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Utils = __webpack_require__(/*! ./utils */ \"./node_modules/qrcode/lib/renderer/utils.js\")\n\nfunction getColorAttrib (color, attrib) {\n  const alpha = color.a / 255\n  const str = attrib + '=\"' + color.hex + '\"'\n\n  return alpha < 1\n    ? str + ' ' + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"'\n    : str\n}\n\nfunction svgCmd (cmd, x, y) {\n  let str = cmd + x\n  if (typeof y !== 'undefined') str += ' ' + y\n\n  return str\n}\n\nfunction qrToPath (data, size, margin) {\n  let path = ''\n  let moveBy = 0\n  let newRow = false\n  let lineLength = 0\n\n  for (let i = 0; i < data.length; i++) {\n    const col = Math.floor(i % size)\n    const row = Math.floor(i / size)\n\n    if (!col && !newRow) newRow = true\n\n    if (data[i]) {\n      lineLength++\n\n      if (!(i > 0 && col > 0 && data[i - 1])) {\n        path += newRow\n          ? svgCmd('M', col + margin, 0.5 + row + margin)\n          : svgCmd('m', moveBy, 0)\n\n        moveBy = 0\n        newRow = false\n      }\n\n      if (!(col + 1 < size && data[i + 1])) {\n        path += svgCmd('h', lineLength)\n        lineLength = 0\n      }\n    } else {\n      moveBy++\n    }\n  }\n\n  return path\n}\n\nexports.render = function render (qrData, options, cb) {\n  const opts = Utils.getOptions(options)\n  const size = qrData.modules.size\n  const data = qrData.modules.data\n  const qrcodesize = size + opts.margin * 2\n\n  const bg = !opts.color.light.a\n    ? ''\n    : '<path ' + getColorAttrib(opts.color.light, 'fill') +\n      ' d=\"M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z\"/>'\n\n  const path =\n    '<path ' + getColorAttrib(opts.color.dark, 'stroke') +\n    ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>'\n\n  const viewBox = 'viewBox=\"' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '\"'\n\n  const width = !opts.width ? '' : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" '\n\n  const svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + '</svg>\\n'\n\n  if (typeof cb === 'function') {\n    cb(null, svgTag)\n  }\n\n  return svgTag\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/renderer/svg-tag.js?");

/***/ }),

/***/ "./node_modules/qrcode/lib/renderer/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/qrcode/lib/renderer/utils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("function hex2rgba (hex) {\n  if (typeof hex === 'number') {\n    hex = hex.toString()\n  }\n\n  if (typeof hex !== 'string') {\n    throw new Error('Color should be defined as hex string')\n  }\n\n  let hexCode = hex.slice().replace('#', '').split('')\n  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n    throw new Error('Invalid hex color: ' + hex)\n  }\n\n  // Convert from short to long form (fff -> ffffff)\n  if (hexCode.length === 3 || hexCode.length === 4) {\n    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n      return [c, c]\n    }))\n  }\n\n  // Add default alpha value\n  if (hexCode.length === 6) hexCode.push('F', 'F')\n\n  const hexValue = parseInt(hexCode.join(''), 16)\n\n  return {\n    r: (hexValue >> 24) & 255,\n    g: (hexValue >> 16) & 255,\n    b: (hexValue >> 8) & 255,\n    a: hexValue & 255,\n    hex: '#' + hexCode.slice(0, 6).join('')\n  }\n}\n\nexports.getOptions = function getOptions (options) {\n  if (!options) options = {}\n  if (!options.color) options.color = {}\n\n  const margin = typeof options.margin === 'undefined' ||\n    options.margin === null ||\n    options.margin < 0\n    ? 4\n    : options.margin\n\n  const width = options.width && options.width >= 21 ? options.width : undefined\n  const scale = options.scale || 4\n\n  return {\n    width: width,\n    scale: width ? 4 : scale,\n    margin: margin,\n    color: {\n      dark: hex2rgba(options.color.dark || '#000000ff'),\n      light: hex2rgba(options.color.light || '#ffffffff')\n    },\n    type: options.type,\n    rendererOpts: options.rendererOpts || {}\n  }\n}\n\nexports.getScale = function getScale (qrSize, opts) {\n  return opts.width && opts.width >= qrSize + opts.margin * 2\n    ? opts.width / (qrSize + opts.margin * 2)\n    : opts.scale\n}\n\nexports.getImageWidth = function getImageWidth (qrSize, opts) {\n  const scale = exports.getScale(qrSize, opts)\n  return Math.floor((qrSize + opts.margin * 2) * scale)\n}\n\nexports.qrToImageData = function qrToImageData (imgData, qr, opts) {\n  const size = qr.modules.size\n  const data = qr.modules.data\n  const scale = exports.getScale(size, opts)\n  const symbolSize = Math.floor((size + opts.margin * 2) * scale)\n  const scaledMargin = opts.margin * scale\n  const palette = [opts.color.light, opts.color.dark]\n\n  for (let i = 0; i < symbolSize; i++) {\n    for (let j = 0; j < symbolSize; j++) {\n      let posDst = (i * symbolSize + j) * 4\n      let pxColor = opts.color.light\n\n      if (i >= scaledMargin && j >= scaledMargin &&\n        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n        const iSrc = Math.floor((i - scaledMargin) / scale)\n        const jSrc = Math.floor((j - scaledMargin) / scale)\n        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0]\n      }\n\n      imgData[posDst++] = pxColor.r\n      imgData[posDst++] = pxColor.g\n      imgData[posDst++] = pxColor.b\n      imgData[posDst] = pxColor.a\n    }\n  }\n}\n\n\n//# sourceURL=webpack://speakerCalibrator/./node_modules/qrcode/lib/renderer/utils.js?");

/***/ }),

/***/ "./src/audioCalibrator.js":
/*!********************************!*\
  !*** ./src/audioCalibrator.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _audioRecorder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audioRecorder */ \"./src/audioRecorder.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _mlsGen_mlsGenInterface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mlsGen/mlsGenInterface */ \"./src/mlsGen/mlsGenInterface.js\");\n/* harmony import */ var _myCharts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./myCharts */ \"./src/myCharts.js\");\n\n\n\n\n\n/**\n * Provides methods for calibrating the user's speakers\n * @extends AudioRecorder\n */\nclass AudioCalibrator extends _audioRecorder__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  /** @private */\n  #isCalibrating = false;\n\n  /** @private */\n  #sourceAudio;\n\n  /** @private */\n  #sourceAudioContext;\n\n  /** @private */\n  #sourceAudioAnalyser;\n\n  /** @private */\n  #sinkAudioContext;\n\n  /** @private */\n  #sinkAudioAnalyser;\n\n  /** @private */\n  #mlsGenInterface;\n\n  /** @private */\n  #mlsBufferView;\n\n  /** @private */\n  #numCalibratingRounds = 1;\n\n  /** @private */\n  #sinkSamplingRate;\n\n  /** @private */\n  #sourceSamplingRate;\n\n  /**\n   * Called when a call is received.\n   * Creates a local audio DOM element and attaches it to the page.\n   */\n  createLocalAudio = targetElement => {\n    const localAudio = document.createElement('audio');\n    localAudio.setAttribute('id', 'localAudio');\n    targetElement.appendChild(localAudio);\n  };\n\n  #setSourceAudio = () => {\n    this.#sourceAudioContext = new (window.AudioContext ||\n      window.webkitAudioContext ||\n      window.audioContext)();\n    this.#sourceSamplingRate = this.#sourceAudioContext.sampleRate;\n  };\n\n  /**\n   * Creates an audio context and plays it for a few seconds.\n   * @private\n   * @returns {Promise} - Resolves when the audio is done playing.\n   */\n  #playCalibrationAudio = async () => {\n    const buffer = this.#sourceAudioContext.createBuffer(\n      1, // number of channels\n      this.#mlsBufferView.length, // length\n      this.#sourceSamplingRate // sample rate\n    );\n    const data = buffer.getChannelData(0); // get data\n    // fill the buffer with our data\n    try {\n      for (let i = 0; i < this.#mlsBufferView.length; i += 1) {\n        data[i] = this.#mlsBufferView[i];\n      }\n    } catch (error) {\n      console.error(error);\n    }\n\n    console.log(buffer.getChannelData(0));\n\n    const source = this.#sourceAudioContext.createBufferSource();\n    source.buffer = buffer;\n    source.connect(this.#sourceAudioContext.destination);\n    source.start(0);\n\n    await (0,_utils__WEBPACK_IMPORTED_MODULE_1__.sleep)(buffer.duration);\n  };\n\n  /**\n   * Getter for the isCalibrating property.\n   * @public\n   * @returns {Boolean} - True if the audio is being calibrated, false otherwise.\n   */\n  getCalibrationStatus = () => this.#isCalibrating;\n\n  /**\n   * Create a sink audio context and attach it to the stream\n   * @param {*} stream\n   */\n  #setSinkAudio = stream => {\n    this.#sinkAudioContext = new (window.AudioContext ||\n      window.webkitAudioContext ||\n      window.audioContext)();\n    this.#sinkAudioAnalyser = this.#sinkAudioContext.createAnalyser();\n    const source = this.#sinkAudioContext.createMediaStreamSource(stream);\n    source.connect(this.#sinkAudioAnalyser);\n    // visualize(this.#sinkAudioAnalyser);\n  };\n\n  /**\n   * Set the sink audio sampling rate to the given value\n   * @param {*} sinkSamplingRate\n   */\n  setSinkSamplingRate = sinkSamplingRate => {\n    this.#sinkSamplingRate = sinkSamplingRate;\n  };\n\n  /**\n   *\n   * @param {*} stream\n   */\n  #calibrationSteps = async stream => {\n    this.#mlsBufferView = this.#mlsGenInterface.getMLS();\n    this.generatedMLSChart = new _myCharts__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\n      'generated-signal-chart',\n      'generated mls',\n      'generated mls',\n      this.#mlsBufferView\n    );\n\n    let numRounds = 0;\n\n    // calibration loop\n    while (!this.#isCalibrating && numRounds < this.#numCalibratingRounds) {\n      // start recording\n      this.startRecording(stream);\n      // play calibration audio\n      console.log(`Calibration Round ${numRounds}`);\n      // eslint-disable-next-line no-await-in-loop\n      await this.#playCalibrationAudio().then(() => {\n        // when done, stop recording\n        console.log('Calibration Round Complete');\n        this.stopRecording();\n      });\n      // eslint-disable-next-line no-await-in-loop\n      await (0,_utils__WEBPACK_IMPORTED_MODULE_1__.sleep)(2);\n      numRounds += 1;\n    }\n\n    console.log('Setting Recorded Signal');\n    this.#mlsGenInterface.setRecordedSignal();\n    this.caputuredMLSChart = new _myCharts__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\n      'captured-signal-chart',\n      'captured mls',\n      'captured mls',\n      this.getRecordedSignals(0)\n    );\n    const IR = this.#mlsGenInterface.getImpulseResponse();\n    this.IRChart = new _myCharts__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('ir-chart', 'ir', 'impulse response', IR);\n    console.log('TEST IR: ', IR);\n  };\n\n  /**\n   * Public method to start the calibration process. Objects intialized from webassembly allocate new memory\n   * and must be manually freed. This function is responsible for intializing the MlsGenInterface,\n   * and wrapping the calibration steps with a garbage collection safe gaurd.\n   * @public\n   * @param {MediaStream} stream - The stream of audio from the Listener.\n   */\n  startCalibration = async stream => {\n    this.#setSourceAudio();\n    this.#setSinkAudio(stream);\n    // initialize the MLSGenInterface object with it's factory method\n    await _mlsGen_mlsGenInterface__WEBPACK_IMPORTED_MODULE_2__[\"default\"].factory(this.#sourceSamplingRate, this.#sinkSamplingRate).then(\n      mlsGenInterface => {\n        this.#mlsGenInterface = mlsGenInterface;\n        console.log('mlsGenInterface', this.#mlsGenInterface);\n      }\n    );\n    // after intializating, start the calibration steps with garbage collection\n    this.#mlsGenInterface.withGarbageCollection(this.#calibrationSteps, [stream]);\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AudioCalibrator);\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/audioCalibrator.js?");

/***/ }),

/***/ "./src/audioPeer.js":
/*!**************************!*\
  !*** ./src/audioPeer.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! peerjs */ \"./node_modules/peerjs/dist/peerjs.min.js\");\n/* harmony import */ var peerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(peerjs__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// TODO: this was already here before, but appears to be unused\nconst pressFeedbackURI =\n  'data:audio/mpeg;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAALAAATlgAXFxcXFxcXFxcuLi4uLi4uLi5FRUVFRUVFRUVdXV1dXV1dXV10dHR0dHR0dHSLi4uLi4uLi4uioqKioqKioqK6urq6urq6urrR0dHR0dHR0dHo6Ojo6Ojo6Oj///////////8AAAA5TEFNRTMuMTAwAaoAAAAALgYAABSAJAZbTgAAgAAAE5YfafL/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//uQZAAAA0YVyhVvQAAAAA0goAABGfWdITn6gAgAADSDAAAAAEWjAwMwMDMFBzCQsw8PMPCwUDgkNMpNzXEoSUTP3s6nJPd4z28k62JNdIwIUHj3nvynRempMmLAo/tff9/3IchyHIch/IxY3SUmG86enD4Pg+fgmfEAIQQcsP+oH//E7/+Ud/1HP/B9AAABMCFFFAAAwDgCyMCVAgQcBQmARAHw0AOGAUgFJgUoL8YKsEvqzGA1APJQAIGBNgDpoBRvQYb6EIGhIkmJg1QA0aH0H4GDBgJ4G55UBpM1AGgUG0wAgOBIUAYJGoGFQ4AkHitxzRSocGMwDYYCwJAWAICgBD8jhwlEqBNsMiAkCBpQY2FxpG61opmucDLrjKi6Fmk5oK9PWVh1DNFM2IaRH/q8mTQgTF4sk0bnv//zEuqRMjYycuuj///5wxZzIvLSMTUxYyZL////86ZBqh4D+QUIABcwBQBLMCmAeTA4wJowO8E2DAeYwQ8CWMDLBHDB1QpIxscoSMwBQJj/WZBA3O4mFMHIAGzAKAVgwmcG8OIV//uSZCIN9VQ4wgd/gAAAAA0g4AABD+S/Di5+qgAAADSAAAAEEzcNTC4yM0m41SLDHAJLSggBKwtKRwb6+IBi4ctbepDskh2KmAgA16NTNrON66ptO40mNa9ayZHVx7zmGPHktZb7vP9xLn4fr+9jeO//8P+z39///9T/////t+d6vf1+c6fP9Hv5cxg4aA4TgkGIYmLbYHGAxaCjHwlM0lwBC4zGwzVG+MFnGoTY8sn0w1MSHA09vAM8ssDCSYAykIABmeCI4AKDMDIRfGbFAjWE8h+BfIEfBoFCTQJUcA5ZIrQDjzQ+gWzxsjDLtE4s46kxjHZZom2SXfyj6uadvNvb0ee/3dX//01YAVKw/FoW3hDrwUDTAwDMVigy8rTYaRNKug2tzzBwxnAx/DOuMhFECAOxWsDO6kAwkdQFH0BiwIgYlAwCgdAwiZBBI1kCC5JcWwCQWMQ/JQnkVFkOVN8oku8yDkjbMiry+2rrLvW/MvT53q/yv+n2///dywQL8DRgOgsrBBi0LGcngZrCZgYxGEAoZ+IplUdGJ1ifHVRh5v/7kmRMDPOhJ0MTn6qAAAANIAAAARDEiQhOf0pAAAA0gAAABAdCcEnCwmbqA1JhbIFwYKEAUGAXgOJo45oXAyjT0MinMgXM2UNoNGyYeLN0ENORMgQC5EYAJlr4Z3L3lgaHG5VO0lWX1q92J3t9sWM+bu9/fe8/VT/L+zq9v+zr9/+//8r71SAAAA9tq0AA1hzXXdxmzgPWzJyU20wh4EDDUSzWI4x4rgMGBd+IImDoAiEBAMCJn2HpqAlRpDIZhbxxp2ASQcGVRJG6RC4xmaZHiYlYPKGGdEGJjIoa4YtICXGHRhGJg2QMkYJADRGfCMTZE5+4ze1gMF1k163DfQrNgh83G3zIYoMdC4wEOwcrzMxMMam0AlYxkKzOgqMDhUuUBgYIQOWiEgwYHAogAwXBAYHAKAVVm0ZW2J1Wno9taaAzuOSF34AjMUjdBOy+pjbpKCil9TG/hOWRkUkxad2pAAAGFlrIADgyUqh1syPqzGQRoUAEDDoFgKMDw7MVA2NJ1sKHaMVghBwfGAgOgJR0migMTBUODDQezBI5jGNQzXD/+5JkjYD20jDN67/kngAADSAAAAEXjN0dTv9SAAAANIAAAASwgEb7HKvHZpiFAM0Bgs8wPYBNNi8MMfMIKRGRlOETOErM6wMGpBTQHTjJEQaKEBoKmlLXGizd5Ax5W2Byh0X6R9YRJ2rQFSKzgZDB0DQDKJHDr/MoZRDsaleN+vVhpoVqzczvZYx+Hdbx1/MuWOZb///Vr1YX93I/6P9KAWAQE8pFZWkOCuFAO0EEAThJ4OYwBQMHIJgUUVrHHRwaURUkZ4YX6MYvO6EDvpgTJY6aVeR7mGcgzBgfQE2YCuA5H9adJQKBCAhAqA53/aS/bk0T1zjIhpmcjVumpqS/ZZ1v6TuOXxF1+49x5d5Knl/Luvw7ua/8P/DdWT+dOkhD5zhvqb0db/93/5AQAQsF3glyO4MAysKti2BGAAdE0L31C4EMAhEAgAu28hgMOFHwEgaYACAFHpko0GM0ia2Yx0/wmKECIhpq5poYK2CTmAQAMhgAQBKYAoARFUAhUQbKhIMAxAFG3eFpLns4drJbaY9+pDVDPZ/QKtLHKNCpsTA6//uSZIEE9GAuRhNfzIAAAA0gAAABEnjLFK588sAAADSAAAAEdTXMSKxfop3DPM5RNbal/EvU7p6/Ie/t93Z1v6OqEAzmEmBoIQcGTCwGMCghPwvOQgUwEbKMZBgNAwOPZioUiMIl/ACXRGoREDB0clmTLApMiq4x2azRlmMM7NijivBEQxUIGvMGdAsjAxgHcDSxgRZANSYAOAgYs0FXAnwaIl43xAcuEVEogHIiFKRHEuREzUfFfSOoEgRyTk8Isema00Fl0gzqujqL/ZT3Krfoq7r1H/AvWzp/yXv/3f/oA0GjFwIZS19BgKAsiCDxuUBAMZ8D6zIZAIFMChweF7GFbQAITYoiSSSvMRBoUJ5l4RGVzOa2hhmAr6mbNSaYcYlxgqAvmAaCEYDAE6yBgAFIpAsGADyaXw+/MSnONGVBjhuNW+/dbYnEQqJJNwIgainmo0TB3Ofkus/yHs5P3dnW/+ryf+QqTEFNRTMuMTAwqqqqqqqqqqqqAABjBgrdYuwIwHSioNCCFkYbBZpMaoVDIRMDhB326ByJkJgYuGdC4P/7kmSwDPT4N0MLn6SAAAANIAAAARDIpRJOePLAAAA0gAAABDAGIA0YOGJhoVGKx+YbQxu2mmHbCT5rII6wYW2ASgYFJDgHYBAIpMARM6WcpEFALUjnWoXbkbwf8AGkx+2FugJGw/l2gIK+vverzfFet8Re/kur09f/f/u6f/1GySAhOMFigxOOnJAAdLIIqmTCCa9ahACTDANMqFMLAIQjQw0EVbjH4aOuN8OAgFCBn0sS0GpU0IAjUJ3MCoPaDTTB4AwnIE7MGrBCjAcgE836g5kUx6AtCKkjKElvKarxnFzLOlKRocalMtnabKM6hpYW5TSrdLe1Kop3e+ZWtymHt445fv9Vfyy/Hn5Xv///v1bXt4M9Z7+o729b+K/4b6pMQU1FMy4xMDCqqqqqqqqqqqoAArJ2QY8DbERAFjDyZMdBUwYDwIEDHduP9KsmPhhMKGHR0ZzTg0NTB4kGhkYqgZ2MZGQRUYNHoGXBgA4HWYEoBbGCNgvJhVgV8ZJaR2GsQJb5g5gRMYD+BQmAhADQNAVRoA4EQAOXUBwAkYBsAVr/+5Jk0w/0GynDE59coAAADSAAAAEULMkADn9SAAAANIAAAATsdabY4ta/VUMV5DuqzWuVs3pSSLmoKyJqFQGpUi+IAy2PdQm57ZU/m8oR6dDu/KvzehHpx5O/KkuvNN/o39SX9fblC3lusxd7wMr2zmhS+YLExsQBmRRQGKE6HITacxM2hgy8ATH50NVDsxSlQMPDL4bNJAg7HUAIBQcOjCRbMBtAdDAAACkwB4EWMCzCGTGll+U7EVMUMoPCSjDHgWcwaECqP+mza0I1QpATkY0Sm3lwsB0q0C3xd6GWuF4jEAeiqacWb5bdVxJbap8YzlnZWta3hLq34RaGf5hj3/pZ3HveY/3ku7/5a/7Wf//9/92aGoPcO9Z3nep/9H+mTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqgBOZ2IMSwdMDATGQhDC4ZXKRj8wGMxub0k5717G//uSZPaO9axfvJOfPEAAAA0gAAABFsja3g5/cEAAADSAAAAELQSBSmZKFYVCYsIjBA1MCgYxWdDkBzMRAEwgQDIIBMgFIzWQTUjgPK3c02lpDWsiqM0Ih0w6QzjB4BzMDcD4wFgEzAfAeQQs8TcsNydp+n5wlq8UapFM2auMpwfZrv475ll25Y5ll3mtzMuwCWO8Ocqe/lndv+j/b1f6/9QATU2x0wCPIAYTCoUHAxhIYX2MXBDC24mvTCAedLotPVa09tEZwuBrSZmkoXXBgkY2SmmPBjQkpGrwfaYZQGhQDcPACJNPw90xLlijCVZWUifsophFk7ww7v7fGk6gE/vB+l0VNkSFwo0bYXJC6gyQQEiwvlDzbHAhHpZLIQbJ1UxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUASWNHVvyNdkdcuCnNLhmA8HuRIHbo/1AhfJ9JZVctla8gMQwpDT96eCGcDAGg8qCCIBce3D8P35RGMZXL8gcmxBByacE9hDD09hNohydtFshlp7EeIe9aMiMe/P/7kmTNjPTPJLaLvPDwAAANIAAAAQ/obuBt+FJAAAA0gAAABEchD3bEIchgekEBmZYRmyPAM3j4DJ8fhgfmeIjtD4HTwPAiPgNGB+BAAjtCABG8AwMvgwAEo5cSIfzt69YYDMdo9RxSsKtgIcom1PMylIK9rWkMkKzctAIIkqXCTqLYAoUrBCJrAlHzJipaMuaPvWraLnsMj6ExUtGUZ0ZRnJ7Q6PrnS7VrsC55kSlRyTYjonPkkybMT2AyVMrbMrYly661bq13Fz0K2JlbEdH1zk9ocnsB09CcutLYmj71p7Q6PWDI+hMXWjJ06Mozk9odH0BkfQmLrRlGdE6M5JrhKJzZKPoSSephKVHJlGcmLhkZXJJ9CYnrRkqSmMZybKpMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5Jk7QT0dTc4kxw0ogAADSAAAAEZOaLm5+WQSAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqglFJEIRoPjA2MDYyViqViCJxDHghjyPQ4ioUiYKw4EMzYZXAooDEE1y2zRpTu00acWUWWcacaUWYeWcacJAhYgWJFCRQGIFiBZZRZRZlw7s7PG////s7M7Ozs7M5xpRZR5RRpxZRZh5RRZRbRC1NP///9PKqqq4NNNNRKqJXTTTTVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZIIP9BFGHYksMlIAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==';\n\n/**\n * @typedef initParameters - Parameters for initializing the AudioPeer\n * @type {object}\n * @property {string} targetElementId - target element where new elements will be appended\n * @property {string} siteUrl: the url of the current site\n */\nconst initParameters = {\n  targetElementId: null,\n  siteUrl: null,\n};\n\n/**\n * @class The first layer of abstraction on the PeerJS library.\n * It meant to be extended by the two seperate client classes, Speaker and Listener.\n * It implements the shared methods and properties of both classes.\n */\nclass AudioPeer {\n  /**\n   * Creates an instance of AudioPeer\n   * Takes the url of the current site and a target element where html elements will be appended.\n   * @param {initParameters} params - see type definition for initParameters\n   */\n  constructor(param = initParameters) {\n    // PeerJS\n    /* Create the Peer object for our end of the connection. */\n    this.peer = new (peerjs__WEBPACK_IMPORTED_MODULE_0___default())(null, {debug: 2});\n    this.conn = null;\n    this.lastPeerId = null;\n\n    // Display information to HTML elem with given id\n    this.targetElement = param.targetElementId;\n\n    this.siteUrl = param.siteUrl;\n\n    // Store for all incoming data\n    this.dataStore = [];\n\n    // Create and play sounds using this audio context\n    this.sourceAudioContext = new (window.AudioContext ||\n      window.webkitAudioContext ||\n      window.audioContext)();\n  }\n\n  /**\n   * Helper method to display information to DOM element\n   * @param {string} message\n   * @param {boolean} append\n   */\n  displayUpdate = (message, append = false) => {\n    // If the specified elem exists, update that elem\n    if (document.getElementById(this.targetElement)) {\n      const displayElement = document.getElementById(this.targetElement);\n      if (append) {\n        displayElement.innerText += `\\n${message}`;\n      } else {\n        displayElement.innerText = message;\n      }\n    } else {\n      console.log('MESSAGE: ', message);\n    }\n  };\n\n  /**\n   * Callback method for when a peer connection is lost\n   * saves the last peer id, last server id, and attempts to reconnect\n   */\n  onPeerDisconnected = () => {\n    this.displayUpdate('Connection lost. Please reconnect');\n\n    // Workaround for peer.reconnect deleting previous id\n    this.peer.id = this.lastPeerId;\n    // eslint-disable-next-line no-underscore-dangle\n    this.peer._lastServerId = this.lastPeerId;\n    this.peer.reconnect();\n  };\n\n  /**\n   * Callback method that cleans up after peer connection is closed\n   */\n  onPeerClose = () => {\n    this.displayUpdate('Connection closed');\n    this.conn = null;\n  };\n\n  /**\n   * Helper method for when an error occurs\n   * @param {*} err\n   */\n  onPeerError = err => {\n    this.displayUpdate(err);\n    console.log(`${err}`);\n  };\n\n  /**\n   * Helper method that converts url paramters to an object\n   * @returns {object}\n   */\n  parseURLSearchParams = () =>\n    // SOURCE: chickens, https://stackoverflow.com/questions/8648892/how-to-convert-url-parameters-to-a-javascript-object\n    // eslint-disable-next-line no-restricted-globals\n    Object.fromEntries(new URLSearchParams(location.search));\n\n  /**\n   * Helper method that converts an object to a query string\n   * @param {object} params\n   * @returns {string}\n   */\n  queryStringFromObject = params =>\n    Object.keys(params)\n      .map(key => `${key}=${params[key]}`)\n      .join('&');\n\n  static keypressFeedbackSound = pressFeedbackURI;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AudioPeer);\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/audioPeer.js?");

/***/ }),

/***/ "./src/audioRecorder.js":
/*!******************************!*\
  !*** ./src/audioRecorder.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @class provides a simple interface for recording audio from a microphone\n * using the Media Recorder API.\n */\nclass AudioRecorder {\n  /** @private */\n  #mediaRecorder;\n\n  /** @private */\n  #recordedChunks = [];\n\n  /** @private */\n  #audioBlob;\n\n  /** @private */\n  #audioContext;\n\n  /** @private */\n  #fileReader;\n\n  /** @private */\n  #arrayBuffer;\n\n  /** @private */\n  #recordedSignals = [];\n\n  /**\n   * creates a new AudioRecorder instance. \n   * Sets up the audio context and file reader.\n   */\n  constructor() {\n    this.#audioContext = new (window.AudioContext ||\n      window.webkitAudioContext ||\n      window.audioContext)();\n    this.#fileReader = new FileReader();\n  }\n\n  /**\n   * Event listener triggered when the file reader is done loading\n   * @private\n   */\n  #onFileReaderLoad = () => {\n    // read the file as an array buffer\n    this.#arrayBuffer = this.#fileReader.result;\n\n    // Convert array buffer into audio buffer\n    this.#audioContext.decodeAudioData(this.#arrayBuffer, (audioBuffer) => {\n      // Do something with audioBuffer\n      // TODO: Address the fact that the audio buffer is being continously filled,\n      // we want a new buffer each round.\n      console.log(audioBuffer.getChannelData(0));\n      this.#recordedSignals.push(audioBuffer.getChannelData(0));\n    });\n  };\n\n  /**\n   * Event listener triggered when data is available in the media recorder.\n   * @private\n   * @param {*} e - The event object.\n   */\n  #onRecorderDataAvailable = (e) => {\n    if (e.data.size > 0) this.#recordedChunks.push(e.data);\n  };\n\n  /**\n   * Event listener triggered when the media recorder stops recording.\n   * @private\n   */\n  #onRecorderStop = () => {\n    // Create a blob from the recorded audio chunks\n    this.#audioBlob = new Blob(this.#recordedChunks, {\n      type: \"audio/wav; codecs=MS_PCM\",\n    });\n\n    // Set up file reader on loaded end event\n    this.#fileReader.onloadend = this.#onFileReaderLoad;\n\n    // Load blob\n    this.#fileReader.readAsArrayBuffer(this.#audioBlob);\n  };\n\n  /**\n   * Method to create a media recorder object and set up event listeners.\n   * @private\n   * @param {MediaStream} stream - The stream of audio from the Listener.\n   */\n  #setMediaRecorder = (stream) => {\n    // Create a new MediaRecorder object\n    this.#mediaRecorder = new MediaRecorder(stream, { mimeType: \"audio/webm\" });\n\n    // Add event listeners\n    this.#mediaRecorder.ondataavailable = (e) =>\n      this.#onRecorderDataAvailable(e);\n    this.#mediaRecorder.onstop = () => this.#onRecorderStop();\n  };\n\n  /**\n   * Public method to start the recording process.\n   * @param {MediaStream} stream - The stream of audio from the Listener.\n   */\n  startRecording = (stream) => {\n    // Set up media recorder if needed\n    if (!this.#mediaRecorder) this.#setMediaRecorder(stream);\n    this.#mediaRecorder.start();\n  };\n\n  /**\n   * Method to stop the recording process.\n   * @public\n   */\n  stopRecording = () => {\n    this.#mediaRecorder.stop();\n  };\n\n  getRecordedSignals = (i) => this.#recordedSignals[i];\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AudioRecorder);\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/audioRecorder.js?");

/***/ }),

/***/ "./src/listener.js":
/*!*************************!*\
  !*** ./src/listener.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _audioPeer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audioPeer */ \"./src/audioPeer.js\");\n\n\n/**\n * @class Handles the listener's side of the connection. Responsible for getting access to user's microphone,\n * and initiating a call to the Speaker.\n * @extends AudioPeer\n */\nclass Listener extends _audioPeer__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  /**\n   * Takes a target element where html elements will be appended.\n   * @param {initParameters} params - see type definition for initParameters\n   */\n  constructor(params) {\n    super(params);\n\n    this.startTime = Date.now();\n    this.receiverPeerId = null;\n\n    const urlParameters = this.parseURLSearchParams();\n    this.speakerPeerId = urlParameters.speakerPeerId;\n\n    this.peer.on('open', this.onPeerOpen);\n    this.peer.on('connection', this.onPeerConnection);\n    this.peer.on('disconnected', this.onPeerDisconnected);\n    this.peer.on('close', this.onPeerClose);\n    this.peer.on('error', this.onPeerError);\n  }\n\n  onPeerOpen = id => {\n    console.log('Listener - onPeerOpen');\n    // Workaround for peer.reconnect deleting previous id\n    if (id === null) {\n      this.displayUpdate('Received null id from peer open');\n      this.peer.id = this.lastPeerId;\n    } else {\n      this.lastPeerId = this.peer.id;\n    }\n    this.join();\n  };\n\n  onPeerConnection = connection => {\n    console.log('Listener - onPeerConnection');\n    // Disallow incoming connections\n    connection.on('open', () => {\n      connection.send('Sender does not accept incoming connections');\n      setTimeout(() => {\n        connection.close();\n      }, 500);\n    });\n  };\n\n  onConnData = data => {\n    console.log('Listener - onConnData');\n    // Keypad has received data, namely instructions to update the keypad\n    // TODO generalize to a list of properies\n    const hasSpeakerID = Object.prototype.hasOwnProperty.call(data, 'speakerPeerId');\n    if (!hasSpeakerID) {\n      this.displayUpdate('Error in parsing data received! Must set \"speakerPeerId\" properties');\n    } else {\n      // this.conn.close();\n      console.log(this.speakerPeerId);\n      this.speakerPeerId = data.speakerPeerId;\n      const newParams = {\n        speakerPeerId: this.speakerPeerId,\n      };\n      /*\n      FUTURE does this limit usable environments?\n      ie does this work if internet is lost after initial page load?\n      */\n      window.location.search = this.queryStringFromObject(newParams); // Redirect to correctly constructed keypad page\n    }\n  };\n\n  join = () => {\n    console.log('Listener - join');\n    /**\n     * Create the connection between the two Peers.\n     *\n     * Sets up callbacks that handle any events related to the\n     * connection and data received on it.\n     */\n    // Close old connection\n    if (this.conn) {\n      this.conn.close();\n    }\n    // Create connection to destination peer specified by the query param\n    this.conn = this.peer.connect(this.speakerPeerId, {\n      reliable: true,\n    });\n\n    this.conn.on('open', () => {\n      // console.log(\"TODO Implement real on connection fn\");\n      this.sendSamplingRate();\n      this.openAudioStream();\n    });\n\n    // Handle incoming data (messages only since this is the signal sender)\n    this.conn.on('data', this.onConnData);\n    this.conn.on('close', () => {\n      console.log('Connection closed');\n    });\n  };\n\n  sendSamplingRate = () => {\n    this.displayUpdate('Listener - sendSamplingRate');\n    // const audioCtx = new (window.AudioContext ||\n    //   window.webkitAudioContext ||\n    //   window.audioContext)();\n    this.conn.send({\n      name: 'samplingRate',\n      payload: 3800, //audioCtx.sampleRate,\n    });\n  };\n\n  openAudioStream = async () => {\n    navigator.mediaDevices\n      .getUserMedia({video: false, audio: true})\n      .then(stream => {\n        this.peer.call(this.speakerPeerId, stream); // one-way call\n        console.log('Listener - openAudioStream');\n      })\n      .catch(err => {\n        this.displayUpdate(`error opening audio stream:${err}`);\n      });\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Listener);\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/listener.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Listener\": () => (/* reexport safe */ _listener__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"Speaker\": () => (/* reexport safe */ _speaker__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _listener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listener */ \"./src/listener.js\");\n/* harmony import */ var _speaker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./speaker */ \"./src/speaker.js\");\n\n\n\n\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/main.js?");

/***/ }),

/***/ "./src/mlsGen/mlsGenInterface.js":
/*!***************************************!*\
  !*** ./src/mlsGen/mlsGenInterface.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* eslint-disable prefer-destructuring */\n/* eslint-disable dot-notation */\n// eslint-disable-next-line import/extensions\nconst createMLSGenModule = __webpack_require__(/*! ../../dist/mlsGen.js */ \"./dist/mlsGen.js\");\n\n/**\n * MLSGenInterface provides a class for interfacing with the MLSGen WASM module.\n */\nclass MlsGenInterface {\n  /** @private */\n  static N = 18; // set based on async clock needs\n\n  /** @private */\n  #WASMInstance; // the WASM module instance\n\n  /** @private */\n  #MLSGenInstance; // the MLSGen object instance\n\n  /**\n   * Creates an instance of MlsGenInterface.\n   * Makes a call to the WASM glue code to load the WASM module.\n   */\n  constructor(WASMInstance, sourceSamplingRate, sinkSamplingRate) {\n    this.#WASMInstance = WASMInstance;\n    console.warn('initializing MLSGen, need to manually garbage collect');\n    this.#MLSGenInstance = new this.#WASMInstance['MLSGen'](\n      MlsGenInterface.N,\n      sourceSamplingRate,\n      sinkSamplingRate\n    );\n  }\n\n  /**\n   * Factory function that provide an asynchronous function that fetches the WASM module\n   * and returns a promise that resolves when the module is loaded.\n   * @param {number} sourceSamplingRate - The sampling rate of the source audio.\n   * @param {number} sinkSamplingRate - The sampling rate of the sink audio.\n   * @returns {MlsGenInterface} mlsGenInterface\n   */\n  static factory = async (sourceSamplingRate, sinkSamplingRate) => {\n    if (sourceSamplingRate === undefined || sinkSamplingRate === undefined) {\n      throw new Error('sourceSamplingRate and sinkSamplingRate must be defined');\n    }\n    console.log(`sourceSamplingRate: ${sourceSamplingRate} sinkSamplingRate: ${sinkSamplingRate}`);\n    return new MlsGenInterface(\n      await createMLSGenModule().then(instance => instance),\n      sourceSamplingRate,\n      sinkSamplingRate\n    );\n  };\n\n  /**\n   * A Higher-Order function that takes an async callback function that access the MLSGen object,\n   * providing safe garbage collection.\n   * @param {function} func\n   * @param {array} args\n   */\n  withGarbageCollection = async (func, params) => {\n    try {\n      await func(...params);\n    } catch (error) {\n      console.error(error);\n    } finally {\n      // garbage collect\n      if (\n        this !== undefined &&\n        this !== null &&\n        this.#MLSGenInstance !== undefined &&\n        this.#MLSGenInstance !== null\n      ) {\n        this.#MLSGenInstance['Destruct'](); // Call the destructor\n        this.#MLSGenInstance['delete'](); // Delete the object\n        console.warn(`GARBAGE COLLECTION: deleted MLSGen`);\n        this.#WASMInstance['doLeakCheck'](); // Check for memory leaks\n      }\n    }\n  };\n\n  /**\n   * Calculate and return the Impulse Response of the recorded signal.\n   * @returns\n   */\n  getImpulseResponse = () => this.#MLSGenInstance['getImpulseResponse']();\n\n  /**\n   * Given a recorded MLS signal, this function sets the recordedSignal property of the MLSGen object.\n   * @param {Float32Array} signal\n   */\n  setRecordedSignal = (\n    signal = [\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n      1,\n    ]\n  ) => {\n    // get memory view\n    const recordedSignalMemoryView = this.#MLSGenInstance['getRecordedSignalMemoryView']();\n\n    // iterate and set\n    for (let i = 0; i < signal.length; i += 1) {\n      recordedSignalMemoryView[i] = signal[i];\n    }\n  };\n\n  /**\n   * Calculate the Maximum Length Sequence (MLS) with period P = 2^N - 1\n   * using the MLSGen WASM module.\n   */\n  getMLS = () => this.#MLSGenInstance['getMLS']();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MlsGenInterface);\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/mlsGen/mlsGenInterface.js?");

/***/ }),

/***/ "./src/myCharts.js":
/*!*************************!*\
  !*** ./src/myCharts.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chart.js */ \"./node_modules/chart.js/dist/chart.esm.js\");\n/* eslint-disable import/no-extraneous-dependencies */\n\n\nchart_js__WEBPACK_IMPORTED_MODULE_0__.Chart.register(\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.ArcElement,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.LineElement,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.BarElement,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.PointElement,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.BarController,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.BubbleController,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.DoughnutController,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.LineController,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.PieController,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.PolarAreaController,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.RadarController,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.ScatterController,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.CategoryScale,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.LinearScale,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.LogarithmicScale,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.RadialLinearScale,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.TimeScale,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.TimeSeriesScale,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.Decimation,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.Filler,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.Legend,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.Title,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.Tooltip,\n  chart_js__WEBPACK_IMPORTED_MODULE_0__.SubTitle\n);\n\n/**\n * Charting Class\n */\nclass MyCharts {\n  /**\n   * Constructor\n   */\n  constructor(elementID, label, text, bufferArray) {\n    const signalCopy = [...bufferArray.slice(0, bufferArray.length / 1000)];\n    const labels = [...signalCopy.keys()];\n    this.ctx = document.getElementById(elementID);\n    this.chart = new chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart(this.ctx, {\n      type: 'line',\n      data: {\n        labels,\n        datasets: [\n          {\n            data: signalCopy,\n            label,\n            borderColor: '#3e95cd',\n            fill: false,\n          },\n        ],\n      },\n      options: {\n        title: {\n          display: true,\n          text,\n        },\n      },\n    });\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MyCharts);\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/myCharts.js?");

/***/ }),

/***/ "./src/speaker.js":
/*!************************!*\
  !*** ./src/speaker.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _audioPeer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audioPeer */ \"./src/audioPeer.js\");\n/* harmony import */ var _audioCalibrator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audioCalibrator */ \"./src/audioCalibrator.js\");\n\n\n\nconst QRCode = __webpack_require__(/*! qrcode */ \"./node_modules/qrcode/lib/browser.js\");\n\n// TODO: some of these methods were preimplmented, but appear to be unused, cleanup\n/**\n * @class Handles the speaker's side of the connection. Responsible for initiating the connection,\n * rendering the QRCode, and answering the call.\n * @extends AudioPeer\n */\nclass Speaker extends _audioPeer__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  /**\n   * Takes the url of the current site and a target element where html elements will be appended.\n   * @param {initParameters} params - see type definition for initParameters\n   */\n  constructor(params) {\n    super(params);\n\n    this.siteUrl += '/listener?';\n    this.ac = new _audioCalibrator__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n\n    /* Set up callbacks that handle any events related to our peer object. */\n    this.peer.on('open', this.onPeerOpen);\n    this.peer.on('connection', this.onPeerConnection);\n    this.peer.on('call', this.onPeerCall);\n    this.peer.on('close', this.onPeerClose);\n    this.peer.on('disconnected', this.onPeerDisconnected);\n    this.peer.on('error', this.onPeerError);\n  }\n\n  /**\n   * Called after the peer conncection has been opened.\n   * Generates a QR code for the connection and displays it.\n   */\n  showQRCode = () => {\n    // this.ac.test();\n    // Get query string, the URL parameters to specify a Listener\n    const queryStringParameters = {\n      speakerPeerId: this.peer.id,\n    };\n    const queryString = this.queryStringFromObject(queryStringParameters);\n    const uri = this.siteUrl + queryString;\n\n    // Display QR code for the participant to scan\n    const qrCanvas = document.createElement('canvas');\n    qrCanvas.setAttribute('id', 'qrCanvas');\n    console.log(uri);\n    QRCode.toCanvas(qrCanvas, uri, error => {\n      if (error) console.error(error);\n    });\n\n    // If specified HTML Id is available, show QR code there\n    if (document.getElementById(this.targetElement)) {\n      document.getElementById(this.targetElement).appendChild(qrCanvas);\n    } else {\n      // or just print it to console\n      console.log('TEST: Peer reachable at: ', uri);\n    }\n  };\n\n  /**\n   * Called when the peer connection is opened.\n   * Saves the peer id and calls the QR code generator.\n   * @param {object} peerId - The peer id of the peer connection\n   */\n  onPeerOpen = id => {\n    // Workaround for peer.reconnect deleting previous id\n    if (id === null) {\n      console.error('Received null id from peer open');\n      this.peer.id = this.lastPeerId;\n    } else {\n      this.lastPeerId = this.peer.id;\n    }\n\n    if (id !== this.peer.id) {\n      console.warn('DEBUG Check you assumption that id === this.peer.id');\n    }\n\n    this.showQRCode();\n  };\n\n  /**\n   * Called when the peer connection is established.\n   * Enforces a single connection.\n   * @param {*} connection - The connection object\n   */\n  onPeerConnection = connection => {\n    console.log('Speaker - onPeerConnection');\n\n    // Allow only a single connection\n    if (this.conn && this.conn.open) {\n      connection.on('open', () => {\n        connection.send('Already connected to another client');\n        setTimeout(() => {\n          connection.close();\n        }, 500);\n      });\n      return;\n    }\n\n    this.conn = connection;\n    console.log('Connected to: ', this.conn.peer);\n    this.ready();\n  };\n\n  /**\n   * Called after a call is established and data is flowing.\n   * Sets up the local audio stream and starts the calibration process.\n   * @param {MediaStream} stream - The stream of audio from the Listener.\n   */\n  onReceiveStream = stream => {\n    window.localStream = stream;\n    window.localAudio.srcObject = stream;\n    window.localAudio.autoplay = false;\n\n    // Start calibration\n    if (!this.ac.getCalibrationStatus()) {\n      this.ac.startCalibration(stream);\n    }\n  };\n\n  /**\n   * Called when a call is made by the Listener.\n   * Answers the call in a one-way manner, and sets up a stream listener.\n   * @param {*} call\n   */\n  onPeerCall = call => {\n    call.answer(); // Answer the call (one way)\n    this.ac.createLocalAudio(document.getElementById(this.targetElement));\n    call.on('stream', this.onReceiveStream);\n  };\n\n  /**\n   * Called when the peer connection is closed.\n   */\n  onPeerClose = () => {\n    this.conn = null;\n    console.log('Connection destroyed');\n  };\n\n  /**\n   * Called when the peer connection is disconnected.\n   * Attempts to reconnect.\n   */\n  onPeerDisconnected = () => {\n    console.log('Connection lost. Please reconnect');\n\n    // Workaround for peer.reconnect deleting previous id\n    this.peer.id = this.lastPeerId;\n    // eslint-disable-next-line no-underscore-dangle\n    this.peer._lastServerId = this.lastPeerId;\n    this.peer.reconnect();\n  };\n\n  /**\n   * Called when the peer connection encounters an error.\n   * @param {*} error\n   */\n  onPeerError = error => {\n    // TODO: check if this function is needed or not\n    console.error(error);\n  };\n\n  /**\n   * Called when data is received from the peer connection.\n   * @param {*} data\n   */\n  onIncomingData = data => {\n    // enforce object type\n    if (\n      !Object.prototype.hasOwnProperty.call(data, 'name') ||\n      !Object.prototype.hasOwnProperty.call(data, 'payload')\n    ) {\n      console.error('Received malformed data: ', data);\n      return;\n    }\n    // handle sampling rate sent from Listener\n    if (data.name === 'samplingRate') {\n      this.ac.setSinkSamplingRate(data.payload);\n    }\n  };\n\n  /**\n   * Called when the peer connection is ready.\n   */\n  ready = () => {\n    // Perform callback with data\n    this.conn.on('data', this.onIncomingData);\n    this.conn.on('close', () => {\n      console.log('Connection reset<br>Awaiting connection...');\n      this.conn = null;\n    });\n  };\n}\n\n/* \nReferenced links:\nhttps://stackoverflow.com/questions/28016664/when-you-pass-this-as-an-argument/28016676#28016676\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\nhttps://stackoverflow.com/questions/879152/how-do-i-make-javascript-beep [3]\n*/\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Speaker);\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/speaker.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"sleep\": () => (/* binding */ sleep),\n/* harmony export */   \"visualize\": () => (/* binding */ visualize)\n/* harmony export */ });\nconst targetElementId = 'viz';\n\n/**\n * Utility function to visualize audio data\n * @param {*} targetAnalyser\n */\nconst visualize = targetAnalyser => {\n  const analyser = targetAnalyser;\n  const canvas = document.createElement('canvas');\n  const canvasCtx = canvas.getContext('2d');\n  document.getElementById(targetElementId).appendChild(canvas);\n\n  analyser.fftSize = 2048;\n\n  const bufferLength = analyser.frequencyBinCount;\n  const dataArray = new Uint8Array(bufferLength);\n\n  // eslint-disable-next-line require-jsdoc\n  const draw = () => {\n    const WIDTH = canvas.width;\n    const HEIGHT = canvas.height;\n\n    requestAnimationFrame(draw);\n\n    analyser.getByteTimeDomainData(dataArray);\n\n    canvasCtx.fillStyle = 'rgb(200, 200, 200)';\n    canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);\n\n    canvasCtx.lineWidth = 2;\n    canvasCtx.strokeStyle = 'rgb(0, 0, 0)';\n\n    canvasCtx.beginPath();\n\n    const sliceWidth = (WIDTH * 1.0) / bufferLength;\n    let x = 0;\n\n    for (let i = 0; i < bufferLength; i += 1) {\n      const v = dataArray[i] / 128.0;\n      const y = (v * HEIGHT) / 2;\n\n      if (i === 0) {\n        canvasCtx.moveTo(x, y);\n      } else {\n        canvasCtx.lineTo(x, y);\n      }\n\n      x += sliceWidth;\n    }\n\n    canvasCtx.lineTo(canvas.width, canvas.height / 2);\n    canvasCtx.stroke();\n  };\n\n  draw();\n};\n\n/**\n * Utlity function to pause execution for a given time\n * @param {number} seconds\n * @returns {Promise}\n */\nconst sleep = seconds =>\n  new Promise(resolve => {\n    setTimeout(resolve, seconds * 1000);\n  });\n\n\n\n\n//# sourceURL=webpack://speakerCalibrator/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});